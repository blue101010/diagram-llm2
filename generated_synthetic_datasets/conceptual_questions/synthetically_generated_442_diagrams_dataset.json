[
    {
        "diagram_type": "architecture",
        "prompt": "Generate a Mermaid architecture diagram for a simple E-commerce application backend showing user authentication, product catalog, shopping cart, and checkout modules.",
        "planning": "*   **User:** Initiates actions (login, browse, add to cart, checkout).\n*   **Authentication Module:**\n    *   Receives user credentials.\n    *   Authenticates user against database.\n    *   Returns authentication token/status.\n*   **Product Catalog Module:**\n    *   Retrieves product information from database.\n    *   Provides product details to User.\n*   **Shopping Cart Module:**\n    *   Stores cart items (user-specific).\n    *   Manages adding/removing items.\n    *   Retrieves cart contents on request (from User/Checkout).\n*   **Checkout Module:**\n    *   Receives cart items and user information (from User/Shopping Cart).\n    *   Processes payment (simulated).\n    *   Creates order.\n    *   Updates inventory (simulated).\n*   **Database:** Stores user data, product catalog, order information.\n*   **API Gateway:** Entry point for all requests, routes to appropriate modules. (Optional, but good practice)\n\nInteractions:\n\n1.  User -> API Gateway (or directly to module)\n2.  API Gateway -> Specific Module (Authentication, Product Catalog, Shopping Cart, Checkout)\n3.  Module <-> Database\n4.  Checkout -> Shopping Cart (to retrieve cart details)",
        "output": "```mermaid\narchitecture-beta\n    group backend(cloud)[E-commerce Backend]\n\n    service user(user)[User] \n    service api_gateway(internet)[API Gateway] in backend\n    service auth_module(server)[Authentication] in backend\n    service product_catalog(server)[Product Catalog] in backend\n    service shopping_cart(server)[Shopping Cart] in backend\n    service checkout_module(server)[Checkout] in backend\n    service database(database)[Database] in backend\n\n    user:R --> L:api_gateway\n    api_gateway:R --> L:auth_module\n    api_gateway:R --> L:product_catalog\n    api_gateway:R --> L:shopping_cart\n    api_gateway:R --> L:checkout_module\n\n    auth_module:B -- T:database\n    product_catalog:B -- T:database\n    shopping_cart:B -- T:database\n    checkout_module:B -- T:database\n\n    checkout_module:L --> R:shopping_cart\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Create a Mermaid architecture diagram for a chat application backend demonstrating real-time message processing, user sessions, and message storage components.",
        "planning": "*   **User:** Initiates messages and maintains sessions.\n\n*   **Client (e.g., Web/Mobile App):** Interface for user interaction. Connects to WebSocket server.\n\n*   **WebSocket Server:** Handles real-time communication, manages user connections and sessions. Relays messages.\n\n*   **Message Router/Broker (e.g., Kafka, RabbitMQ):** Distributes messages to appropriate processing components.\n\n*   **Message Processing Service:** Performs tasks like filtering, moderation, and data enrichment.\n\n*   **Database (e.g., PostgreSQL, MongoDB):** Stores messages and user data.\n\n*   **Session Store (e.g., Redis):** Manages user sessions for authentication and authorization.\n\n*   **Interaction Flow:**\n    *   User sends message -> Client -> WebSocket Server -> Message Router\n    *   Message Router -> Message Processing Service\n    *   Message Processing Service -> Database\n    *   Message Router -> WebSocket Server -> Client (other users)\n    *   User Authentication -> WebSocket Server -> Session Store",
        "output": "```mermaid\narchitecture-beta\n    group client_group(cloud)[Client]\n\n    service user(user)[User] in client_group\n    service client_app(mobile)[Client App] in client_group\n\n    group backend(server)[Backend]\n\n    service ws_server(server)[WebSocket Server] in backend\n    service message_router(message)[Message Router] in backend\n    service processing_service(process)[Message Processing Service] in backend\n    service database(database)[Database] in backend\n    service session_store(database)[Session Store] in backend\n\n    user:R -- L:client_app\n    client_app:R -- L:ws_server\n    ws_server:R --> L:message_router\n    message_router:R --> L:processing_service\n    processing_service:R --> L:database\n    message_router:R --> R:ws_server\n    ws_server:B --> T:session_store\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Design a Mermaid architecture diagram of a microservices-based blogging platform that includes a front-end, API Gateway, and separate services for posts, comments, and user management.",
        "planning": "*   **Front-end:**\n    *   User interface (web/mobile).\n    *   Interacts with the API Gateway.\n\n*   **API Gateway:**\n    *   Entry point for all requests.\n    *   Routes requests to appropriate microservices.\n    *   Handles authentication/authorization (optionally).\n\n*   **Posts Service:**\n    *   Manages blog post creation, retrieval, update, and deletion (CRUD).\n    *   Database for storing posts.\n\n*   **Comments Service:**\n    *   Manages comments on blog posts.\n    *   Database for storing comments.\n    *   Interacts with Posts service (to associate comments with posts).\n\n*   **User Management Service:**\n    *   Handles user registration, login, and profile management.\n    *   Database for storing user data.\n    *   Provides authentication/authorization information to API Gateway.\n\n*   **Interactions:**\n    *   Front-end -> API Gateway (HTTP requests).\n    *   API Gateway -> Microservices (HTTP requests).\n    *   Microservices -> Databases (Database queries).\n    *   (Optional) Inter-service communication (e.g., Posts service might notify Comments service when a new post is created).",
        "output": "```mermaid\narchitecture-beta\n    group infrastructure(cloud)[Infrastructure]\n\n    service frontend(browser)[Front-End] in infrastructure\n    service api_gateway(gateway)[API Gateway] in infrastructure\n\n    group backend(cloud)[Backend Services]\n\n    service posts_service(server)[Posts Service] in backend\n    service comments_service(server)[Comments Service] in backend\n    service user_service(server)[User Management] in backend\n\n    database posts_db(database)[Posts Database] in backend\n    database comments_db(database)[Comments Database] in backend\n    database user_db(database)[User Database] in backend\n\n    frontend:R --> L:api_gateway\n\n    api_gateway:R --> L:posts_service\n    api_gateway:R --> L:comments_service\n    api_gateway:R --> L:user_service\n\n    posts_service:R --> L:posts_db\n    comments_service:R --> L:comments_db\n    user_service:R --> L:user_db\n\n    comments_service:L -- R:posts_service\n\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Provide a Mermaid architecture diagram for a RESTful API design for a weather forecasting service including API Gateway, data ingestion, processing engine, and database storage.",
        "planning": "*   **Client:** Represents users/applications requesting weather data. Interacts with API Gateway.\n*   **API Gateway:** Entry point for all requests. Routes requests to the appropriate service. Handles authentication, rate limiting, and request transformation.\n*   **Data Ingestion:** Collects raw weather data from external sources (e.g., weather stations, satellites). Pushes data to the Processing Engine.\n*   **Processing Engine:** Transforms, cleans, and aggregates raw data into a usable format (e.g., calculates forecasts). Stores processed data in the Database.\n*   **Database:** Stores processed weather data. Accessed by the API Gateway (via the Processing Engine indirectly) to serve requests.\n*   **Data Sources:** External sources of raw weather data. Feeds data to the Data Ingestion component.\n\n**Interactions:**\n\n1.  Client -> API Gateway (Request Weather Data)\n2.  API Gateway -> Processing Engine (Forward Request)\n3.  Processing Engine -> Database (Query Data)\n4.  Database -> Processing Engine (Return Data)\n5.  Processing Engine -> API Gateway (Return Processed Data)\n6.  API Gateway -> Client (Return Response)\n7.  Data Sources -> Data Ingestion (Push Raw Data)\n8.  Data Ingestion -> Processing Engine (Push Raw Data)\n9. Processing Engine -> Database (Store Processed Data)",
        "output": "architecture-beta\n    group infrastructure(cloud)[Weather Service Infrastructure]\n\n    service client(users)[Client Application] \n    service api_gateway(cloud)[API Gateway] in infrastructure\n    service data_ingestion(server)[Data Ingestion] in infrastructure\n    service processing_engine(server)[Processing Engine] in infrastructure\n    service database(database)[Database] in infrastructure\n    service data_sources(internet)[Data Sources]\n\n    client:R --> L:api_gateway:L\n    api_gateway:R --> L:processing_engine:L\n    processing_engine:R --> L:database:L\n    database:L --> R:processing_engine:R\n    processing_engine:R --> L:api_gateway:R\n    api_gateway:R --> L:client:R\n    data_sources:R --> L:data_ingestion:L\n    data_ingestion:R --> L:processing_engine:L\n\n    processing_engine:B --> T:database:T"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Draw a Mermaid architecture diagram for a RAG-based (Retrieve and Generate) question-answering system demonstrating components for data retrieval, language model processing, and response generation.",
        "planning": "*   **Data Source(s):** Indicate various potential data sources (e.g., Document Database, Webpages, Knowledge Graph) feeding into the RAG system.\n*   **Data Ingestion:** Shows documents being added to the vector store\n*   **Text Chunking:** Represents splitting documents into smaller, manageable chunks.\n*   **Embedding Model:** Embeds the chunks and the user's query into vector representations.\n*   **Vector Store:** Stores the embedded chunks for efficient similarity search.\n*   **Similarity Search:** Finds the most relevant chunks based on the user query's embedding.\n*   **Prompt Engineering:** Combining the user query and retrieved documents into a prompt.\n*   **Large Language Model (LLM):** Processes the prompt and generates an answer.\n*   **Response Generation:** Formats and presents the answer to the user.\n*   **User Interface:** User enters prompt which goes to similarity search, then LLM, then receive the response.",
        "output": "```mermaid\narchitecture-beta\n    group data_sources(cloud)[Data Sources]\n    service doc_db(database)[Document Database] in data_sources\n    service web_pages(internet)[Webpages] in data_sources\n    service knowledge_graph(database)[Knowledge Graph] in data_sources\n\n    service data_ingestion(server)[Data Ingestion]\n    service text_chunking(server)[Text Chunking]\n    service embedding_model(server)[Embedding Model]\n    service vector_store(database)[Vector Store]\n    service similarity_search(server)[Similarity Search]\n    service prompt_engineer(server)[Prompt Engineering]\n    service llm(server)[Large Language Model]\n    service response_gen(server)[Response Generation]\n    service user_interface(internet)[User Interface]\n\n    doc_db:R --> L:data_ingestion\n    web_pages:R --> L:data_ingestion\n    knowledge_graph:R --> L:data_ingestion\n\n    data_ingestion:R --> L:text_chunking\n    text_chunking:R --> L:embedding_model\n    embedding_model:R --> L:vector_store\n    vector_store:R --> L:similarity_search\n    similarity_search:R --> L:prompt_engineer\n    prompt_engineer:R --> L:llm\n    llm:R --> L:response_gen\n    response_gen:R --> L:user_interface\n\n    user_interface:L --> R:similarity_search\n    user_interface:L --> R:llm\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Sketch a Mermaid architecture diagram for a secure file storage system with components for user authentication, file upload/download service, and metadata storage.",
        "planning": "*   **User:** Initiates login, upload, and download requests.\n\n*   **Authentication Service:**\n    *   Authenticates user credentials.\n    *   Issues access tokens upon successful authentication.\n\n*   **API Gateway:**\n    *   Receives all external requests (login, upload, download).\n    *   Validates access tokens.\n    *   Routes requests to appropriate services.\n\n*   **File Upload/Download Service:**\n    *   Handles file uploads and downloads.\n    *   Stores files in Object Storage.\n    *   Retrieves files from Object Storage.\n\n*   **Object Storage:**\n    *   Stores the actual file data (e.g., AWS S3, Google Cloud Storage, Azure Blob Storage).\n    *   Provides scalability and durability.\n\n*   **Metadata Storage:**\n    *   Stores file metadata (e.g., filename, user ID, upload date, file size, access permissions, encryption keys location).\n    *   Database or similar (e.g., PostgreSQL, MySQL).\n\n*   **Encryption Service:**\n    *   Encrypts files before storing in Object Storage.\n    *   Decrypts files before download.\n    *   Manages encryption keys. (Can be combined with metadata storage.)\n\n**Interactions:**\n\n1.  User -> API Gateway: Login request.\n2.  API Gateway -> Authentication Service: Authenticate user.\n3.  Authentication Service -> API Gateway: Return access token.\n4.  User -> API Gateway: Upload/Download request (with access token).\n5.  API Gateway -> File Upload/Download Service: Route request.\n6.  File Upload/Download Service <-> Encryption Service: Encrypt/Decrypt File\n7.  File Upload/Download Service <-> Object Storage: Store/Retrieve File.\n8.  File Upload/Download Service <-> Metadata Storage: Store/Retrieve file metadata.\n9.  API Gateway -> User: Return response.",
        "output": "```mermaid\narchitecture-beta\n    group security(cloud)[Security]\n    group core(cloud)[Core Services]\n    group storage(cloud)[Storage Layer]\n\n    service user(user)[User] \n    service api_gateway(router)[API Gateway] in core\n    service auth_service(lock)[Authentication Service] in security\n    service file_service(file-upload)[File Upload/Download Service] in core\n    service object_storage(database)[Object Storage] in storage\n    service metadata_storage(database)[Metadata Storage] in storage\n    service encryption_service(key)[Encryption Service] in security\n\n    user:R --> L:api_gateway:T\n    api_gateway:R --> L:auth_service:T\n    auth_service:R --> L:api_gateway:B\n    api_gateway:R --> L:file_service:T\n    file_service:L <-> R:encryption_service:T\n    file_service:L <-> R:object_storage:T\n    file_service:L <-> R:metadata_storage:T\n    api_gateway:B --> T:user\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Generate a Mermaid architecture diagram for a simple movie recommendation engine showing user profiling, recommendation algorithm, and content management service.",
        "planning": "**Components:**\n\n*   **User:** Represents the end user interacting with the system.\n*   **User Interface (UI):**  Entry point for user interaction.\n*   **User Profiling Service:**  Responsible for building and maintaining user profiles.\n*   **Recommendation Algorithm:**  Generates movie recommendations based on user profiles and movie data.\n*   **Content Management Service (CMS):** Stores and manages movie data (metadata, descriptions, etc.).\n*   **Database:** Persistent storage for user profiles and movie data.\n\n**Interactions:**\n\n1.  **User -> UI:** User interacts with the UI (e.g., browsing, rating movies).\n2.  **UI -> User Profiling Service:** UI sends user activity data to the User Profiling Service.\n3.  **User Profiling Service -> Database:** User Profiling Service stores/updates user profiles in the Database.\n4.  **Recommendation Algorithm -> User Profiling Service:** Recommendation Algorithm retrieves user profile from the User Profiling Service.\n5.  **Recommendation Algorithm -> CMS:** Recommendation Algorithm queries the CMS for movie data.\n6.  **CMS -> Database:** CMS retrieves movie data from the Database.\n7.  **Recommendation Algorithm -> UI:** Recommendation Algorithm sends movie recommendations to the UI.\n8.  **UI -> User:** UI displays movie recommendations to the User.",
        "output": "```mermaid\narchitecture-beta\n    group infrastructure(cloud)[Infrastructure]\n\n    service user(user)[User] \n    service ui(window)[User Interface]\n    service user_profile(profile)[User Profiling Service] in infrastructure\n    service recommendation(algorithm)[Recommendation Algorithm] in infrastructure\n    service cms(content)[Content Management Service] in infrastructure\n    service db(database)[Database] in infrastructure\n\n    user:R --> L:ui : Interaction\n    ui:R --> L:user_profile : User Activity\n    user_profile:R --> L:db : Store Profile\n    recommendation:L --> R:user_profile : Get Profile\n    recommendation:T --> B:cms : Query Movie Data\n    cms:R --> L:db : Retrieve Data\n    recommendation:R --> L:ui : Send Recommendations\n    ui:L --> R:user : Display Recommendations\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Construct a Mermaid architecture diagram for an IoT-based smart home system with sensor data collection, central processing unit, and a visualization dashboard.",
        "planning": "**Components:**\n\n*   **Sensors:** Collect data (temperature, light, motion).\n*   **IoT Gateway:** Receives data from sensors, pre-processes, transmits.\n*   **Central Processing Unit (Cloud/Local Server):** Receives, analyzes, stores sensor data.\n*   **Database:** Stores processed sensor data.\n*   **Visualization Dashboard:** Displays data insights, user interface.\n*   **User Device:** Access dashboard (phone, tablet, computer).\n\n**Interactions:**\n\n*   Sensors -> IoT Gateway: Data transmission.\n*   IoT Gateway -> Central Processing Unit: Data transmission.\n*   Central Processing Unit -> Database: Data storage.\n*   Database -> Central Processing Unit: Data retrieval.\n*   Central Processing Unit -> Visualization Dashboard: Data transmission.\n*   User Device -> Visualization Dashboard: Request and receive data.\n*   User Device -> Central Processing Unit: Send commands (optional).",
        "output": "architecture-beta\n    group smartHome(cloud)[Smart Home System]\n\n    service sensors(internet)[Sensors]\n    service iotGateway(server)[IoT Gateway] in smartHome\n    service cpu(server)[Central Processing Unit] in smartHome\n    service database(database)[Database] in smartHome\n    service dashboard(disk)[Visualization Dashboard] in smartHome\n    service userDevice(internet)[User Device]\n\n    sensors:R --> L:iotGateway\n    iotGateway:R --> L:cpu\n    cpu:R --> L:database\n    database:R --> L:cpu\n    cpu:R --> L:dashboard\n    userDevice:R --> L:dashboard\n    userDevice:R --> L:cpu"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Provide a Mermaid architecture diagram for a blockchain-based digital voting platform detailing nodes, consensus mechanism, and secure storage modules.",
        "planning": "*   **User Interface (UI):**\n    *   Interaction: Users interact with the platform to register, authenticate, view ballots, and cast votes.\n    *   Details: Represents web/mobile app.\n*   **Voting Node:**\n    *   Interaction: Receives votes from UI, validates, and propagates to other nodes. Participates in consensus.\n    *   Details: Core blockchain node.\n*   **Blockchain Network:**\n    *   Interaction: Interconnects voting nodes for data replication and consensus.\n    *   Details: P2P network linking nodes.\n*   **Consensus Mechanism:**\n    *   Interaction: Ensures agreement on valid transactions (votes) among nodes.\n    *   Details: Algorithm (e.g., PoS, Raft) used for block creation.\n*   **Secure Storage Module:**\n    *   Interaction: Stores the blockchain data (blocks of votes) and user data (hashed passwords).\n    *   Details: Database or distributed ledger.\n*   **Smart Contract Module:**\n    *   Interaction: Enforces voting rules and tallies votes.\n    *   Details: Contains the election logic.\n*   **Identity Management Module:**\n    *   Interaction: Manages user identity verification and authentication.\n    *   Details: Integrates with digital ID systems.",
        "output": "```mermaid\narchitecture-beta\n    group voting_platform(cloud)[Voting Platform]\n\n    service ui(internet)[User Interface] in voting_platform\n    service voting_node(server)[Voting Node] in voting_platform\n    service blockchain(database)[Blockchain Network]\n    service consensus(gear)[Consensus Mechanism] in voting_platform\n    service secure_storage(disk)[Secure Storage] in voting_platform\n    service smart_contract(contract)[Smart Contract Module] in voting_platform\n    service identity_mgmt(users)[Identity Management] in voting_platform\n\n    ui:R --> L:voting_node\n    voting_node:R -- L:blockchain\n    voting_node:B -- T:consensus\n    blockchain:B -- T:secure_storage\n    smart_contract:R -- L:blockchain\n    identity_mgmt:R -- L:ui\n    smart_contract:T -- B:consensus\n    identity_mgmt:B -- T:voting_node\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Produce a Mermaid architecture diagram for a serverless image processing pipeline showing front-end upload mechanism, API Gateway, serverless functions, and cloud storage.",
        "planning": "*   **User:** Interacts with the front-end.\n*   **Front-end (Web/App):** Provides UI for image upload; communicates with API Gateway.\n*   **API Gateway:** Receives upload requests; routes to serverless function.\n*   **Serverless Function (Upload):** Handles initial upload, pre-processing if needed; saves image metadata and original image location to database/storage, triggers processing function.\n*   **Serverless Function (Processing):** Receives trigger from upload function or storage event; performs image processing tasks (e.g., resizing, format conversion, watermarking).\n*   **Cloud Storage (Original Images):** Stores original uploaded images.\n*   **Cloud Storage (Processed Images):** Stores processed images.\n*   **Database (Optional):** Stores image metadata, processing status, links to original and processed images.\n*   **Communication:**\n    *   User -> Front-end: Upload request.\n    *   Front-end -> API Gateway: HTTP request (POST image).\n    *   API Gateway -> Serverless (Upload): Invokes function.\n    *   Serverless (Upload) -> Cloud Storage: Saves original image.\n    *   Serverless (Upload) -> Serverless (Processing) / Cloud Storage Event: Trigger processing.\n    *   Serverless (Processing) -> Cloud Storage: Saves processed images.\n    *   Serverless (Processing) -> Database: Updates image metadata (optional).\n    *   Front-end -> API Gateway: HTTP request (GET image).\n    *   API Gateway -> Serverless Function: Invokes function.\n    *   Serverless Function -> Database/Cloud Storage: retrieves image.\n    *   Serverless Function -> API Gateway: Sends image URL.\n    *   API Gateway -> Front-end: Sends image URL.",
        "output": "```mermaid\narchitecture-beta\n    group user_group(cloud)[User]\n\n    service frontend(browser)[Front-end]\n    service api_gw(cloud)[API Gateway]\n    service upload_func(serverlessFunction)[Upload Function]\n    service processing_func(serverlessFunction)[Processing Function]\n    service original_storage(disk)[Original Images]\n    service processed_storage(disk)[Processed Images]\n\n    frontend in user_group\n\n    frontend:R --> L:api_gw\n    api_gw:R --> L:upload_func\n    upload_func:R --> L:original_storage\n    upload_func:B --> T:processing_func\n    processing_func:R --> L:processed_storage\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Develop a Mermaid architecture diagram for an online exam system including modules for user authentication, exam administration, and result processing.",
        "planning": "**Components:**\n\n*   **User:** Represents the exam taker or administrator.\n*   **Browser/Client:** User interface for interacting with the system.\n*   **Load Balancer:** Distributes traffic to multiple web servers.\n*   **Web Server:** Handles HTTP requests.\n*   **User Authentication Module:** Manages user login and authentication.\n*   **Exam Administration Module:** Creates, updates, and manages exams.\n*   **Exam Database:** Stores exam questions, answers, and metadata.\n*   **Result Processing Module:** Calculates scores and generates reports.\n*   **Result Database:** Stores exam results.\n*   **Cache:** Temporary storage for frequently accessed data.\n\n**Interactions:**\n\n1.  **User** interacts with **Browser/Client**.\n2.  **Browser/Client** sends requests to **Load Balancer.**\n3.  **Load Balancer** forwards request to **Web Server**.\n4.  **Web Server** communicates with **User Authentication Module** for login/authentication.\n5.  **Web Server** communicates with **Exam Administration Module** for exam creation/management.\n6.  **Exam Administration Module** reads/writes to **Exam Database.**\n7.  **Web Server** retrieves exam data from **Exam Database** or **Cache**.\n8.  **Web Server** sends exam to **Browser/Client**.\n9.  **Browser/Client** submits answers to **Web Server**.\n10. **Web Server** sends answers to **Result Processing Module**.\n11. **Result Processing Module** reads exam data from **Exam Database** and writes results to **Result Database**.\n12. **User** can view results from **Result Database** via **Web Server** and **Browser/Client**.",
        "output": "```mermaid\narchitecture-beta\n    group infrastructure(cloud)[Infrastructure]\n\n    service user(user)[User]\n    service browser(browser)[Browser Client]\n    service loadbalancer(server)[Load Balancer] in infrastructure\n    service webserver(server)[Web Server] in infrastructure\n    service cache(database)[Cache] in infrastructure\n\n    group authentication(cloud)[Authentication] in infrastructure\n    service authmodule(server)[Auth Module] in authentication\n\n    group exam_management(cloud)[Exam Management] in infrastructure\n    service examadmin(server)[Exam Admin Module] in exam_management\n    service examdb(database)[Exam Database] in exam_management\n\n    group result_processing(cloud)[Result Processing] in infrastructure\n    service resultprocess(server)[Result Processing Module] in result_processing\n    service resultdb(database)[Result Database] in result_processing\n\n    user:R --> L:browser\n    browser:R --> L:loadbalancer\n    loadbalancer:R --> L:webserver\n\n    webserver:L --> R:authmodule\n    webserver:L --> R:examadmin\n    examadmin:R --> L:examdb\n    webserver:R --> L:examdb\n    webserver:R --> L:cache\n\n    webserver:B --> T:browser\n    browser:L --> R:webserver\n\n    webserver:R --> L:resultprocess\n    resultprocess:R --> L:examdb\n    resultprocess:R --> L:resultdb\n\n    webserver:L --> R:resultdb\n    browser:L --> R:webserver\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Design a Mermaid architecture diagram for a decoupled content management system with a front-end interface, back-end service layer, and persistent database.",
        "planning": "*   **Front-end Interface (Client):**\n    *   Represents the user-facing application (e.g., website, mobile app).\n    *   Interacts with the Back-end Service Layer via API calls (HTTP requests).\n    *   Displays content retrieved from the back-end.\n\n*   **Back-end Service Layer (API):**\n    *   Acts as an intermediary between the Front-end and the Database.\n    *   Receives requests from the Front-end.\n    *   Handles business logic (e.g., content retrieval, creation, modification).\n    *   Interacts with the Persistent Database to store and retrieve data.\n    *   Returns data to the Front-end in a structured format (e.g., JSON).\n\n*   **Persistent Database:**\n    *   Stores the content and related data.\n    *   Receives requests from the Back-end Service Layer (CRUD operations).\n    *   Returns data to the Back-end Service Layer.\n    *   Could be a relational database (e.g., PostgreSQL, MySQL) or a NoSQL database (e.g., MongoDB).",
        "output": "architecture-beta\n    group client(cloud)[Front-end Interface]\n    group api(cloud)[Back-end Service Layer]\n    group db_group(database)[Persistent Database]\n\n    service frontend(browser)[Client App] in client\n    service backend(server)[API Service] in api\n    service database(database)[Database] in db_group\n\n    frontend:R --> L:backend\n    backend:R --> L:database"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Sketch a Mermaid architecture diagram for a food delivery application backend demonstrating restaurant listings, order management system, and payment gateway integration.",
        "planning": "*   **Components:**\n    *   User Interface (UI): Represents user interaction (e.g., mobile app).\n    *   API Gateway: Entry point for all requests.\n    *   Restaurant Service: Manages restaurant data (listings, menus).\n    *   Order Management Service: Handles order placement, tracking, and updates.\n    *   Payment Service: Integrates with payment gateways for processing transactions.\n    *   Database (Restaurant, Order, User data): Stores persistent data.\n\n*   **Interactions:**\n    1.  UI -> API Gateway: User requests restaurant listings, places orders.\n    2.  API Gateway -> Restaurant Service: Fetches restaurant data.\n    3.  API Gateway -> Order Management Service: Creates, updates, and retrieves order information.\n    4.  Order Management Service -> Restaurant Service:  Checks restaurant availability, menu details.\n    5.  Order Management Service -> Payment Service: Initiates payment processing.\n    6.  Payment Service -> Payment Gateway: Communicates with external payment providers (Stripe, PayPal).\n    7.  Restaurant Service -> Database: Stores restaurant data.\n    8. Order Management Service -> Database: Stores Order data.\n    9. API Gateway -> User Service (optional): User Authentication/Authorization.",
        "output": "architecture-beta\n    group infrastructure(cloud)[Infrastructure]\n\n    service ui(computer)[User Interface] in infrastructure\n    service api_gateway(cloud)[API Gateway] in infrastructure\n    service restaurant_service(server)[Restaurant Service] in infrastructure\n    service order_management(server)[Order Management] in infrastructure\n    service payment_service(server)[Payment Service] in infrastructure\n    service restaurant_db(database)[Restaurant DB] in infrastructure\n    service order_db(database)[Order DB] in infrastructure\n    service payment_gateway(internet)[Payment Gateway] in infrastructure\n    service user_service(server)[User Service] in infrastructure\n\n\n    ui:R --> L:api_gateway\n    api_gateway:R --> L:restaurant_service\n    api_gateway:R --> L:order_management\n    order_management:R --> L:restaurant_service\n    order_management:R --> L:payment_service\n    payment_service:R --> L:payment_gateway\n    restaurant_service:R --> L:restaurant_db\n    order_management:R --> L:order_db\n    api_gateway:R --> L:user_service"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Provide a Mermaid architecture diagram for a ridesharing service backend detailing user management, ride matching engine, and payment processing module.",
        "planning": "*   **User App (Client):**\n    *   Initiates requests (ride requests, profile updates, payment info).\n    *   Receives ride details, driver information, and payment confirmations.\n\n*   **Driver App (Client):**\n    *   Receives ride requests.\n    *   Updates location.\n    *   Manages ride status.\n\n*   **API Gateway:**\n    *   Entry point for all client requests.\n    *   Routes requests to appropriate services.\n    *   Handles authentication and authorization.\n\n*   **User Management Service:**\n    *   Handles user registration, login, profile management.\n    *   Stores user data (profile, payment methods, ride history).\n    *   Interacts with the API Gateway for authentication.\n\n*   **Ride Matching Engine:**\n    *   Receives ride requests from the API Gateway.\n    *   Matches riders with available drivers based on location, availability, and other criteria.\n    *   Communicates ride details to both rider and driver apps via API Gateway.\n\n*   **Location Service:**\n    *   Tracks driver and rider locations.\n    *   Provides location data to the Ride Matching Engine.\n\n*   **Payment Processing Module:**\n    *   Handles payment transactions.\n    *   Integrates with payment gateways (e.g., Stripe, PayPal).\n    *   Communicates with User Management Service to retrieve payment information.\n\n*   **Database:**\n    *   Stores user data, ride data, location data, and payment information.\n    *   Accessed by User Management Service, Ride Matching Engine, Location Service, and Payment Processing Module.",
        "output": "```mermaid\narchitecture-beta\n    group clients(users)[Clients]\n\n    service user_app(mobile)[User App] in clients\n    service driver_app(mobile)[Driver App] in clients\n\n    group backend(cloud)[Backend]\n\n    service api_gateway(gateway)[API Gateway] in backend\n    service user_mgmt(users)[User Management Service] in backend\n    service ride_match(engine)[Ride Matching Engine] in backend\n    service location_srv(location)[Location Service] in backend\n    service payment_proc(payment)[Payment Processing Module] in backend\n    service database(database)[Database] in backend\n\n    user_app:R --> L:api_gateway\n    driver_app:R --> L:api_gateway\n    api_gateway:R --> L:user_mgmt\n    api_gateway:R --> L:ride_match\n    api_gateway:R --> L:payment_proc\n    ride_match:R --> L:location_srv\n    user_mgmt:R --> L:database\n    ride_match:R --> L:database\n    location_srv:R --> L:database\n    payment_proc:R --> L:database\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Generate a Mermaid architecture diagram for a customer support ticketing system using microservices, showing user portal, ticket routing, and resolution management.",
        "planning": "*   **User Portal:**\n    *   Component: User Interface (web/app)\n    *   Interaction: Submits tickets to Ticket Ingestion Service. Receives ticket status updates from Notification Service.\n\n*   **Ticket Ingestion Service:**\n    *   Component: API endpoint\n    *   Interaction: Receives tickets from User Portal. Sends tickets to Ticket Routing Service.\n\n*   **Ticket Routing Service:**\n    *   Component: Rule Engine\n    *   Interaction: Receives tickets from Ticket Ingestion. Routes tickets to appropriate Agent Assignment Service.\n\n*   **Agent Assignment Service:**\n    *   Component: Algorithm for agent selection\n    *   Interaction: Receives tickets from Ticket Routing. Assigns tickets to agents and notifies them via Notification Service.\n\n*   **Resolution Management Service:**\n    *   Component: API and data storage for ticket details\n    *   Interaction: Stores and updates ticket information. Agents interact with this service to resolve tickets.\n\n*   **Notification Service:**\n    *   Component: Handles sending notifications (email, SMS, etc.)\n    *   Interaction: Receives notification requests from Agent Assignment Service (agent assignment), Resolution Management Service (status updates), and potentially directly from other services or backend process (e.g. SLA breaches).\n\n*   **Database(s):**\n    *   Component: Data storage.\n    *   Interaction: Resolution Management Service stores ticket details and history, Agent info, etc.",
        "output": "architecture-beta\n    group user_interaction(cloud)[User Interaction]\n    group ticket_processing(cloud)[Ticket Processing]\n    group backend_services(cloud)[Backend Services]\n\n    service user_portal(internet)[User Portal] in user_interaction\n    service ticket_ingestion(server)[Ticket Ingestion] in ticket_processing\n    service ticket_routing(server)[Ticket Routing] in ticket_processing\n    service agent_assignment(server)[Agent Assignment] in ticket_processing\n    service resolution_management(database)[Resolution Management] in backend_services\n    service notification_service(server)[Notification Service] in backend_services\n    service database(database)[Database] in backend_services\n\n    user_portal:B --> T:ticket_ingestion\n    ticket_ingestion:B --> T:ticket_routing\n    ticket_routing:B --> T:agent_assignment\n    agent_assignment:B --> T:notification_service\n    agent_assignment:R --> L:resolution_management\n    resolution_management:R --> L:database\n    user_portal:R --> L:notification_service\n    resolution_management:T --> B:notification_service"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Create a Mermaid architecture diagram for a social media analytics platform demonstrating data ingestion, processing engine, and a visualization dashboard.",
        "planning": "*   **Data Sources:**\n    *   Social Media APIs (e.g., Twitter API, Facebook Graph API, Instagram API). Interaction: Data Flowing In.\n    *   Data Lakes/Warehouses (Optional, for historical data). Interaction: Data Flowing In.\n\n*   **Data Ingestion Layer:**\n    *   Data Connectors/Extractors: Fetches data from various sources. Interaction: Pushes data to Message Queue.\n    *   Message Queue (e.g., Kafka, RabbitMQ): Buffers and distributes data streams. Interaction: Feeds data to Processing Engine.\n\n*   **Processing Engine:**\n    *   Data Processing Framework (e.g., Spark, Flink): Performs transformations, aggregations, and analysis. Interaction: Receives data from Message Queue, outputs to Database.\n    *   Data Storage (e.g., NoSQL database, TimescaleDB): Stores processed data. Interaction: Receives data from Processing Framework, sends data to Visualization Dashboard.\n\n*   **Visualization Dashboard:**\n    *   API Endpoint: Serves processed data to the UI. Interaction: Queries Database, sends data to UI.\n    *   User Interface: Displays analytics and visualizations. Interaction: User interacts with UI, UI requests data from API Endpoint.",
        "output": "architecture-beta\n    group dataSources(cloud)[Data Sources]\n\n    service socialMediaApis(internet)[Social Media APIs] in dataSources\n    service dataLakes(database)[Data Lakes Warehouses] in dataSources\n\n    group dataIngestion(cloud)[Data Ingestion]\n\n    service dataConnectors(server)[Data Connectors Extractors] in dataIngestion\n    service messageQueue(database)[Message Queue] in dataIngestion\n\n    group processingEngine(cloud)[Processing Engine]\n\n    service dataProcessing(server)[Data Processing Framework] in processingEngine\n    service dataStorage(database)[Data Storage] in processingEngine\n\n    group visualization(cloud)[Visualization Dashboard]\n\n    service apiEndpoint(server)[API Endpoint] in visualization\n    service userInterface(internet)[User Interface] in visualization\n\n    socialMediaApis:B --> T:dataConnectors\n    dataLakes:B --> T:dataConnectors\n    dataConnectors:R --> L:messageQueue\n    messageQueue:B --> T:dataProcessing\n    dataProcessing:R --> L:dataStorage\n    dataStorage:B --> T:apiEndpoint\n    apiEndpoint:R --> L:userInterface"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Outline a Mermaid architecture diagram for an e-learning platform with components for course management, user enrollment, and progress tracking.",
        "planning": "*   **User:** Interacts with the platform (e.g., browsing courses, enrolling, viewing progress).\n*   **Course Catalog:** Displays available courses; interacts with Course Management.\n*   **Course Management:** Creates, updates, and manages course content; interacts with Course Catalog and Enrollment.\n*   **Enrollment:** Handles user enrollment in courses; interacts with User and Course Management.\n*   **Learning Management System (LMS):** Delivers course content, tracks user activity, and assesses progress; interacts with Enrollment and Progress Tracking.\n*   **Progress Tracking:** Records user progress and performance within courses; interacts with LMS and User.\n*   **Database:** Stores all platform data (courses, users, enrollment, progress). All mentioned components interact with it.",
        "output": "```mermaid\narchitecture-beta\n    group platform(cloud)[E-Learning Platform]\n\n    service user(internet)[User] in platform\n    service course_catalog(disk)[Course Catalog] in platform\n    service course_management(server)[Course Management] in platform\n    service enrollment(server)[Enrollment] in platform\n    service lms(server)[LMS] in platform\n    service progress_tracking(disk)[Progress Tracking] in platform\n    service database(database)[Database] in platform\n\n    user:R --> L:course_catalog\n    course_catalog:R --> L:course_management\n    course_management:R --> L:enrollment\n    enrollment:R --> L:lms\n    lms:R --> L:progress_tracking\n    progress_tracking:R --> L:user\n\n    course_management:B --> T:database\n    enrollment:B --> T:database\n    lms:B --> T:database\n    progress_tracking:B --> T:database\n    course_catalog:B --> T:database\n    user:B --> T:database\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Develop a Mermaid architecture diagram for a multiplayer online game server architecture illustrating game state management, real-time communication, and player databases.",
        "planning": "*   **Players:** Represents online players.\n    *   Interacts with: Game Clients.\n\n*   **Game Clients:** Player's game application.\n    *   Interacts with: Load Balancer, Authentication Server.\n\n*   **Load Balancer:** Distributes client connections.\n    *   Interacts with: Game Servers, Authentication Server.\n\n*   **Authentication Server:** Verifies player credentials.\n    *   Interacts with: Load Balancer, Player Database.\n\n*   **Game Servers:** Manage game logic and state for game instances.\n    *   Interacts with: Load Balancer, Real-Time Communication Server, Game State Database.\n\n*   **Real-Time Communication Server:** Handles low-latency communication between clients and servers.\n    *   Interacts with: Game Servers, Game Clients.\n\n*   **Game State Database:** Stores persistent game world data.\n    *   Interacts with: Game Servers.\n\n*   **Player Database:** Stores player accounts and profiles.\n    *   Interacts with: Authentication Server.",
        "output": "```mermaid\narchitecture-beta\n    service players(users)[Players]\n    service game_clients(desktop)[Game Clients]\n    service load_balancer(router)[Load Balancer]\n    service auth_server(lock)[Authentication Server]\n    service game_servers(server)[Game Servers]\n    service comm_server(message)[Real-Time Communication Server]\n    service game_db(database)[Game State Database]\n    service player_db(database)[Player Database]\n\n    game_clients:L -- R:load_balancer\n    load_balancer:L -- R:game_servers\n    load_balancer:T -- B:auth_server\n    auth_server:R -- L:player_db\n    game_servers:R -- L:comm_server\n    game_servers:B -- T:game_db\n    comm_server:R -- L:game_clients\n    players:R -- L:game_clients\n    auth_server:T -- B:load_balancer\n\n```"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Draw a Mermaid architecture diagram for an email newsletter service with modules for subscription management, email dispatch engine, and performance analytics.",
        "planning": "*   **User:** Initiates subscription/unsubscription. Interacts with Subscription Management. Receives emails dispatched by Email Dispatch Engine.\n\n*   **Subscription Management:** Handles user subscriptions (add/remove). Stores subscription data (email, preferences). Communicates with User and Email Dispatch Engine.\n\n*   **Email Dispatch Engine:** Receives email content and subscriber list from Subscription Management. Sends emails to Users. Sends email delivery status to Performance Analytics.\n\n*   **Performance Analytics:** Receives data from Email Dispatch Engine (delivery status, opens, clicks). Stores and analyzes email performance data. Potentially provides reports/dashboards (not explicitly shown as interacting with other modules in the diagram, but implied output).",
        "output": "architecture-beta\n    group user_group(cloud)[User]\n    group subscription_group(cloud)[Subscription Management]\n    group dispatch_group(cloud)[Email Dispatch Engine]\n    group analytics_group(cloud)[Performance Analytics]\n\n    service user(person)[User] in user_group\n    service subscription(database)[Subscription Data] in subscription_group\n    service dispatch(server)[Email Dispatch] in dispatch_group\n    service analytics(database)[Analytics Data] in analytics_group\n\n    user:R --> L:subscription{group}\n    subscription{group}:R --> L:dispatch{group}\n    dispatch{group}:R --> L:user\n    dispatch{group}:B --> T:analytics{group}"
    },
    {
        "diagram_type": "architecture",
        "prompt": "Generate a Mermaid architecture diagram for a healthcare appointment management system including modules for patient registration, scheduling, and notifications.",
        "planning": "*   **Patient Registration Module:**\n    *   Components: Patient Information Form, Validation, Database Storage.\n    *   Interaction: Takes patient data, validates it, stores it in the Patient Database.\n\n*   **Scheduling Module:**\n    *   Components: Appointment Calendar, Doctor Availability, Appointment Booking.\n    *   Interaction: Reads doctor availability, allows booking appointments, updates the Appointment Database. Interacts with Patient Database to link appointments to patients.\n\n*   **Notifications Module:**\n    *   Components: SMS Gateway, Email Service, Notification Templates.\n    *   Interaction: Retrieves appointment details from Appointment Database. Sends appointment reminders and confirmations to patients via SMS and Email. Interacts with Patient Database to retrieve contact details.\n\n*   **Databases:**\n    *   Patient Database: Stores patient demographics and contact information.\n    *   Appointment Database: Stores appointment schedules, doctor assignments, and status.\n\n*   **External Actor:**\n    *   Patient: Interacts with Patient Registration and Scheduling modules.\n\n*   **Key Interactions:**\n    *   Patient Registration writes to Patient Database.\n    *   Scheduling reads from Patient Database and writes to Appointment Database.\n    *   Notifications read from Patient Database and Appointment Database, then communicates with SMS Gateway/Email Service.\n    *   Patient interacts with Patient Registration and Scheduling modules.",
        "output": "```mermaid\narchitecture-beta\n    group patient_registration(cloud)[Patient Registration]\n    group scheduling(cloud)[Scheduling]\n    group notifications(cloud)[Notifications]\n\n    service patient_info(file)[Patient Information Form] in patient_registration\n    service validation(check)[Validation] in patient_registration\n\n    service appointment_calendar(calendar)[Appointment Calendar] in scheduling\n    service doctor_availability(clock)[Doctor Availability] in scheduling\n    service appointment_booking(edit)[Appointment Booking] in scheduling\n\n    service sms_gateway(sms)[SMS Gateway] in notifications\n    service email_service(email)[Email Service] in notifications\n    service notification_templates(template)[Notification Templates] in notifications\n\n    service patient_db(database)[Patient Database]\n    service appointment_db(database)[Appointment Database]\n\n    service patient(user)[Patient]\n\n    patient_info:R -- L:validation\n    validation:R --> T:patient_db\n\n    doctor_availability:R -- L:appointment_calendar\n    appointment_calendar:R -- L:appointment_booking\n    appointment_booking:R --> T:appointment_db\n\n    appointment_booking:T --> L:patient_db\n\n    notification_templates:R -- L:sms_gateway\n    notification_templates:R -- L:email_service\n\n    sms_gateway:T --> B:appointment_db\n    email_service:T --> B:patient_db\n\n    patient:R --> T:patient_registration\n    patient:R --> T:scheduling\n\n    scheduling:T --> T:patient_db\n    notifications:T --> T:appointment_db\n\n```"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram explaining the TCP three-way handshake process for establishing a connection.",
        "planning": "*   **Client:** The initiating machine.\n*   **Server:** The machine listening for connection requests.\n*   **SYN (Synchronize):** Packet sent from the client to the server.\n*   **SYN-ACK (Synchronize-Acknowledge):** Packet sent from the server to the client.\n*   **ACK (Acknowledge):** Packet sent from the client to the server.\n*   **Interaction 1:** Client sends SYN to Server.\n*   **Interaction 2:** Server responds with SYN-ACK to Client.\n*   **Interaction 3:** Client sends ACK to Server, connection established.",
        "output": "block-beta\n  columns 3\n  Client space:3 Server\n  space:3 blockArrowId1<[\"SYN\"]>(down)\n  ClientSYN[\"SYN\"] space:3 ServerSYN[\"SYN\"] \n  Client --> ServerSYN\n  space:3 blockArrowId2<[\"SYN-ACK\"]>(down)\n  ClientSYNACK[\"SYN-ACK\"] space:3 ServerSYNACK[\"SYN-ACK\"]\n  ServerSYNACK --> ClientSYNACK\n  space:3 blockArrowId3<[\"ACK\"]>(down)\n  ClientACK[\"ACK\"] space:3 ServerACK[\"ACK\"]\n  ClientACK --> ServerACK\n  style Client fill:#ccf,stroke:#333,stroke-width:2px\n  style Server fill:#fcc,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram illustrating the data packet exchange mechanism in TCP data transmission.",
        "planning": "*   **Sender Application:** Source of data. Sends data to TCP.\n\n*   **TCP (Sender):**\n    *   Receives data from the application.\n    *   Segments data into TCP segments.\n    *   Adds TCP header (Seq. Number, Ack. Number, Flags, etc.).\n    *   Sends segments to IP layer.\n\n*   **IP Layer (Sender):**\n    *   Receives TCP segments.\n    *   Adds IP header (Source & Destination IP addresses).\n    *   Sends IP packets over the network.\n\n*   **Network (Conceptual):** Represents the network path.\n\n*   **IP Layer (Receiver):**\n    *   Receives IP packets.\n    *   Removes IP header.\n    *   Forwards TCP segments to TCP layer.\n\n*   **TCP (Receiver):**\n    *   Receives TCP segments.\n    *   Reassembles segments based on sequence numbers.\n    *   Sends ACK (Acknowledgment) segments back to the sender (with Ack Number).\n    *   Delivers reassembled data to the receiver application.\n\n*   **Receiver Application:** Receives the ordered data stream.\n\n*   **ACK Segments:** Show ACK segments flowing from the TCP (Receiver) back to the TCP (Sender). Include the Ack Number in these ACK segments. Arrows should clearly show the direction.",
        "output": "block-beta\n  columns 3\n  SenderApp[/'Sender Application: Source of data' /] space Net space ReceiverApp[/'Receiver Application: Receives ordered data' /]\n  down1<['Data']>(down) space down2<['Network Path']>(down) down3<['Data Stream']>(down)\n  TCPSender[/'TCP Sender: Segments data, adds TCP header'/] space IPlayerReceiver[/'IP Layer Receiver: Removes IP header'/]  TCPEndReceiver[/'TCP Receiver: Reassembles segments, sends ACK'/]\n  down4<['TCP Segments']>(down) space down5<['IP Packets']>(down) down6<['Reassembled Data']>(down)\n  IPlayerSender[/'IP Layer Sender: Adds IP header'/] space space\n  IPlayerSender -- \"IP Packets\" --> IPlayerReceiver\n  TCPSender -- \"TCP Segments\" --> IPlayerSender\n  IPlayerReceiver -- \"TCP Segments\" --> TCPEndReceiver\n  TCPEndReceiver -- \"ACK Segments\" --> TCPSender\n\n  classDef senderFill fill:#ccf,stroke:#333;\n  classDef receiverFill fill:#fcc,stroke:#333;\n  class SenderApp,TCPSender,IPlayerSender senderFill\n  class ReceiverApp,TCPEndReceiver,IPlayerReceiver receiverFill"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram showing the flow of OAuth authentication in an E-commerce application.",
        "planning": "*   **User:** Initiates the login/authorization process.\n*   **E-commerce Application (Client):** The application the user is trying to access.\n*   **Authorization Server:** Issues access tokens (e.g., Google, Facebook, your own auth server).\n*   **Resource Server:** Hosts the user's data that the E-commerce Application needs to access (can be the same as the Authorization Server or separate).\n\n**Interaction Flow:**\n\n1.  User tries to access protected resource in E-commerce Application.\n2.  E-commerce Application redirects User to Authorization Server for authentication.\n3.  User authenticates with Authorization Server.\n4.  Authorization Server redirects User back to E-commerce Application with an authorization code.\n5.  E-commerce Application exchanges authorization code for access token and optionally refresh token with Authorization Server.\n6.  E-commerce Application uses access token to request protected resources from Resource Server.\n7.  Resource Server validates access token and provides the protected resource to the E-commerce Application.\n8.  E-commerce Application displays requested resource to the User.",
        "output": "block-beta\n  columns 3\n  User space App space AuthServer space ResourceServer\n  \n  User[\"1. Access Resource\"] --> App\n  App --> AuthServer[\"2. Redirect to Auth Server\"]\n  AuthServer --> User[\"3. Authenticate\"]\n  User --> App[\"4. Auth Code\"]\n  App --> AuthServer[\"5. Exchange Code for Token\"]\n  AuthServer --> App[\"Access Token\"]\n  App --> ResourceServer[\"6. Request Resource\"]\n  ResourceServer --> App[\"7. Provide Resource\"]\n  App --> User[\"8. Display Resource\"]\n\n  classDef actor fill:#f9f,stroke:#333,stroke-width:2px\n  class User actor"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram depicting the sequence of steps in the RSA cryptography algorithm.",
        "planning": "*   **Key Generation:**\n    *   Input: Security parameter (bit length).\n    *   Process: Prime number generation, modulus calculation (n = p*q), totient calculation (phi(n) = (p-1)*(q-1)), choose public exponent 'e' (1 < e < phi(n), gcd(e, phi(n)) = 1), calculate private exponent 'd' (d*e \u2261 1 mod phi(n)).\n    *   Output: Public key (n, e), Private key (n, d).\n\n*   **Encryption:**\n    *   Input: Plaintext 'M', Public key (n, e).\n    *   Process: Ciphertext 'C' = M^e mod n.\n    *   Output: Ciphertext 'C'.\n\n*   **Decryption:**\n    *   Input: Ciphertext 'C', Private key (n, d).\n    *   Process: Plaintext 'M' = C^d mod n.\n    *   Output: Plaintext 'M'.",
        "output": "block-beta\n  columns 3\n\n  %% Key Generation\n  KeyGenInput[/'Security Parameter\n  Bit Length'/] space KeyGenProcess[\n    Prime Generation\n    n = p*q\n    phi(n) = (p-1)*(q-1)\n    Choose e\n    Calculate d\n  ] space KeyGenOutput[/'Public Key: n, e\nPrivate Key: n, d'/]\n\n  %% Encryption\n  EncryptionInput[/'Plaintext M\nPublic Key: n, e'/] space EncryptionProcess[/'Ciphertext C =\nM^e mod n'/] space EncryptionOutput[/'Ciphertext C'/]\n\n  %% Decryption\n  DecryptionInput[/'Ciphertext C\nPrivate Key: n, d'/] space DecryptionProcess[/'Plaintext M =\nC^d mod n'/] space DecryptionOutput[/'Plaintext M'/]\n\n  %% Connections\n  KeyGenInput --> KeyGenProcess\n  KeyGenProcess --> KeyGenOutput\n\n  EncryptionInput --> EncryptionProcess\n  EncryptionProcess --> EncryptionOutput\n\n  DecryptionInput --> DecryptionProcess\n  DecryptionProcess --> DecryptionOutput"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram representing the hierarchical organization of CPU pipeline stages in a simple computer architecture.",
        "planning": "**Block Diagram Plan: CPU Pipeline Stages**\n\n1.  **Instruction Fetch (IF):**\n    *   Input: Program Counter (PC)\n    *   Output: Instruction\n    *   Interaction: PC provides address; IF fetches instruction from memory.\n\n2.  **Instruction Decode (ID):**\n    *   Input: Instruction\n    *   Output: Control signals, register operands\n    *   Interaction: Decodes instruction; reads registers.\n\n3.  **Execute (EX):**\n    *   Input: Control signals, register operands, immediate values\n    *   Output: ALU result, branch target address\n    *   Interaction: Performs ALU operations, calculates addresses.\n\n4.  **Memory Access (MEM):**\n    *   Input: ALU result (address), data to write\n    *   Output: Data from memory (for load instructions)\n    *   Interaction: Reads/writes data from/to memory.\n\n5.  **Write Back (WB):**\n    *   Input: ALU result, data from memory\n    *   Output: Updated register values\n    *   Interaction: Writes result back to register file.\n\n**Interactions & Control:**\n\n*   Pipeline registers between each stage to hold data.\n*   Control unit providing control signals to each stage.\n*   Forwarding paths to resolve data hazards (show direct connections from EX/MEM/WB to ID/EX).\n*   Stall logic to handle data hazards and control hazards (branch misprediction).\n\n**Simplified Representation:** Focus on the data flow and key control dependencies.\n\n**Note:** Do not include the \"PC Update Logic\" (where PC gets updated) in the drawing, as that is an implementation detail rather than the stage itself.",
        "output": "```mermaid\nblock-beta\n  columns 5\n  IF[\\\"Instruction Fetch\\\"] space ID[\\\"Instruction Decode\\\"] space EX[\\\"Execute\\\"] space MEM[\\\"Memory Access\\\"] space WB[\\\"Write Back\\\"]\n\n  %% Forwarding paths\n  EX --> ID\n  MEM --> ID\n  WB --> ID\n\n  %% Arrows to show data flow within pipeline stages\n  style IF fill:#ccf,stroke:#333\n  style ID fill:#ccf,stroke:#333\n  style EX fill:#ccf,stroke:#333\n  style MEM fill:#ccf,stroke:#333\n  style WB fill:#ccf,stroke:#333\n\n  %% Pipeline Registers between stages\n  IF -.- ID\n  ID -.- EX\n  EX -.- MEM\n  MEM -.- WB\n```"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram illustrating the core components of a chat application server architecture.",
        "planning": "*   **Clients (Users):** Represented as blocks (e.g., \"User A,\" \"User B\"). Interaction: Connects to the Load Balancer/API Gateway.\n\n*   **Load Balancer/API Gateway:** A central entry point. Interaction: Distributes traffic to the Application Servers, handles authentication, and potentially rate limiting.\n\n*   **Application Servers:** Processes client requests (sending/receiving messages, managing chat rooms). Interaction: Communicates with the Database, Message Queue, and potentially other internal services.\n\n*   **Database:** Stores user data, message history, chat room information. Interaction: Accessed by Application Servers for data persistence and retrieval.\n\n*   **Message Queue (e.g., Redis, RabbitMQ):** Facilitates real-time message delivery. Interaction: Application Servers publish messages to the queue; other Application Servers subscribe to the queue to receive messages for relevant clients.\n\n*   **Presence Service (Optional):** Tracks user online/offline status. Interaction: Application Servers update and query the presence service.  Clients can subscribe to presence updates.",
        "output": "block-beta\n  columns 5\n\n  UserA[\"User A\"] space UserB[\"User B\"] space UserN[\"User N\"] space Lb[\"Load Balancer/API Gateway\"] space Ps[\"Presence Service\"]\n\n  down1 blockArrowId6<[\"\"]>(down)\n  down2 blockArrowId6<[\"\"]>(down)\n  down3 blockArrowId6<[\"\"]>(down)\n  down4 blockArrowId6<[\"\"]>(down)\n\n  AppServer1[\"Application Server 1\"] space AppServer2[\"Application Server 2\"] space AppServerN[\"Application Server N\"] space Db[\"Database\"]\n\n  down5 blockArrowId6<[\"\"]>(down)\n  down6 blockArrowId6<[\"\"]>(down)\n  down7 blockArrowId6<[\"\"]>(down)\n\n  Mq[\"Message Queue\"]\n\n  UserA --> Lb\n  UserB --> Lb\n  UserN --> Lb\n\n  Lb --> AppServer1\n  Lb --> AppServer2\n  Lb --> AppServerN\n\n  AppServer1 --> Db\n  AppServer2 --> Db\n  AppServerN --> Db\n\n  AppServer1 --> Mq\n  AppServer2 --> Mq\n  AppServerN --> Mq\n  \n  AppServer1 --> Ps\n  AppServer2 --> Ps\n  AppServerN --> Ps"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram showing the workflow of data distribution in a load balancing system for web applications.",
        "planning": "*   **Client:** Represents the user making requests.\n*   **Load Balancer:** The central component distributing traffic.\n*   **Web Servers:** Multiple servers hosting the web application.\n*   **Interaction:**\n    *   Client sends request to Load Balancer.\n    *   Load Balancer selects a Web Server based on algorithm.\n    *   Load Balancer forwards request to the selected Web Server.\n    *   Web Server processes request and sends response back to Load Balancer.\n    *   Load Balancer forwards response back to the Client.",
        "output": "```mermaid\nblock-beta\n  columns 3\n  Client space LoadBalancer space WebServer1\n  space downArrow1<[\" \"]>(down)\n  space WebServer2 space\n\n  Client --> LoadBalancer\n  LoadBalancer --> WebServer1\n  WebServer1 --> LoadBalancer\n  LoadBalancer --> Client\n\n  LoadBalancer --> WebServer2\n  WebServer2 --> LoadBalancer\n\n  classDef process fill:#ccf,stroke:#333,stroke-width:2px;\n  class Client,WebServer1, WebServer2, LoadBalancer process\n\n```"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram representing a Kanban board workflow for managing Software Development tasks.",
        "planning": "*   **Columns:** Represent stages of the workflow (e.g., Backlog, Ready, In Development, In Testing, Done).\n*   **Tasks (Cards):** Represent individual software development tasks or user stories.\n*   **Swimlanes (Optional):** Horizontal lanes to categorize tasks (e.g., by feature, priority, or team).\n*   **Kanban Board:** The visual representation of the workflow, containing the columns, tasks, and swimlanes.\n*   **Workflow:** Tasks move from left to right across the columns, representing progress through the development stages. Arrows show the flow.\n*   **Limits (WIP Limits):** Numerical constraints on the number of tasks allowed in each column, displayed on top of each column.\n*   **Input Queue (Backlog):** tasks are added here initially.\n*   **Output (Done):** Tasks are moved here when completed.",
        "output": "block-beta\n  columns 5\n  Backlog space Ready space \"In Development\" space \"In Testing\" space Done\n  blockArrowId1<[\" \"]>(down) blockArrowId2<[\" \"]>(down) blockArrowId3<[\" \"]>(down) blockArrowId4<[\" \"]>(down) blockArrowId5<[\" \"]>(down)\n  Task1 space Task2 space Task3 space Task4 space Task5\n  style Backlog fill:#ccf,stroke:#333\n  style Ready fill:#ccf,stroke:#333\n  style \"In Development\" fill:#ccf,stroke:#333\n  style \"In Testing\" fill:#ccf,stroke:#333\n  style Done fill:#ccf,stroke:#333\n  style Task1 fill:#fff,stroke:#333,stroke-width:1px\n  style Task2 fill:#fff,stroke:#333,stroke-width:1px\n  style Task3 fill:#fff,stroke:#333,stroke-width:1px\n  style Task4 fill:#fff,stroke:#333,stroke-width:1px\n  style Task5 fill:#fff,stroke:#333,stroke-width:1px"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram illustrating the process of encryption and decryption using the AES algorithm.",
        "planning": "*   **Encryption Side:**\n    *   **Plaintext:** Input data to be encrypted.\n    *   **Key:** Secret key used for encryption.\n    *   **Initial Round Key Addition:** XOR plaintext with the initial round key derived from the Key Schedule.\n    *   **Rounds (Multiple):** Series of transformations.\n        *   **SubBytes:** Byte substitution using S-box.\n        *   **ShiftRows:** Cyclic shift of bytes in each row.\n        *   **MixColumns:** Column mixing using matrix multiplication (omitted in the last round).\n        *   **AddRoundKey:** XOR with round key derived from the Key Schedule.\n    *   **Key Schedule:** Generates round keys from the main Key.\n    *   **Ciphertext:** Output encrypted data.\n\n*   **Decryption Side:**\n    *   **Ciphertext:** Input encrypted data.\n    *   **Key:** Same secret key used for encryption.\n    *   **Initial Round Key Addition (Inverse):** XOR ciphertext with the final round key (from Key Schedule's end).\n    *   **Rounds (Multiple):** Inverse transformations of encryption rounds.\n        *   **InvShiftRows:** Inverse of ShiftRows.\n        *   **InvSubBytes:** Inverse of SubBytes.\n        *   **AddRoundKey:** XOR with round key (in reverse order from Key Schedule).\n        *   **InvMixColumns:** Inverse of MixColumns (omitted in the last round).\n    *   **Key Schedule:** Generates round keys (used in reverse order for decryption).\n    *   **Plaintext:** Output decrypted data.\n\n*   **Interactions:**\n    *   Plaintext/Ciphertext flow through the rounds in sequence.\n    *   Key Schedule provides round keys for each round of both encryption and decryption (different order).\n    *   Each round transformation builds on the previous one.",
        "output": "block-beta\n  columns 7\n  plaintext[\"Plaintext\"] space key[\"Key\"] space ciphertext[\"Ciphertext\"] space key2[\"Key\"] space decrypted_text[\"Plaintext\"]\n\n  initial_round[\"Initial Round Key Addition\"] space key_schedule[\"Key Schedule\"] space inv_initial_round[\"Initial Round Key Addition \\n Inverse\"] space key_schedule2[\"Key Schedule\"]\n\n  sub_bytes[\"SubBytes\"] space  inv_sub_bytes[\"InvSubBytes\"]\n  shift_rows[\"ShiftRows\"] space  inv_shift_rows[\"InvShiftRows\"]\n  mix_columns[\"MixColumns\"] space  inv_mix_columns[\"InvMixColumns\"]\n  add_round_key[\"AddRoundKey\"] space  add_round_key2[\"AddRoundKey\"]\n\n  EncRoundLable[\"Encryption Rounds\"] DecRoundLable[\"Decryption Rounds\"]\n  EndCipher[\"Ciphertext\"]\n\n\n  plaintext --> initial_round\n  key --> key_schedule\n  initial_round --> sub_bytes\n  sub_bytes --> shift_rows\n  shift_rows --> mix_columns\n  mix_columns --> add_round_key\n  add_round_key --> EndCipher\n  EndCipher --> ciphertext\n  ciphertext --> inv_initial_round\n  key2 --> key_schedule2\n  inv_initial_round --> inv_shift_rows\n  inv_shift_rows --> inv_sub_bytes\n  inv_sub_bytes --> add_round_key2\n  add_round_key2 --> inv_mix_columns\n  inv_mix_columns --> decrypted_text\n\n\n\n  style plaintext fill:#ccf,stroke:#333,stroke-width:2px\n  style key fill:#ccf,stroke:#333,stroke-width:2px\n  style ciphertext fill:#ccf,stroke:#333,stroke-width:2px\n  style key2 fill:#ccf,stroke:#333,stroke-width:2px\n  style decrypted_text fill:#ccf,stroke:#333,stroke-width:2px\n  style initial_round fill:#ffc,stroke:#333,stroke-width:2px\n  style key_schedule fill:#ffc,stroke:#333,stroke-width:2px\n  style inv_initial_round fill:#ffc,stroke:#333,stroke-width:2px\n  style key_schedule2 fill:#ffc,stroke:#333,stroke-width:2px\n  style sub_bytes fill:#cff,stroke:#333,stroke-width:2px\n  style shift_rows fill:#cff,stroke:#333,stroke-width:2px\n  style mix_columns fill:#cff,stroke:#333,stroke-width:2px\n  style add_round_key fill:#cff,stroke:#333,stroke-width:2px\n  style inv_sub_bytes fill:#cff,stroke:#333,stroke-width:2px\n  style inv_shift_rows fill:#cff,stroke:#333,stroke-width:2px\n  style inv_mix_columns fill:#cff,stroke:#333,stroke-width:2px\n  style add_round_key2 fill:#cff,stroke:#333,stroke-width:2px\n  style EncRoundLable fill:#afa,stroke:#333,stroke-width:2px\n  style DecRoundLable fill:#afa,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram describing the interactions between microservices in an E-commerce platform.",
        "planning": "*   **Customer/Client (Web/Mobile App):**\n    *   Entry point; Interacts with multiple services.\n\n*   **API Gateway:**\n    *   Routes requests to appropriate microservices.\n    *   Handles authentication, authorization, rate limiting.\n\n*   **Product Catalog Service:**\n    *   Manages product information (name, description, price).\n    *   Responds to requests for product details.\n\n*   **Inventory Service:**\n    *   Tracks product stock levels.\n    *   Updates inventory upon order placement/cancellation.\n\n*   **Shopping Cart Service:**\n    *   Manages user's shopping cart content.\n    *   Adds, removes, and updates items in the cart.\n\n*   **Order Service:**\n    *   Creates and manages orders.\n    *   Communicates with Payment and Shipping services.\n\n*   **Payment Service:**\n    *   Processes payments (credit card, etc.).\n    *   Communicates with external payment gateways.\n\n*   **Shipping Service:**\n    *   Calculates shipping costs and manages shipment.\n    *   Communicates with shipping providers.\n\n*   **User Service:**\n    *   Manages user accounts, profiles, and authentication.\n\n*   **Recommendation Service:**\n    *   Provides product recommendations.\n    *   Uses data from other services (e.g., purchase history, product views).\n\n*   **Database(s):**\n    *   Each service may have its own database.\n    *   Data is not typically shared directly between databases (data consistency handled through services).\n\n*   **Communication:**\n    *   API Gateway communicates with all microservices via synchronous requests (HTTP).\n    *   Microservices communicate with each other via asynchronous messaging (e.g., Kafka, RabbitMQ) for tasks like inventory updates after order placement.",
        "output": "block-beta\n  columns 5\n  Client space API_Gateway space Product_Catalog space Inventory space Shopping_Cart\n  down1<[\" \"]>(down) space down2<[\" \"]>(down) space down3<[\" \"]>(down) space down4<[\" \"]>(down) space down5<[\" \"]>(down)\n  Order space Payment space Shipping space User space Recommendation\n  \n  API_Gateway --> Product_Catalog\n  API_Gateway --> Inventory\n  API_Gateway --> Shopping_Cart\n  API_Gateway --> Order\n  API_Gateway --> Payment\n  API_Gateway --> Shipping\n  API_Gateway --> User\n  API_Gateway --> Recommendation\n  \n  Order --> Payment\n  Order --> Shipping\n  \n  Recommendation --> Product_Catalog\n  Recommendation --> User\n\n  classDef clientFill fill:#ccf,stroke:#333;\n  classDef serviceFill fill:#ffc,stroke:#333;\n\n  class Client clientFill;\n  class API_Gateway serviceFill;\n  class Product_Catalog,Inventory,Shopping_Cart,Order,Payment,Shipping,User,Recommendation serviceFill;"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram depicting the states of a finite state machine modeling a vending machine.",
        "planning": "*   **States:** At least states for \"Idle,\" \"Selection,\" \"Dispensing,\" and \"Change Returning\".\n*   **Inputs:** Coin insertion (e.g., Nickel, Dime, Quarter), Product Selection (e.g., A, B, C), Cancel.\n*   **Outputs:** Display (e.g., \"Insert Coins,\" Product Price, \"Thank You\"), Product Release, Change Dispense.\n*   **Transitions:** Arrows connecting states, labeled with input conditions that trigger the transition. For example, \"Idle\" to \"Selection\" upon coin insertion, \"Selection\" to \"Dispensing\" upon product selection and sufficient coins, \"Dispensing\" back to \"Idle\" after product release.  \"Selection\" to \"Change Returning\" upon cancel.\n*   **Coin Accumulation:** A mechanism (conceptual - doesn't need to be a separate block) to track the amount of money inserted. The machine transitions from \"Idle\" to \"Selection\" when coins are inserted.\n*   **Error Handling (Optional but Recommended):** Include a state or transition to handle invalid input (e.g., insufficient funds, invalid product selection).",
        "output": "block-beta\n  columns 5\n  Idle[/'Idle' /] space\n  Selection[/'Selection'/] space\n  Dispensing[/'Dispensing'/] space\n  ChangeReturning[/'Change Returning'/]\n  InsufficientFunds[/'Insufficient Funds'/]\n\n  Idle --> Selection: Coin Inserted\n  Selection --> Dispensing: Product Selected + Sufficient Funds\n  Selection --> ChangeReturning: Cancel\n  Selection --> InsufficientFunds: Product Selected + Insufficient Funds\n  Dispensing --> Idle: Product Released\n  ChangeReturning --> Idle: Change Dispensed\n  InsufficientFunds --> Selection: More Coins Inserted\n  InsufficientFunds --> Idle: Cancel\n\n  classDef state fill:#ccf,stroke:#333,stroke-width:2px;\n  class Idle,Selection,Dispensing,ChangeReturning,InsufficientFunds state"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram that outlines the structure of a simplified TCP header used in packet transmission.",
        "planning": "*   **Source Port:** Identifies the sending application's port number.\n*   **Destination Port:** Identifies the receiving application's port number.\n*   **Sequence Number:** Indicates the starting sequence number of data bytes in the segment. Crucial for reassembling data in the correct order.\n*   **Acknowledgment Number:** Indicates the next sequence number the sender expects to receive. Acknowledges previously received data.\n*   **Data Offset (Header Length):** Specifies the size of the TCP header in 32-bit words. Indicates where the data begins.\n*   **Flags (Control Bits):** Contains control flags (e.g., SYN, ACK, FIN, RST, URG, PSH) for connection establishment, termination, and control.\n*   **Window Size:** Specifies the size of the receive window, indicating how much data the sender can transmit without receiving an acknowledgment.\n*   **Checksum:** Error-detection field to ensure data integrity.\n*   **Urgent Pointer:** If the URG flag is set, this field indicates the offset from the current sequence number where urgent data begins.\n*   **Options (Optional):** Optional fields for additional features (e.g., Maximum Segment Size).\n*   **Data (Payload):** The actual application data being transmitted. (While technically not part of the header, its position is vital.)",
        "output": "block-beta\n  columns 2\n  SourcePort[Source Port] space DestinationPort[Destination Port]\n  SequenceNumber[Sequence Number] space AcknowledgmentNumber[Acknowledgment Number]\n  DataOffset[Data Offset] space Flags[Flags]\n  WindowSize[Window Size] space Checksum[Checksum]\n  UrgentPointer[Urgent Pointer] space Options[Options]\n  Data[Data Payload]\n\n  Flags --> WindowSize\n\n  classDef field fill:#ccf,stroke:#333,stroke-width:1px;\n  class SourcePort,DestinationPort,SequenceNumber,AcknowledgmentNumber,DataOffset,Flags,WindowSize,Checksum,UrgentPointer,Options,Data field"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram showing the communication flow in a client-server model for a chat application.",
        "planning": "*   **Client 1:**\n\n    *   User Interface (Chat Window)\n    *   Sends Message to Server\n    *   Receives Messages from Server\n*   **Client 2 (and potentially more clients):**\n\n    *   User Interface (Chat Window)\n    *   Sends Message to Server\n    *   Receives Messages from Server\n*   **Server:**\n\n    *   Receives Messages from Clients\n    *   Distributes Messages to Relevant Clients\n    *   Maintains Client Connections\n    *   (Optional) Handles User Authentication",
        "output": "block-beta\n  columns 3\n\n  Client1 blockArrowId1<[\"Sends Message\"]>(right) Server blockArrowId2<[\"Distributes Message\"]>(right) Client2\n\n  block:Client1\n    UserInterface1[\"User Interface\"] \n    ReceivesMessages1[\"Receives Messages\"]    \n  end\n\n  block:Server\n    ReceivesMessagesServer[\"Receives Messages\"] \n    MaintainsConnections[\"Maintains Connections\"]\n    Authentication[\"User Authentication\"]\n  end\n\n  block:Client2\n    UserInterface2[\"User Interface\"] \n    ReceivesMessages2[\"Receives Messages\"]\n  end\n\n  style Client1 fill:#ccf,stroke:#333,stroke-width:2px\n  style Client2 fill:#ccf,stroke:#333,stroke-width:2px\n  style Server fill:#ffc,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram representing the message flow in a publish-subscribe system.",
        "planning": "*   **Publishers:**\n    *   Publish messages to a specific topic/channel.\n    *   Sends messages to the Message Broker.\n*   **Subscribers:**\n    *   Subscribe to specific topics/channels.\n    *   Receives messages from the Message Broker based on their subscriptions.\n*   **Message Broker (Central Hub):**\n    *   Receives messages from Publishers.\n    *   Filters and routes messages to relevant Subscribers based on subscriptions.\n    *   Maintains topic/channel subscriptions.\n*   **Topics/Channels:**\n    *   Represented as a named entity that messages are published to and subscribed to.\n    *   Link between publishers and subscribers.",
        "output": "block-beta\n  columns 3\n  Publisher space MessageBroker space Subscriber\n  \ndownPublisher<[\"Publishes messages to a topic\"]>(down)  downBroker<[\"Routes messages based on topic subscriptions\"]>(down)  downSubscriber<[\"Receives messages based on topic subscriptions\"]>(down)\n\n  Publisher --> MessageBroker\n  MessageBroker --> Subscriber\n\n  style Publisher fill:#ccf,stroke:#333,stroke-width:2px\n  style Subscriber fill:#ccf,stroke:#333,stroke-width:2px\n  style MessageBroker fill:#fcc,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram illustrating the steps involved in user verification using two-factor authentication.",
        "planning": "*   **User:** Initiates login attempt. Interacts with client/application.\n\n*   **Client/Application:** Presents login interface. Transmits credentials and authentication request. Interacts with user and Authentication Server.\n\n*   **Authentication Server:** Receives login request. Verifies first factor (e.g., password). Initiates second factor challenge. Interacts with database/user store, client/application, and SMS/Authenticator App Server.\n\n*   **Database/User Store:** Stores user credentials (password hash) and authentication information. Interacts with Authentication Server.\n\n*   **SMS/Authenticator App Server:** Sends one-time password (OTP) via SMS or generates code via authenticator app. Interacts with user and Authentication Server.\n\n**Interaction Flow:**\n\n1.  User -> Client: User enters username/password.\n2.  Client -> Authentication Server: Sends username/password to Authentication Server.\n3.  Authentication Server -> Database: Verifies user's first factor (password).\n4.  Authentication Server -> Client: Initiates second factor authentication.\n5.  Authentication Server -> SMS/Authenticator App Server: Requests OTP generation and delivery to user.\n6.  SMS/Authenticator App Server -> User: Sends OTP via SMS or app.\n7.  User -> Client: User enters OTP.\n8.  Client -> Authentication Server: Sends OTP to Authentication Server.\n9.  Authentication Server -> Database: Verifies the OTP.\n10. Authentication Server -> Client: Grants or denies access.",
        "output": "block-beta\n  columns 5\n  User space ClientApp space AuthServer space DB space SMSAppServer\n\n  User[\"User: Login Attempt\"]\n  ClientApp[\"Client/Application: Login Interface\"]\n  AuthServer[\"Authentication Server: Verify Credentials\"]\n  DB[\"Database/User Store\"]\n  SMSAppServer[\"SMS/Authenticator App Server: Generate OTP\"]\n\n  %% Interaction Flow\n  User --> ClientApp: Enters Username/Password\n  ClientApp --> AuthServer: Sends Username/Password\n  AuthServer --> DB: Verifies First Factor\n  AuthServer --> ClientApp: Initiate Second Factor\n  AuthServer --> SMSAppServer: Requests OTP Generation\n  SMSAppServer --> User: Sends OTP\n  User --> ClientApp: Enters OTP\n  ClientApp --> AuthServer: Sends OTP\n  AuthServer --> DB: Verifies OTP\n  AuthServer --> ClientApp: Grants/Denies Access\n\n  \n  style User fill:#ccf,stroke:#333,stroke-width:2px\n  style ClientApp fill:#ccf,stroke:#333,stroke-width:2px\n  style AuthServer fill:#ccf,stroke:#333,stroke-width:2px\n  style DB fill:#ccf,stroke:#333,stroke-width:2px\n  style SMSAppServer fill:#ccf,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram for a simple video processing pipeline in a screencasting application.",
        "planning": "*   **Screen Capture:** Captures the screen content (desktop, window, region). Output: Raw pixel data (e.g., RGB frames).\n*   **Cursor/Annotation Overlay (Optional):** Adds cursor position or annotations to the captured frame. Input: Raw pixel data from Screen Capture, Cursor data/Annotation data. Output: Modified raw pixel data.\n*   **Video Encoding:** Compresses the raw pixel data into a video format (e.g., H.264, VP9). Input: Raw pixel data (from Screen Capture or Cursor/Annotation Overlay). Output: Encoded video stream.\n*   **Audio Input (Optional):** Captures audio from a microphone or system audio. Output: Raw audio data.\n*   **Audio Encoding (Optional):** Compresses the raw audio data into an audio format (e.g., AAC, Opus). Input: Raw audio data from Audio Input. Output: Encoded audio stream.\n*   **Muxing (Optional):** Combines the encoded video and audio streams into a single container format (e.g., MP4, MKV). Input: Encoded video stream, Encoded audio stream. Output: Muxed video file/stream.\n*   **Output:** Delivers the processed video (and audio) to a destination (e.g., file storage, streaming server). Input: Encoded video stream (or Muxed video file/stream). Output: Recorded file or live stream.",
        "output": "block-beta\n  columns 3\n  ScreenCapture[\"Screen Capture\"] space VideoEncoding[\"Video Encoding\"]\n  AudioInput[\"Audio Input\"] space AudioEncoding[\"Audio Encoding\"]\n  \n  CursorOverlay[\"Cursor/Annotation Overlay\"] space Muxing[\"Muxing\"]\n  Output[\"Output\"] \n  \n\n  ScreenCapture --> VideoEncoding\n  ScreenCapture --> CursorOverlay\n  CursorOverlay --> VideoEncoding\n  AudioInput --> AudioEncoding\n  VideoEncoding --> Muxing\n  AudioEncoding --> Muxing\n  Muxing --> Output\n  VideoEncoding --> Output"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram representing the fork-join process in a parallel computing system.",
        "planning": "*   **Main Process (Master Process):**\n    *   Represents the initial, sequential part of the program.\n    *   Initiates the fork operation.\n\n*   **Fork:**\n    *   Represents the splitting of the main process into multiple parallel tasks/processes/threads.\n    *   Sends tasks/data to worker processes.\n\n*   **Worker Processes (Parallel Tasks):**\n    *   Represent the parallel units of computation.\n    *   Receive tasks/data from the master process.\n    *   Perform computations independently.\n\n*   **Join:**\n    *   Represents the synchronization point where worker processes complete their tasks and return results.\n    *   Collects results from worker processes.\n\n*   **Result Aggregation (Optional):**\n    *   Combines the results from the worker processes (if necessary).\n    *   May be part of the main process or a separate stage.\n\n*   **Data Flow:**\n    *   Data flows from the Main Process to Worker Processes during Fork.\n    *   Data (results) flow from Worker Processes to the Join stage (and potentially to Result Aggregation).\n\n*   **Control Flow:**\n    *   The Main Process controls the overall flow, initiating the Fork and Join.\n    *   Synchronization mechanisms (e.g., barriers, semaphores) may be implied within the Join stage.",
        "output": "block-beta\n  columns 3\n  MainProcess[Main Process]\n  space down<[\" \"]>(down)\n  Fork\n  MainProcess --> Fork\n  space down2<[\" \"]>(down)\n  Worker1[Worker Process 1] space Worker2[Worker Process 2] space Worker3[Worker Process 3]\n  Fork --> Worker1\n  Fork --> Worker2\n  Fork --> Worker3\n  space down3<[\" \"]>(down)\n  Join\n  Worker1 --> Join\n  Worker2 --> Join\n  Worker3 --> Join\n  space down4<[\" \"]>(down)\n  ResultAggregation[Result Aggregation]\n  Join --> ResultAggregation"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram showing the error detection and correction workflow in a data transmission system.",
        "planning": "*   **Source Encoder:** Encodes the original data. (Input: Original Data, Output: Encoded Data)\n\n*   **Channel Encoder:** Adds redundancy for error detection/correction. (Input: Encoded Data, Output: Codeword)\n\n*   **Transmitter:** Sends the codeword through the channel. (Input: Codeword, Output: Transmitted Signal)\n\n*   **Channel:** Represents the transmission medium (can introduce errors/noise). (Input: Transmitted Signal, Output: Received Signal)\n\n*   **Receiver:** Receives the signal from the channel. (Input: Received Signal, Output: Received Codeword)\n\n*   **Channel Decoder:** Detects and corrects errors. (Input: Received Codeword, Output: Corrected Data / Error Flag) - Interaction: Uses redundancy to check for and fix errors.\n\n*   **Source Decoder:** Decodes the data back to its original form. (Input: Corrected Data, Output: Original Data (hopefully)) - Interaction: Reverses source encoding.",
        "output": "block-beta\n  columns 1\n  SE[/'Source Encoder' /]\n  arrowDown1<[\" \"]>(down)\n  CE[/'Channel Encoder'/]\n  arrowDown2<[\" \"]>(down)\n  T[/'Transmitter'/]\n  arrowDown3<[\" \"]>(down)\n  CH[/'Channel'/]\n  arrowDown4<[\" \"]>(down)\n  R[/'Receiver'/]\n  arrowDown5<[\" \"]>(down)\n  CD[/'Channel Decoder'/]\n  arrowDown6<[\" \"]>(down)\n  SD[/'Source Decoder'/]\n\n  SE --> CE\n  CE --> T\n  T --> CH\n  CH --> R\n  R --> CD\n  CD --> SD\n\n  style SE fill:#ccf,stroke:#333,stroke-width:2px\n  style CE fill:#ccf,stroke:#333,stroke-width:2px\n  style T fill:#ccf,stroke:#333,stroke-width:2px\n  style CH fill:#ccf,stroke:#333,stroke-width:2px\n  style R fill:#ccf,stroke:#333,stroke-width:2px\n  style CD fill:#ccf,stroke:#333,stroke-width:2px\n  style SD fill:#ccf,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram depicting the interactions between components in an event-driven simulation system.",
        "planning": "*   **Event Queue:** Stores events chronologically, prioritized by timestamp. Provides \"get next event\" and \"add event\" functionality.\n\n*   **Event Generator:** Creates initial events and schedules new events based on simulation logic. Feeds events into the Event Queue.\n\n*   **Simulation Engine:** The core logic. Reads events from the Event Queue, processes them, and updates the simulation state.\n\n*   **Simulation State:** Represents the current state of the system being simulated (e.g., object positions, resource availability). Accessed and modified by the Simulation Engine.\n\n*   **Event Handlers:** Specific functions called by the Simulation Engine to process different event types. Updates the Simulation State based on the event.\n\n*   **Output/Reporting Module:** Collects simulation data from the Simulation State and generates reports/visualizations. Triggered periodically or by specific events.\n\n**Interactions:**\n\n1.  **Event Generator -> Event Queue:** Initial events are placed in the queue.\n2.  **Simulation Engine -> Event Queue:** Requests the next event to process.\n3.  **Event Queue -> Simulation Engine:** Provides the next event.\n4.  **Simulation Engine -> Event Handlers:** Dispatches event to the appropriate handler.\n5.  **Event Handlers -> Simulation State:** Updates the simulation state based on the event.\n6.  **Event Handlers -> Event Queue:** Schedules new events based on the current event.\n7.  **Simulation Engine/Specific Events -> Output/Reporting Module:** Triggers data collection and reporting.\n8.  **Simulation State -> Output/Reporting Module:** Provides data for reports.",
        "output": "block-beta\n  columns 3\n\n  EventGenerator space EventQueue space SimulationEngine\n  down1<[\" \"]>(down) space down2<[\" \"]>(down) space down3<[\" \"]>(down)\n  EventHandlers space SimulationState space OutputReportingModule\n\n  EventGenerator --> EventQueue\n  SimulationEngine --> EventQueue: Request next event\n  EventQueue --> SimulationEngine: Provide next event\n  SimulationEngine --> EventHandlers: Dispatch event\n  EventHandlers --> SimulationState: Update state\n  EventHandlers --> EventQueue: Schedule new events\n  SimulationEngine --> OutputReportingModule: Trigger data collection\n  SimulationState --> OutputReportingModule: Provide data for reports\n\n  classDef component fill:#ccf,stroke:#333,stroke-width:2px\n  class EventQueue,EventGenerator,SimulationEngine,SimulationState,EventHandlers,OutputReportingModule component"
    },
    {
        "diagram_type": "block",
        "prompt": "Give a block diagram illustrating the subsystem interactions in the memory management of an operating system.",
        "planning": "*   **CPU:**\n    *   Sends memory requests (read/write) and addresses to the Memory Management Unit (MMU).\n\n*   **Memory Management Unit (MMU):**\n    *   Translates logical (virtual) addresses from the CPU to physical addresses.\n    *   Interacts with the TLB (Translation Lookaside Buffer) for fast address translation.\n    *   If a TLB miss occurs, interacts with the Page Table.\n\n*   **Translation Lookaside Buffer (TLB):**\n    *   Cache of recent virtual-to-physical address translations.\n    *   Provides fast address lookup.\n    *   Informs MMU of hit or miss.\n\n*   **Page Table:**\n    *   Stores the mapping between virtual pages and physical frames.\n    *   Used by the MMU to translate addresses when a TLB miss occurs.\n    *   Managed by the Operating System.\n\n*   **Operating System (OS):**\n    *   Manages the Page Table (creation, updates).\n    *   Handles page faults (when a requested page is not in physical memory).\n    *   Communicates with Secondary Storage (Disk) for swapping pages in/out.\n    *   Provides memory allocation/deallocation services.\n\n*   **Physical Memory (RAM):**\n    *   Stores data and instructions currently in use.\n    *   Accessed using physical addresses.\n\n*   **Secondary Storage (Disk):**\n    *   Stores virtual memory pages not currently in RAM.\n    *   Used for swapping pages when physical memory is full.\n    *   Interacts with the OS during page faults.",
        "output": "block-beta\n  columns 3\n\n  CPU[\"CPU\"] space MMU[\"MMU\"] space OS[\"Operating System\"]\n  down1<[\"Memory Request Address\"]>(down) space down2<[\"Translate Logical to Physical Address\"]>(down) space  down3<[\"Manage Page Table Page Fault\"]>(down)\n\n  MMU --\"TLB Hit/Miss\"--> TLB[\"TLB\"] \n  MMU --\"Page Table Request\"--> PageTable[\"Page Table\"]\n  OS  --\"Page Fault Swap Pages\"--> Disk[\"Secondary Storage Disk\"]\n  OS --\"Memory Allocation Deallocation\"--> RAM[\"Physical Memory RAM\"]\n  \n  style CPU fill:#636,stroke:#333,stroke-width:2px\n  style MMU fill:#969,stroke:#333,stroke-width:2px\n  style OS fill:#bbf,stroke:#f66,stroke-width:2px\n  style TLB fill:#ccf,stroke:#f66,stroke-width:2px\n  style PageTable fill:#ccf,stroke:#f66,stroke-width:2px\n  style Disk fill:#ccf,stroke:#f66,stroke-width:2px\n  style RAM fill:#ccf,stroke:#f66,stroke-width:2px"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a simple e-commerce platform at system level, showing the interaction between the website, payment gateway, and user system.",
        "planning": "*   **Containers:**\n    *   **Web Application:**  Handles user interface and logic.\n    *   **Payment Gateway:**  External system for processing payments.\n    *   **User System:**  Manages user accounts and authentication.\n\n*   **Interactions:**\n    *   User interacts with Web Application (via web browser).\n    *   Web Application communicates with User System (for login/registration, user data).\n    *   Web Application communicates with Payment Gateway (for payment processing).\n    *   Payment Gateway may communicate back to Web Application (with transaction status).",
        "output": "C4Context\n  Person(user, User, \"Customer using the e-commerce platform\")\n\n  System(web_app, \"Web Application\", \"Handles user interface and logic\")\n  System_Ext(payment_gateway, \"Payment Gateway\", \"External system for processing payments\")\n  System(user_system, \"User System\", \"Manages user accounts and authentication\")\n\n  Rel(user, web_app, \"Uses\", \"HTTPS\")\n  Rel(web_app, user_system, \"Authenticates with\", \"HTTPS\")\n  Rel(web_app, payment_gateway, \"Processes payments via\", \"HTTPS\")\n  Rel_Back(payment_gateway, web_app, \"Sends transaction status to\", \"HTTPS\")\n\n  UpdateRelStyle(user, web_app, $offsetY=\"-20\")\n  UpdateRelStyle(web_app, user_system, $offsetX=\"-40\", $offsetY=\"20\")\n  UpdateRelStyle(web_app, payment_gateway, $offsetY=\"-40\")\n  UpdateRelStyle(payment_gateway, web_app, $offsetX=\"40\", $offsetY=\"20\")\n\n  UpdateLayoutConfig($c4ShapeInRow=\"3\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a chat application with components such as server, client, and database, detailing the interactions among them.",
        "planning": "**Components:**\n\n*   **Client Application (User's device):** Interacts with the user, sends/receives messages.\n*   **Server Application:** Manages connections, message routing, authentication, and business logic.\n*   **Database:** Stores user data, messages, and conversation history.\n\n**Interactions:**\n\n*   **Client -> Server:** User sends message; authenticates; joins/leaves chat rooms; requests data.\n*   **Server -> Client:** Sends message to recipient(s); notifies of new messages; updates user interface; requests user authentication.\n*   **Server <-> Database:** Stores/retrieves user data (profiles, credentials); stores/retrieves messages and conversation history.",
        "output": "C4Component\n\nContainer(client, \"Client Application\", \"User Device\", \"Sends/Receives messages\")\nContainer(server, \"Server Application\", \"\", \"Manages connections, message routing, authentication\")\nContainerDb(database, \"Database\", \"\", \"Stores user data, messages, conversation history\")\n\nRel(client, server, \"Sends message; Authenticates; Joins/Leaves\")\nRel(server, client, \"Sends message; Notifies of new messages\")\nRel_Back(database, server, \"Stores/Retrieves user data and messages\")\n\nUpdateRelStyle(client, server, $offsetY=\"-20\")\nUpdateRelStyle(server, client, $offsetY=\"20\")\nUpdateRelStyle(database, server, $offsetX=\"-30\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a microservices-based online banking system focusing on the interactions between authentication, account management, and transaction services.",
        "planning": "*   **Context (Level 1):**\n    *   User: Interacts with the Online Banking System.\n    *   Online Banking System: Contains the Authentication, Account Management, and Transaction services.\n\n*   **Container (Level 2):**\n    *   Web Application (UI): User interface for accessing banking services.\n    *   Authentication Service: Handles user login and authorization.\n    *   Account Management Service: Manages user account information (balance, details, etc.).\n    *   Transaction Service: Processes transactions (deposits, withdrawals, transfers).\n    *   Database (shared or separate for each service): Persists user data, account data, and transaction history.\n\n*   **Components (Level 3):**\n    *   **Authentication Service:**\n        *   Login Component: Verifies user credentials.\n        *   Token Generation Component: Creates authentication tokens.\n        *   Token Validation Component: Validates authentication tokens.\n    *   **Account Management Service:**\n        *   Account Information Component: Retrieves account details.\n        *   Balance Update Component: Updates account balances.\n        *   Account Creation Component: Handles new account creation.\n    *   **Transaction Service:**\n        *   Transaction Processing Component: Executes transactions.\n        *   Transaction Logging Component: Records transaction history.\n        *   Balance Check Component: Ensures sufficient funds.\n\n*   **Interactions:**\n    *   User -> Web Application\n    *   Web Application -> Authentication Service (for login/authentication).\n    *   Web Application -> Account Management Service (for account details).\n    *   Web Application -> Transaction Service (for initiating transactions).\n    *   Authentication Service -> Database (for user authentication data).\n    *   Account Management Service -> Database (for account data).\n    *   Transaction Service -> Account Management Service (to update balances).\n    *   Transaction Service -> Database (for transaction history).",
        "output": "C4Container\n  Person(user, User, \"Interacts with the Online Banking System\")\n\n  Container_Boundary(onlineBankingSystem, \"Online Banking System\") {\n    Container(webApp, \"Web Application\", \"\", \"User interface for accessing banking services\")\n    Container(authService, \"Authentication Service\", \"\", \"Handles user login and authorization\")\n    Container(accountMgmtService, \"Account Management Service\", \"\", \"Manages user account information\")\n    Container(transactionService, \"Transaction Service\", \"\", \"Processes transactions\")\n    ContainerDb(database, \"Database\", \"\", \"Persists user data account data transaction history\")\n  }\n\n  Rel(user, webApp, \"Uses\")\n  Rel(webApp, authService, \"Authenticates\")\n  Rel(webApp, accountMgmtService, \"Manages Accounts\")\n  Rel(webApp, transactionService, \"Initiates Transactions\")\n  Rel(authService, database, \"Authenticates User\")\n  Rel(accountMgmtService, database, \"Manages Account Data\")\n  Rel(transactionService, accountMgmtService, \"Updates Balances\")\n  Rel(transactionService, database, \"Logs Transactions\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram illustrating a content management system architecture showing interactions between an admin portal, a content delivery module, and a database.",
        "planning": "**C4 Diagram Plan: Content Management System**\n\n**Level 1: System Context Diagram**\n\n*   **System:** Content Management System (CMS) - Central box.\n*   **Users:**\n    *   Content Administrators - Interact with Admin Portal.\n    *   Website Visitors - Consume content delivered by the Content Delivery Module.\n*   **External Systems (optional):**\n    *   Analytics Platform - Receives data from the Content Delivery Module.\n\n**Level 2: Container Diagram**\n\n*   **Containers:**\n    *   Admin Portal (Web Application): Allows content creation, editing, and management.\n    *   Content Delivery Module (Web Application/API): Serves content to website visitors.\n    *   Database (e.g., MySQL, PostgreSQL): Stores content, metadata, and configurations.\n\n**Level 3: Component Diagram (Focus on key components within each container)**\n\n*   **Admin Portal Components:**\n    *   Authentication Module: Handles user login and authorization.\n    *   Content Editor: Provides an interface for creating and editing content.\n    *   Content Workflow Management: Manages content approval processes.\n*   **Content Delivery Module Components:**\n    *   Content Retrieval: Fetches content from the database.\n    *   Caching Layer: Improves performance by caching frequently accessed content.\n    *   Templating Engine: Renders content into web pages or API responses.\n*   **Database Components:**\n    *   Content Tables: Store the actual content (text, images, etc.).\n    *   Metadata Tables: Store information about the content (author, creation date, etc.).\n\n**Interactions (Arrows between components/containers):**\n\n*   Admin Portal -> Database: Reads and writes content/metadata.\n*   Admin Portal -> Content Delivery Module: Triggers content updates/cache invalidation.\n*   Content Delivery Module -> Database: Reads content for delivery.\n*   Content Delivery Module -> Users: Delivers content via website pages or API responses.\n*   Content Delivery Module -> Analytics Platform (Optional): Sends data about content usage.\n*   Authentication Module -> Database: Checks user credentials.",
        "output": "```mermaid\nC4Context\n  title Content Management System - System Context\n\n  Person(content_admin, \"Content Admin\", \"Manages content via Admin Portal\")\n  Person(website_visitor, \"Website Visitor\", \"Consumes content delivered by the CMS\")\n\n  System(cms, \"Content Management System\", \"Manages creation, storage, and delivery of content\")\n  System_Ext(analytics, \"Analytics Platform\", \"Tracks content usage statistics\")\n\n  Rel(content_admin, cms, \"Manages Content\")\n  Rel(cms, website_visitor, \"Delivers Content to\")\n  Rel(cms, analytics, \"Sends Usage Data to\")\n\nC4Container\n  title Content Management System - Container Diagram\n\n  Container(admin_portal, \"Admin Portal\", \"Web Application\", \"Allows content creation and management\")\n  Container(delivery_module, \"Content Delivery Module\", \"Web Application/API\", \"Serves content to website visitors\")\n  ContainerDb(database, \"Database\", \"MySQL/PostgreSQL\", \"Stores content and metadata\")\n\n  Rel(admin_portal, database, \"Reads/Writes\", \"JDBC/ORM\")\n  Rel(admin_portal, delivery_module, \"Triggers Updates\")\n  Rel(delivery_module, database, \"Reads Content\", \"JDBC/ORM\")\n\nC4Component\n  title Content Management System - Component Diagram - Admin Portal\n\n  Container(admin_portal_container, \"Admin Portal\", \" \", \" \")\n  Component(auth_module, \"Authentication Module\", \" \", \"Handles user login\")\n  Component(content_editor, \"Content Editor\", \" \", \"Provides interface for content creation\")\n  Component(workflow_management, \"Workflow Management\", \" \", \"Manages content approval\")\n\n  Rel(admin_portal_container, auth_module, \"Uses\")\n  Rel(admin_portal_container, content_editor, \"Uses\")\n  Rel(admin_portal_container, workflow_management, \"Uses\")\n\nC4Component\n  title Content Management System - Component Diagram - Delivery Module\n\n  Container(delivery_module_container, \"Delivery Module\", \" \", \" \")\n  Component(content_retrieval, \"Content Retrieval\", \" \", \"Fetches content from DB\")\n  Component(caching_layer, \"Caching Layer\", \" \", \"Caches frequently accessed content\")\n  Component(templating_engine, \"Templating Engine\", \" \", \"Renders content for delivery\")\n\n  Rel(delivery_module_container, content_retrieval, \"Uses\")\n  Rel(delivery_module_container, caching_layer, \"Uses\")\n  Rel(delivery_module_container, templating_engine, \"Uses\")\n\nC4Component\n  title Content Management System - Component Diagram - Database\n\n  ContainerDb(database_container, \"Database\", \" \", \" \")\n  ComponentDb(content_tables, \"Content Tables\", \" \", \"Stores actual content\")\n  ComponentDb(metadata_tables, \"Metadata Tables\", \" \", \"Stores content metadata\")\n\n  Rel(database_container, content_tables, \"Uses\")\n  Rel(database_container, metadata_tables, \"Uses\")\n```"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a social media platform highlighting components like post management, user profiles, and messaging.",
        "planning": "**C4 Diagram Plan: Social Media Platform**\n\n*   **Context Diagram (Level 1):**\n    *   System: Social Media Platform\n    *   Users: Interacting with the system.\n    *   External Systems: Internet, Push Notification Service.\n\n*   **Container Diagram (Level 2):**\n    *   Web Application: (Frontend, written in Javascript/React) Serves the UI, interacts with API.\n    *   API Application: (Backend, written in Python/Java) Exposes REST API.\n    *   Database: (e.g., PostgreSQL, MySQL) Stores user data, posts, messages, etc.\n    *   Message Queue: (e.g., RabbitMQ, Kafka) Handles asynchronous tasks like sending notifications.\n\n*   **Component Diagram (Level 3 - Focused on Key Areas):**\n\n    *   **Post Management Component:**\n        *   Components: Post Creation, Post Storage, Feed Generation.\n        *   Interactions: Post Creation stores new posts in Post Storage; Feed Generation retrieves posts from Post Storage for display.\n        *   API: Uses the API Application to interact with other componenets.\n        *   Uses the Database.\n    *   **User Profile Component:**\n        *   Components: Profile Data, Authentication, Friend Management.\n        *   Interactions: Profile Data stores user information, Authentication handles login/registration, Friend Management manages relationships.\n        *   API: Uses the API Application to interact with other componenets.\n        *   Uses the Database.\n    *   **Messaging Component:**\n        *   Components: Message Sending, Message Storage, Real-time Updates.\n        *   Interactions: Message Sending stores messages in Message Storage; Real-time Updates delivers messages to users using web sockets.\n        *   API: Uses the API Application to interact with other componenets.\n        *   Uses the Database.\n        *   Interactions with Message Queue for async tasks, such as delayed deliveries.\n    *   **Search Component:**\n        *   Component: Search Index, Search Query Processor\n        *   Interactions: Search Query Processor queries the Search Index based on user input; the Search Index finds results from data stored from Post Management, User Profile and Messaging components.\n        *   API: Uses the API Application to interact with other componenets.\n\n*   **Technology Choices:**\n    *   Mention specific technologies used for each container/component (e.g., React for frontend, Python/Django for API, PostgreSQL for database, RabbitMQ for message queue).",
        "output": "C4Context\n  Enterprise_Boundary(social_media_boundary, \"Social Media Platform\") {\n    Person(user, \"User\", \"Interacts with the platform\")\n    System(social_media_platform, \"Social Media Platform\", \"Allows users to connect and share content\")\n  }\n  System_Ext(internet, \"Internet\", \"Provides connectivity\")\n  System_Ext(push_notifications, \"Push Notification Service\", \"Delivers notifications\")\n\n  BiRel(user, social_media_platform, \"Uses\")\n  Rel(social_media_platform, internet, \"Connects via\")\n  Rel(social_media_platform, push_notifications, \"Sends notifications via\")\n\n  C4Container\n  Container_Boundary(social_media_container, \"Social Media Platform Containers\") {\n    Container(web_app, \"Web Application\", \"JavaScript/React\", \"Serves the UI and interacts with the API\")\n    Container(api_app, \"API Application\", \"Python/Java\", \"Exposes REST API\")\n    ContainerDb(database, \"Database\", \"PostgreSQL/MySQL\", \"Stores user data posts and messages\")\n    ContainerQueue(message_queue, \"Message Queue\", \"RabbitMQ/Kafka\", \"Handles asynchronous tasks\")\n  }\n\n  Rel(web_app, api_app, \"Uses\", \"HTTPS\")\n  Rel(api_app, database, \"Reads/Writes\", \"JDBC/ORM\")\n  Rel(api_app, message_queue, \"Uses\", \"AMQP/Kafka Protocol\")\n\n  C4Component\n  Container_Boundary(api_boundary, \"API Application Components\") {\n\t\tSubcomponent(post_management, \"Post Management Component\", \"Handles the management of posts\") {\n      Component(post_creation, \"Post Creation\", \"Allows creating new posts\")\n      Component(post_storage, \"Post Storage\", \"Stores posts\")\n      Component(feed_generation, \"Feed Generation\", \"Generates user feeds\")\n\n      Rel(post_creation, post_storage, \"Stores\", \"\")\n      Rel(feed_generation, post_storage, \"Retrieves\", \"\")\n\t\t}\n\n\t\tSubcomponent(user_profile, \"User Profile Component\", \"Handles user profiles and authentication\"){\n      Component(profile_data, \"Profile Data\", \"Stores user information\")\n      Component(authentication, \"Authentication\", \"Handles login/registration\")\n      Component(friend_management, \"Friend Management\", \"Manages user relationships\")\n\n      Rel(profile_data, authentication, \"Uses\", \"\")\n      Rel(profile_data, friend_management, \"Uses\", \"\")\n\t\t}\n\n\t\tSubcomponent(messaging, \"Messaging Component\", \"Handles messaging functionality\"){\n      Component(message_sending, \"Message Sending\", \"Sends messages\")\n      Component(message_storage, \"Message Storage\", \"Stores messages\")\n      Component(realtime_updates, \"Real-time Updates\", \"Delivers messages in real-time\")\n\n      Rel(message_sending, message_storage, \"Stores\", \"\")\n      Rel(realtime_updates, message_storage, \"Retrieves\", \"\")\n\t\t}\n\n\t\tSubcomponent(search, \"Search Component\", \"Handles search functionality\"){\n      Component(search_index, \"Search Index\", \"Index data for searching\")\n      Component(search_query_processor, \"Search Query Processor\", \"Processes search queries\")\n\n      Rel(search_query_processor, search_index, \"Queries\", \"\")\n\t\t}\n  }\n  \n  Rel(post_management, api_app, \"Uses\", \"\")\n  Rel(user_profile, api_app, \"Uses\", \"\")\n  Rel(messaging, api_app, \"Uses\", \"\")\n  Rel(search, api_app, \"Uses\", \"\")\n\n  Rel(post_management, database, \"Uses\", \"\")\n  Rel(user_profile, database, \"Uses\", \"\")\n  Rel(messaging, database, \"Uses\", \"\")\n\n  Rel(messaging, message_queue, \"Uses\", \"\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a task management application depicting containers such as a web application, mobile application, API service, and data store.",
        "planning": "*   **Web Application Container:**\n    *   Purpose: User interface for managing tasks via a web browser.\n    *   Interaction: Interacts with the API Service to fetch and update task data.\n\n*   **Mobile Application Container:**\n    *   Purpose: User interface for managing tasks on mobile devices.\n    *   Interaction: Interacts with the API Service to fetch and update task data.\n\n*   **API Service Container:**\n    *   Purpose: Provides an API for web and mobile applications to access and manipulate task data.\n    *   Interaction:\n        *   Receives requests from the Web and Mobile Applications.\n        *   Reads/writes data to the Data Store.\n\n*   **Data Store Container:**\n    *   Purpose: Persists task data (e.g., tasks, users, projects).\n    *   Interaction: Receives read/write requests from the API Service.",
        "output": "C4Container\n\nPerson(user, User, \"A user of the task management application\")\n\nContainer_Boundary(task_management, \"Task Management Application\") {\n    Container(web_app, \"Web Application\", \"JavaScript, React\", \"User interface for managing tasks via a web browser\")\n    Container(mobile_app, \"Mobile Application\", \"Swift, Kotlin\", \"User interface for managing tasks on mobile devices\")\n    Container(api_service, \"API Service\", \"Java, Spring Boot\", \"Provides an API for web and mobile applications\")\n    ContainerDb(data_store, \"Data Store\", \"PostgreSQL\", \"Persists task data\")\n}\n\nRel(user, web_app, \"Uses\", \"HTTPS\")\nRel(user, mobile_app, \"Uses\")\n\nRel(web_app, api_service, \"Uses\", \"JSON/HTTPS\")\nRel(mobile_app, api_service, \"Uses\", \"JSON/HTTPS\")\n\nRel_Back(data_store, api_service, \"Reads/Writes\", \"JDBC\")\n\nUpdateRelStyle(web_app, api_service, $offsetY=\"-40\", $offsetX=\"50\")\nUpdateRelStyle(mobile_app, api_service, $offsetY=\"40\", $offsetX=\"-50\")\nUpdateRelStyle(user, web_app, $offsetY=\"30\")\nUpdateRelStyle(user, mobile_app, $offsetY=\"-30\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for an online learning platform showing interactions between course management services, user profiles, and a payment processing module.",
        "planning": "**Level 1: System Context Diagram**\n\n*   **System:** Online Learning Platform\n*   **Users:** Students, Instructors, Administrators\n*   **External Systems:** Payment Gateway\n\n**Level 2: Container Diagram**\n\n*   **Web Application:** User interface for students, instructors, and admins.\n*   **API Application:** Backend services for the Web Application.\n*   **Database:** Stores user profiles, course data, and payment information.\n*   **Payment Processing Module:** Handles payment transactions.\n\n**Level 3: Component Diagram (Focusing on Interactions)**\n\n*   **Course Management Service:**\n    *   Components: Course Creation, Enrollment, Content Delivery\n    *   Interactions: Reads/Writes course data to the Database, interacts with User Profile Service for enrollment.\n*   **User Profile Service:**\n    *   Components: Authentication, Profile Management\n    *   Interactions: Reads/Writes user data to the Database, interacts with Course Management Service for enrollment, interacts with Payment Processing Module for subscription status.\n*   **Payment Processing Module:**\n    *   Components: Payment Capture, Subscription Management, Refund Processing.\n    *   Interactions: Communicates with Payment Gateway, Updates user subscription status in User Profile Service, Writes transaction details to the Database.\n\n**Key Interactions:**\n\n*   Users interact with the Web Application.\n*   Web Application communicates with API Application.\n*   API Application uses Course Management Service, User Profile Service, and Payment Processing Module.\n*   Services interact with the Database for persistent storage.\n*   Payment Processing Module communicates with an external Payment Gateway.",
        "output": "```mermaid\nC4Context\n  Enterprise_Boundary(b0, \"Online Learning Platform\") {\n    Person(student, \"Student\", \"Learns courses\")\n    Person(instructor, \"Instructor\", \"Creates and manages courses\")\n    Person(admin, \"Administrator\", \"Manages the platform\")\n\n    System(platform, \"Online Learning Platform\", \"Provides courses to students\")\n\n    System_Ext(payment_gateway, \"Payment Gateway\", \"Processes payments\")\n  }\n\n  Rel(student, platform, \"Uses\")\n  Rel(instructor, platform, \"Uses\")\n  Rel(admin, platform, \"Uses\")\n  Rel(platform, payment_gateway, \"Uses\", \"Payment\")\n\nC4Container\n  Container(web_app, \"Web Application\", \"User Interface\")\n  Container(api_app, \"API Application\", \"Backend Services\")\n  ContainerDb(database, \"Database\", \"Data Storage\")\n  Container(payment_module, \"Payment Processing Module\", \"Handles Payments\")\n\n  Rel(web_app, api_app, \"Uses\")\n  Rel(api_app, database, \"Uses\")\n  Rel(api_app, payment_module, \"Uses\")\n\nC4Component\n  Container(web_app_container, \"Web Application\") {\n    Component(web_ui, \"Web UI\", \"User Interface\")\n  }\n  Container(api_app_container, \"API Application\") {\n    Component(course_service, \"Course Management Service\", \"Manages courses\")\n    Component(user_service, \"User Profile Service\", \"Manages user profiles\")\n    Component(payment_service, \"Payment Processing Module\", \"Handles payments\")\n  }\n  ContainerDb(database_container, \"Database\") {\n    ComponentDb(course_data, \"Course Data\", \"Stores course information\")\n    ComponentDb(user_data, \"User Data\", \"Stores user profiles\")\n    ComponentDb(payment_data, \"Payment Data\", \"Stores payment details\")\n  }\n\n  Rel(web_app_container, api_app_container, \"Uses\")\n\n  Rel(course_service, course_data, \"Reads/Writes\")\n  Rel(user_service, user_data, \"Reads/Writes\")\n  Rel(payment_service, payment_data, \"Writes\")\n\n  Rel(course_service, user_service, \"Uses\", \"Enrollment\")\n  Rel(user_service, payment_service, \"Uses\", \"Subscription Status\")\n  Rel(payment_service, payment_gateway, \"Communicates\")\n\n  UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n```"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for an IoT sensor network system, illustrating components for sensor devices, data aggregation services, and an analytics platform.",
        "planning": "**C4 Diagram Plan: IoT Sensor Network**\n\n**Context Diagram (Level 1):**\n\n*   **System:** IoT Sensor Network System.\n*   **Users:**\n    *   Data Scientists (analyzing data).\n    *   Operations Team (monitoring system health).\n*   **External Systems:**\n    *   Cloud Platform (where the analytics platform resides).\n    *   End-User Applications (visualizing insights).\n\n**Container Diagram (Level 2):**\n\n*   **Containers:**\n    *   Sensor Devices (IoT devices collecting data).\n    *   Data Aggregation Service (receives and processes sensor data).\n    *   Analytics Platform (performs data analysis and generates insights).\n    *   Database (stores aggregated and analyzed data).\n*   **Relationships:**\n    *   Sensor Devices send data to Data Aggregation Service.\n    *   Data Aggregation Service sends data to Analytics Platform and Database.\n    *   Analytics Platform reads data from Database and exposes APIs.\n    *   Cloud Platform hosts the Analytics Platform and Database.\n    *   End-User Applications consumes data from Analytics platform.\n\n**Component Diagram (Level 3 - Focus on Analytics Platform):**\n\n*   **Components within Analytics Platform:**\n    *   Data Ingestion Component (receives data from Aggregation Service).\n    *   Data Processing Component (transforms and cleans data).\n    *   Analytics Engine Component (performs calculations and generates insights).\n    *   API Gateway Component (provides access to insights).\n*   **Relationships:**\n    *   Data Ingestion passes data to Data Processing.\n    *   Data Processing sends data to Analytics Engine.\n    *   Analytics Engine stores results in Database.\n    *   API Gateway exposes endpoints for End-User Applications.\n\n**Code Diagram (Level 4 - Optional, Focus on specific component in Analytics Platform):**\n\n*   Detailed design of a specific component (e.g., Data Processing).\n*   Classes, interfaces, and their relationships within that component.\n*   Specific technologies used (e.g., specific libraries).",
        "output": "```mermaid\nC4Context\n  title IoT Sensor Network System Context Diagram\n\n  Person(data_scientist, \"Data Scientist\", \"Analyzes sensor data for insights\")\n  Person(operations_team, \"Operations Team\", \"Monitors system health and performance\")\n\n  System(iot_system, \"IoT Sensor Network System\", \"Collects, aggregates, analyzes, and visualizes sensor data\")\n\n  System_Ext(cloud_platform, \"Cloud Platform\", \"Hosts analytics platform and database\")\n  System_Ext(end_user_app, \"End-User Applications\", \"Visualizes sensor data insights\")\n\n  Rel(data_scientist, iot_system, \"Uses\", \"To analyze data\")\n  Rel(operations_team, iot_system, \"Monitors\", \"System health\")\n  Rel(iot_system, cloud_platform, \"Resides on\")\n  Rel(iot_system, end_user_app, \"Provides data to\")\n\nC4Container\n  title IoT Sensor Network Container Diagram\n\n  Container(sensor_devices, \"Sensor Devices\", \"Various\", \"Collects and transmits sensor data\")\n  Container(data_aggregator, \"Data Aggregation Service\", \"Python\", \"Receives and processes sensor data\")\n  Container(analytics_platform, \"Analytics Platform\", \"Java\", \"Performs data analysis and generates insights\")\n  ContainerDb(database, \"Database\", \"PostgreSQL\", \"Stores aggregated and analyzed data\")\n\n  Rel(sensor_devices, data_aggregator, \"Sends data to\", \"MQTT\")\n  Rel(data_aggregator, analytics_platform, \"Sends data to\", \"gRPC\")\n  Rel(data_aggregator, database, \"Stores data in\")\n  Rel(analytics_platform, database, \"Reads data from\")\n  Rel(cloud_platform, analytics_platform, \"Hosts\")\n  Rel(cloud_platform, database, \"Hosts\")\n  Rel(end_user_app, analytics_platform, \"Consumes data from\", \"API\")\n\nC4Component\n  title Analytics Platform Component Diagram\n\n  Container(analytics_platform_container, \"Analytics Platform\", \"Java\", \"Container for analytics components\") {\n    Component(data_ingestion, \"Data Ingestion Component\", \"Kafka Consumer\", \"Receives data from Aggregation Service\")\n    Component(data_processing, \"Data Processing Component\", \"Spark\", \"Transforms and cleans data\")\n    Component(analytics_engine, \"Analytics Engine Component\", \"TensorFlow\", \"Performs calculations and generates insights\")\n    Component(api_gateway, \"API Gateway Component\", \"Spring Boot\", \"Provides access to insights\")\n  }\n  ContainerDb(database_component, \"Database\", \"PostgreSQL\", \"Stores the output\")\n\n  Rel(data_ingestion, data_processing, \"Passes data to\")\n  Rel(data_processing, analytics_engine, \"Sends data to\")\n  Rel(analytics_engine, database_component, \"Stores results in\")\n  Rel(api_gateway, end_user_app, \"Exposes endpoints to\")\n  Rel(data_processing, database_component, \"Writes cleaned data to\")\n\n  UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n```"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a RAG-based document retrieval system that includes data ingestion, query processing, and document retrieval services.",
        "planning": "*   **Level 1: System Context**\n    *   **System:** RAG-based Document Retrieval System\n    *   **User:** Interacts with the system to retrieve information.\n    *   **External System 1:** Document Source (e.g., Cloud Storage, File System) - Provides documents for ingestion.\n\n*   **Level 2: Container Diagram**\n    *   **Application:** API Gateway - Handles user requests and routes them to appropriate services.\n    *   **Application:** Query Processing Service - Processes user queries (e.g., cleaning, reformatting).\n    *   **Application:** Document Ingestion Service - Ingests documents from the Document Source, chunks them, and creates embeddings.\n    *   **Database:** Vector Database - Stores document embeddings for efficient similarity search.\n    *   **Database:** Document Metadata Store - Stores document metadata and chunk mappings.\n\n*   **Level 3: Component Diagram (Focus on Key Services)**\n    *   **Query Processing Service:**\n        *   **Component:** Query Parser - Parses the user query.\n        *   **Component:** Query Reformulator (Optional) - Refines the query for better retrieval.\n        *   **Interaction:** Sends processed query to Document Retrieval Service.\n    *   **Document Ingestion Service:**\n        *   **Component:** Document Loader - Loads documents from the Document Source.\n        *   **Component:** Document Splitter - Splits documents into chunks.\n        *   **Component:** Embedding Generator - Generates embeddings for document chunks using a pre-trained model.\n        *   **Interaction:** Stores embeddings in Vector Database.\n        *   **Interaction:** Stores document metadata and chunk mappings in Document Metadata Store.\n    *   **Document Retrieval Service:**\n        *   **Component:** Vector Search - Searches the Vector Database for relevant document embeddings based on the query embedding.\n        *   **Component:** Context Extractor - Retrieves the corresponding document chunks from the Document Metadata Store.\n        *   **Component:** Response Generator (Optional) - Formats the retrieved information for the user.\n        *   **Interaction:** Queries Vector Database.\n        *   **Interaction:** Retrieves document chunks from Document Metadata Store.\n        *   **Interaction:** Sends retrieved information to API Gateway.",
        "output": "```mermaid\nC4Context\n  title RAG-based Document Retrieval System - System Context\n\n  Person(user, User, \"Retrieves information from the system\")\n\n  System(rag_system, \"RAG-based Document Retrieval System\", \"Provides document retrieval based on RAG\")\n\n  System_Ext(doc_source, \"Document Source\", \"Provides documents for ingestion\")\n\n  Rel(user, rag_system, \"Uses\")\n  Rel(rag_system, doc_source, \"Ingests documents from\")\n\nC4Container\n  title RAG-based Document Retrieval System - Container Diagram\n\n  Container(api_gateway, \"API Gateway\", \"Handles user requests and routes them\")\n  Container(query_service, \"Query Processing Service\", \"Processes user queries\")\n  Container(ingestion_service, \"Document Ingestion Service\", \"Ingests documents and creates embeddings\")\n  ContainerDb(vector_db, \"Vector Database\", \"Stores document embeddings\")\n  ContainerDb(metadata_store, \"Document Metadata Store\", \"Stores document metadata and chunk mappings\")\n\n  Rel(api_gateway, query_service, \"Routes queries to\")\n  Rel(api_gateway, ingestion_service, \"Triggers document ingestion\")\n  Rel(query_service, vector_db, \"Queries for similar embeddings\")\n  Rel(query_service, metadata_store, \"Retrieves document chunks\")\n  Rel(ingestion_service, vector_db, \"Stores embeddings in\")\n  Rel(ingestion_service, metadata_store, \"Stores metadata in\")\n\nC4Component\n  title Query Processing Service - Component Diagram\n\n  Container(qs, \"Query Processing Service\"){\n    Component(query_parser, \"Query Parser\", \"Parses the user query\")\n    Component(query_reformulator, \"Query Reformulator\", \"Refines the query for better retrieval\")\n  }\n\n  Rel(query_parser, query_reformulator, \"Uses\")\n  Rel(qs, vector_db, \"Sends processed query to Document Retrieval Service\")\n\n\nC4Component\n  title Document Ingestion Service - Component Diagram\n\n  Container(dis, \"Document Ingestion Service\"){\n    Component(doc_loader, \"Document Loader\", \"Loads documents from the Document Source\")\n    Component(doc_splitter, \"Document Splitter\", \"Splits documents into chunks\")\n    Component(embedding_gen, \"Embedding Generator\", \"Generates embeddings for document chunks\")\n  }\n\n  Rel(doc_loader, doc_splitter, \"Loads documents to\")\n  Rel(doc_splitter, embedding_gen, \"Splits document to\")\n  Rel(embedding_gen, vector_db, \"Stores embeddings in Vector Database\")\n  Rel(embedding_gen, metadata_store, \"Stores metadata in Metadata Store\")\n\nC4Component\n  title Document Retrieval Service - Component Diagram\n\n  Container(drs, \"Document Retrieval Service\"){\n    Component(vector_search, \"Vector Search\", \"Searches the Vector Database for relevant embeddings\")\n    Component(context_extractor, \"Context Extractor\", \"Retrieves corresponding document chunks\")\n    Component(response_gen, \"Response Generator\", \"Formats retrieved information\")\n  }\n\n  Rel(vector_search, vector_db, \"Queries Vector Database\")\n  Rel(context_extractor, metadata_store, \"Retrieves document chunks from Metadata Store\")\n  Rel(response_gen, api_gateway, \"Sends retrieved information to API Gateway\")\n\n  Rel(vector_search, context_extractor, \"Uses\")\n  Rel(context_extractor, response_gen, \"Uses\")\n\nUpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n```"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for an inventory management system showing interactions between retail outlets, warehouses, and supply chain management services.",
        "planning": "**C4 Diagram Plan: Inventory Management System**\n\n*   **Level 1: System Context Diagram**\n    *   **System:** Inventory Management System (IMS) - Central box.\n    *   **Users/External Systems:**\n        *   Retail Outlets: Places orders, receives inventory, sells products.\n        *   Warehouses: Stores inventory, fulfills orders.\n        *   Supply Chain Management Services: Provides inventory data, initiates restock.\n\n*   **Level 2: Container Diagram**\n    *   **Containers:**\n        *   Web Application: UI for Retail Outlets.\n        *   Warehouse Application: Manages warehouse operations.\n        *   API Application: Backend REST APIs (Inventory, Orders, Products).\n        *   Database: Stores Inventory, Product, Order and User Information.\n\n*   **Level 3: Component Diagram (Focus on key components)**\n    *   **Within Web Application:**\n        *   Order Placement Component: Handles order creation by Retail Outlets.\n        *   Inventory View Component: Shows available stock.\n    *   **Within API Application:**\n        *   Inventory Management Component: Updates and retrieves inventory levels.\n        *   Order Management Component: Processes and tracks orders.\n    *   **Within Warehouse Application:**\n        *   Order Fulfillment Component: Packs and ships orders.\n        *   Receiving Component: Receives new inventory.\n\n*   **Interactions (All Levels):**\n\n    *   Retail Outlets -> IMS (Web App) : Places orders, Checks Stock.\n    *   IMS (Web App) -> API App: Requesting order details, inventory levels\n    *   API App -> Database: Data retrieval and storage.\n    *   API App -> Warehouse Application: Sends order fulfillment requests.\n    *   Warehouses -> Warehouse Application: Provides inventory updates, fulfills orders.\n    *   Supply Chain Management Services -> API App: Provides forecast data, sends restock requests.",
        "output": "```mermaid\nC4Context\n  Enterprise_Boundary(b0, \"Company\") {\n    Person(retail_outlet, \"Retail Outlet\", \"Places orders, receives inventory, sells products\")\n    System(inventory_system, \"Inventory Management System\", \"Manages inventory levels, orders, and products\")\n    System_Ext(warehouse, \"Warehouse\", \"Stores inventory, fulfills orders\")\n    System_Ext(supply_chain, \"Supply Chain Management Services\", \"Provides inventory data, initiates restock\")\n  }\n\n  Rel(retail_outlet, inventory_system, \"Places orders, Checks Stock\")\n  Rel(inventory_system, warehouse, \"Sends order fulfillment requests\")\n  Rel(supply_chain, inventory_system, \"Provides forecast data, sends restock requests\")\n\n\nC4Container\n  Container_Boundary(c1, \"Inventory Management System\") {\n    Container(web_app, \"Web Application\", \"UI for Retail Outlets\")\n    Container(warehouse_app, \"Warehouse Application\", \"Manages warehouse operations\")\n    Container(api_app, \"API Application\", \"Backend REST APIs Inventory Orders Products\")\n    ContainerDb(database, \"Database\", \"Stores Inventory Product Order and User Information\")\n  }\n\n  Rel(retail_outlet, web_app, \"Uses\", \"HTTPS\")\n  Rel(web_app, api_app, \"Requests order details, inventory levels\", \"HTTPS\")\n  Rel(api_app, database, \"Data retrieval and storage\", \"JDBC\")\n  Rel(api_app, warehouse_app, \"Sends order fulfillment requests\", \"HTTPS\")\n  Rel(warehouse, warehouse_app, \"Provides inventory updates, fulfills orders\")\n  Rel(supply_chain, api_app, \"Provides forecast data, sends restock requests\")\n\nC4Component\n  Container_Boundary(web_app_boundary, \"Web Application Components\") {\n    Component(order_placement, \"Order Placement Component\", \"Handles order creation by Retail Outlets\")\n    Component(inventory_view, \"Inventory View Component\", \"Shows available stock\")\n  }\n\n  Container_Boundary(api_app_boundary, \"API Application Components\") {\n    Component(inventory_management, \"Inventory Management Component\", \"Updates and retrieves inventory levels\")\n    Component(order_management, \"Order Management Component\", \"Processes and tracks orders\")\n  }\n\n  Container_Boundary(warehouse_app_boundary, \"Warehouse Application Components\") {\n    Component(order_fulfillment, \"Order Fulfillment Component\", \"Packs and ships orders\")\n    Component(receiving, \"Receiving Component\", \"Receives new inventory\")\n  }\n\n  Rel(retail_outlet, order_placement, \"Uses\")\n  Rel(retail_outlet, inventory_view, \"Uses\")\n  Rel(order_placement, order_management, \"Uses\")\n  Rel(inventory_view, inventory_management, \"Uses\")\n  Rel(order_management, order_fulfillment, \"Uses\")\n  Rel(warehouse, receiving, \"Uses\")\n\n\nUpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n```"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a health tracking mobile app focusing on interactions between the mobile client, a health data processing service, and cloud storage.",
        "planning": "**Level 1: System Context Diagram**\n\n*   **Components:** User, Health Tracking Mobile App, Health Data Processing Service, Cloud Storage.\n*   **Interactions:**\n    *   User uses Health Tracking Mobile App.\n    *   Health Tracking Mobile App sends data to Health Data Processing Service.\n    *   Health Tracking Mobile App retrieves data from Cloud Storage.\n    *   Health Data Processing Service stores processed data in Cloud Storage.\n\n**Level 2: Container Diagram**\n\n*   **Health Tracking Mobile App (Container):**\n    *   UI (User Interface)\n    *   Data Collection Module (sensors, manual input)\n    *   Communication Module (API calls)\n    *   Local Data Storage\n*   **Health Data Processing Service (Container):**\n    *   API Endpoint\n    *   Data Processing Engine\n    *   Database Connector\n*   **Cloud Storage (Container):**\n    *   Object Storage (e.g., AWS S3, Azure Blob Storage)\n    *   Database (e.g., NoSQL database)\n*   **Interactions:**\n    *   Mobile App UI interacts with Data Collection Module.\n    *   Data Collection Module sends raw data to Communication Module.\n    *   Communication Module sends raw data to Health Data Processing Service API.\n    *   Health Data Processing Service API sends data to Data Processing Engine.\n    *   Data Processing Engine stores processed data in Cloud Storage (Object Storage/Database).\n    *   Mobile App Communication Module retrieves processed data from Cloud Storage (Object Storage/Database).\n**Level 3: Component Diagram**\n\n*   **Health Tracking Mobile App (Components):**\n    *   Activity Tracking Component\n    *   Sleep Monitoring Component\n    *   Nutrition Logging Component\n    *   Data Synchronization Component\n*   **Health Data Processing Service (Components):**\n    *   Data Validation Component\n    *   Metrics Calculation Component\n    *   Anomaly Detection Component\n    *   Reporting Component\n*   **Cloud Storage (Components):**\n    *   API Gateway\n    *   Authentication Service\n    *   Storage Service\n*   **Interactions:** Focus on component interactions within each container (detailed API calls and data flow).",
        "output": "```mermaid\nC4Context\n  title Health Tracking System Context Diagram\n\n  Person(user, User, \"A person using the health tracking app.\")\n\n  System(mobile_app, \"Health Tracking Mobile App\", \"Tracks health data and interacts with other systems.\")\n\n  System(processing_service, \"Health Data Processing Service\", \"Processes health data and stores it.\")\n\n  SystemDb(cloud_storage, \"Cloud Storage\", \"Stores processed health data.\")\n\n  Rel(user, mobile_app, \"Uses\")\n  Rel(mobile_app, processing_service, \"Sends data to\")\n  Rel(mobile_app, cloud_storage, \"Retrieves data from\")\n  Rel(processing_service, cloud_storage, \"Stores processed data in\")\n\n\nC4Container\n  title Health Tracking System Container Diagram\n\n  Person(user2, User, \"A person using the health tracking app.\")\n\n  Container(mobile_ui, \"Mobile App UI\", \"Native App\", \"Provides user interface for the app.\")\n  Container(data_collection, \"Data Collection Module\", \"Sensors and Manual Input\", \"Collects health data.\")\n  Container(communication_module, \"Communication Module\", \"API Calls\", \"Handles communication with other services.\")\n  ContainerDb(local_storage, \"Local Data Storage\", \"SQLite\", \"Stores data locally.\")\n\n  Container_Boundary(mobile_app_boundary, \"Health Tracking Mobile App\") {\n    \n  }\n\n  Container(api_endpoint, \"API Endpoint\", \"REST API\", \"Receives data and initiates processing.\")\n  Container(data_processing_engine, \"Data Processing Engine\", \"Python\", \"Processes health data.\")\n  ContainerDb(database_connector, \"Database Connector\", \"JDBC\", \"Connects to the database.\")\n\n  Container_Boundary(processing_service_boundary, \"Health Data Processing Service\") {\n    \n  }\n\n  ContainerDb(object_storage, \"Object Storage\", \"AWS S3\", \"Stores processed data.\")\n  ContainerDb(nosql_db, \"Database\", \"MongoDB\", \"Stores user profiles.\")\n\n  Container_Boundary(cloud_storage_boundary, \"Cloud Storage\") {\n    \n  }\n\n  Rel(user2, mobile_ui, \"Uses\")\n  Rel(mobile_ui, data_collection, \"Interacts with\")\n  Rel(data_collection, communication_module, \"Sends data to\")\n  Rel(communication_module, api_endpoint, \"Sends data to\")\n  Rel(api_endpoint, data_processing_engine, \"Sends data to\")\n  Rel(data_processing_engine, object_storage, \"Stores data in\")\n  Rel(data_processing_engine, nosql_db, \"Stores data in\")\n  Rel(communication_module, object_storage, \"Retrieves data from\")\n  Rel(communication_module, nosql_db, \"Retrieves data from\")\n\nC4Component\n  title Health Tracking System Component Diagram\n\n  Component(activity, \"Activity Tracking Component\", \"\", \"Tracks physical activity.\")\n  Component(sleep, \"Sleep Monitoring Component\", \"\", \"Monitors sleep patterns.\")\n  Component(nutrition, \"Nutrition Logging Component\", \"\", \"Logs nutrition intake.\")\n  Component(sync, \"Data Synchronization Component\", \"\", \"Synchronizes data with cloud.\")\n\n  Container_Boundary(mobile_app_components, \"Health Tracking Mobile App\") {\n    \n  }\n\n  Component(validation, \"Data Validation Component\", \"\", \"Validates incoming data.\")\n  Component(metrics, \"Metrics Calculation Component\", \"\", \"Calculates health metrics.\")\n  Component(anomaly, \"Anomaly Detection Component\", \"\", \"Detects anomalies in data.\")\n  Component(reporting, \"Reporting Component\", \"\", \"Generates reports.\")\n\n  Container_Boundary(processing_service_components, \"Health Data Processing Service\") {\n    \n  }\n\n  Component(api_gateway, \"API Gateway\", \"\", \"Handles API requests.\")\n  Component(authentication, \"Authentication Service\", \"\", \"Authenticates users.\")\n  Component(storage_service, \"Storage Service\", \"\", \"Manages data storage.\")\n\n  Container_Boundary(cloud_storage_components, \"Cloud Storage\") {\n    \n  }\n\n  Rel(activity, sync, \"Sends data to\")\n  Rel(sleep, sync, \"Sends data to\")\n  Rel(nutrition, sync, \"Sends data to\")\n\n  Rel(validation, metrics, \"Sends data to\")\n  Rel(metrics, anomaly, \"Sends data to\")\n  Rel(anomaly, reporting, \"Sends data to\")\n\n  Rel(api_gateway, authentication, \"Uses\")\n  Rel(api_gateway, storage_service, \"Uses\")\n```"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for an online forum system, showing components such as user authentication, forum posting, and notification services.",
        "planning": "*   **Users:** Interact with the System (Browsing, posting, etc.)\n*   **Web Application:** Handles user requests and presents the forum interface.\n    *   Interacts with: User Authentication, Forum Posting Service, Notification Service, Database.\n*   **User Authentication Service:** Manages user accounts and authentication.\n    *   Interacts with: Web Application, Database.\n*   **Forum Posting Service:** Handles creation, editing, and deletion of forum posts.\n    *   Interacts with: Web Application, Database, Notification Service.\n*   **Notification Service:** Sends notifications to users (e.g., new replies).\n    *   Interacts with: Forum Posting Service, Web Application.\n*   **Database:** Stores user data, forum posts, and other relevant information.\n    *   Interacts with: User Authentication Service, Forum Posting Service, Web Application.",
        "output": "C4Component\n\nPerson(user, User, \"Interacts with the System \\n(Browsing posting etc.)\")\n\nContainer(web_app, \"Web Application\", \"\", \"Handles user requests and presents \\nthe forum interface\")\n\nContainer(auth_service, \"User Authentication Service\", \"\", \"Manages user accounts and authentication\")\n\nContainer(posting_service, \"Forum Posting Service\", \"\", \"Handles creation editing and deletion \\nof forum posts\")\n\nContainer(notification_service, \"Notification Service\", \"\", \"Sends notifications to users \\n(e.g. new replies)\")\n\nContainerDb(database, \"Database\", \"\", \"Stores user data forum posts and \\nother relevant information\")\n\nRel(user, web_app, \"Uses\")\n\nRel(web_app, auth_service, \"Uses\")\n\nRel(web_app, posting_service, \"Uses\")\n\nRel(web_app, notification_service, \"Uses\")\n\nRel(web_app, database, \"Uses\")\n\nRel(auth_service, database, \"Uses\")\n\nRel(posting_service, database, \"Uses\")\n\nRel(posting_service, notification_service, \"Uses\")\n\nUpdateRelStyle(user, web_app, $offsetY=\"-20\")\nUpdateRelStyle(web_app, auth_service, $offsetX=\"-50\")\nUpdateRelStyle(web_app, posting_service, $offsetY=\"40\")\nUpdateRelStyle(web_app, notification_service, $offsetX=\"50\")\nUpdateRelStyle(web_app, database, $offsetY=\"-40\")\nUpdateRelStyle(auth_service, database, $offsetX=\"-30\")\nUpdateRelStyle(posting_service, database, $offsetX=\"30\")\nUpdateRelStyle(posting_service, notification_service, $offsetY=\"-20\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a file sharing application, illustrating components such as an upload/download service, security module, and storage system.",
        "planning": "**C4 Diagram Plan: File Sharing Application**\n\n*   **Context (Level 1):**\n    *   System: \"File Sharing Application\" - Allows users to upload, store, and download files.\n    *   Users: Interact with the application via a \"Web Browser\" or \"Mobile App\".\n\n*   **Container (Level 2):**\n    *   \"Web Application\": Presents the user interface (UI).\n    *   \"Mobile Application\": Presents the user interface (UI).\n    *   \"API Gateway\": Entry point for all requests (authentication, routing).\n    *   \"Upload/Download Service\": Handles file uploads and downloads.\n    *   \"Security Module\": Authentication, authorization, and access control.\n    *   \"Storage System\": Stores the files (e.g., object storage).\n    *   \"Database\": Stores metadata about files, users, and permissions.\n\n*   **Component (Level 3):**\n    *   **Within \"Web Application\":**\n        *   \"UI Components\": Display files, upload forms, download links.\n    *   **Within \"Mobile Application\":**\n        *   \"UI Components\": Display files, upload forms, download links.\n    *   **Within \"API Gateway\":**\n        *   \"Authentication Component\": Verifies user credentials.\n        *   \"Authorization Component\": Determines access rights.\n        *   \"Request Router\": Routes requests to appropriate services.\n    *   **Within \"Upload/Download Service\":**\n        *   \"Upload Manager\": Receives and processes file uploads.\n        *   \"Download Manager\": Retrieves and streams files for download.\n        *   \"Chunking Component\": Handles large file uploads/downloads in chunks.\n    *   **Within \"Security Module\":**\n        *   \"Authentication Provider\": Integrates with identity providers (e.g., OAuth).\n        *   \"Access Control Logic\": Enforces permissions based on roles and ownership.\n    *   **Within \"Storage System\":**\n        *   \"Object Storage Interface\": Manages file storage and retrieval (e.g., AWS S3, Azure Blob Storage).\n    *   **Within \"Database\":**\n        *   \"User Management\": Stores user data.\n        *   \"File Metadata\": Stores file information (name, size, location).\n        *   \"Permissions\": Stores access control lists.\n\n*   **Interactions:**\n    *   User (via Web/Mobile App) -> API Gateway\n    *   API Gateway -> Security Module (Authentication/Authorization)\n    *   API Gateway -> Upload/Download Service\n    *   Upload/Download Service -> Storage System\n    *   Upload/Download Service -> Database (metadata update)\n    *   Security Module -> Database (user/permission lookup)\n    *   Web/Mobile App -> Database(File Listing).",
        "output": "C4Container\n  System_Ext(user_web, 'User Web Browser', 'User interacting with the application via a web browser')\n  System_Ext(user_mobile, 'User Mobile App', 'User interacting with the application via a mobile app')\n\n  Container(web_app, 'Web Application', 'Presents the user interface UI')\n  Container(mobile_app, 'Mobile Application', 'Presents the user interface UI')\n  Container(api_gateway, 'API Gateway', 'Entry point for all requests authentication routing')\n  Container(upload_download_service, 'Upload/Download Service', 'Handles file uploads and downloads')\n  Container(security_module, 'Security Module', 'Authentication authorization and access control')\n  ContainerDb(database, 'Database', 'Stores metadata about files users and permissions')\n  Container_Ext(storage_system, 'Storage System', 'Stores the files e.g. object storage')\n\n  Rel(user_web, web_app, 'Uses')\n  Rel(user_mobile, mobile_app, 'Uses')\n  Rel(web_app, api_gateway, 'Uses API')\n  Rel(mobile_app, api_gateway, 'Uses API')\n  Rel(api_gateway, security_module, 'Authenticates/Authorizes')\n  Rel(api_gateway, upload_download_service, 'Requests file operations')\n  Rel(upload_download_service, storage_system, 'Stores/Retrieves files')\n  Rel(upload_download_service, database, 'Updates metadata')\n  Rel(security_module, database, 'Looks up user/permissions')\n  Rel(web_app, database, 'File Listing')\n  Rel(mobile_app, database, 'File Listing')\n\n\n  UpdateRelStyle(user_web, web_app, $offsetY='20')\n  UpdateRelStyle(user_mobile, mobile_app, $offsetY='20')\n  UpdateRelStyle(web_app, api_gateway, $offsetY='20')\n  UpdateRelStyle(mobile_app, api_gateway, $offsetY='20')\n  UpdateRelStyle(api_gateway, security_module, $offsetY='20')\n  UpdateRelStyle(api_gateway, upload_download_service, $offsetY='20')\n  UpdateRelStyle(upload_download_service, storage_system, $offsetY='20')\n  UpdateRelStyle(upload_download_service, database, $offsetY='20')\n  UpdateRelStyle(security_module, database, $offsetY='20')\n  UpdateRelStyle(web_app, database, $offsetY='20')\n  UpdateRelStyle(mobile_app, database, $offsetY='20')"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a restaurant booking system depicting interactions between a web interface, booking service, and the restaurant management backend.",
        "planning": "*   **Level 1 (Context):**\n    *   **System:** Restaurant Booking System.\n    *   **Users:** Customers.\n    *   **External Systems:** Payment Gateway (optional), Email Service (optional).\n\n*   **Level 2 (Container):**\n    *   **Web Interface:** (WebApp) Handles user interaction, displays available tables/times, submits booking requests.\n    *   **Booking Service:** (API Application) Receives booking requests from the Web Interface, manages bookings, interacts with the Restaurant Management Backend.\n    *   **Restaurant Management Backend:** (Database/Application) Stores table availability, booking data, restaurant information.\n\n*   **Level 3 (Component - Focus on Booking Service):**\n    *   **API Gateway:** Entry point for all requests to the Booking Service.\n    *   **Booking Manager:** Component responsible for creating, updating, and cancelling bookings.\n    *   **Availability Checker:** Component that determines table availability based on time and party size.\n    *   **Data Access Layer:** Component that interacts with the Restaurant Management Backend database.\n\n*   **Interactions:**\n    *   Customer -> Web Interface: Browses tables, submits booking requests.\n    *   Web Interface -> Booking Service: Sends booking requests.\n    *   Booking Service -> Restaurant Management Backend: Checks availability, creates/updates booking records.\n    *   Booking Service -> Payment Gateway (optional): Processes payments.\n    *   Booking Service -> Email Service (optional): Sends confirmation emails.",
        "output": "C4Context\n  Enterprise_Boundary(b0, \"Restaurant\") {\n    Person(customer, \"Customer\", \"Makes reservations\")\n\n    System(booking_system, \"Restaurant Booking System\", \"Allows customers to book tables online\")\n\n    System_Ext(payment_gateway, \"Payment Gateway\", \"Processes online payments\", $tags=\"optional\")\n    System_Ext(email_service, \"Email Service\", \"Sends booking confirmations\", $tags=\"optional\")\n  }\n\n  BiRel(customer, booking_system, \"Makes bookings via\")\n  Rel(booking_system, payment_gateway, \"Uses\", \"For payments\")\n  Rel(booking_system, email_service, \"Uses\", \"Sends confirmation emails\")\n\n\nC4Container\n  Container_Boundary(c1, \"Restaurant Booking System\") {\n    Container(web_interface, \"Web Interface\", \"Angular\", \"Handles user interaction\")\n    Container(booking_service, \"Booking Service\", \"Java Spring Boot\", \"Manages bookings\")\n    ContainerDb(restaurant_db, \"Restaurant Management Backend\", \"PostgreSQL\", \"Stores table availability and booking data\")\n  }\n\n  Rel(customer, web_interface, \"Uses\", \"HTTPS\")\n  Rel(web_interface, booking_service, \"Sends booking requests\", \"JSON/HTTPS\")\n  Rel(booking_service, restaurant_db, \"Reads/Writes booking data\", \"JDBC\")\n  Rel(booking_service, payment_gateway, \"Processes payments\", \"HTTPS\")\n  Rel(booking_service, email_service, \"Sends emails\", \"SMTP\")\n\n\nC4Component\n  Container_Boundary(booking_service_boundary, \"Booking Service\") {\n    Component(api_gateway, \"API Gateway\", \"Spring Cloud Gateway\", \"Entry point for requests\")\n    Component(booking_manager, \"Booking Manager\", \"Spring Bean\", \"Creates and manages bookings\")\n    Component(availability_checker, \"Availability Checker\", \"Spring Bean\", \"Checks table availability\")\n    Component(data_access_layer, \"Data Access Layer\", \"Spring JDBC\", \"Interacts with the database\")\n  }\n\n  Rel(api_gateway, booking_manager, \"Routes requests to\")\n  Rel(booking_manager, availability_checker, \"Uses\")\n  Rel(booking_manager, data_access_layer, \"Uses\")\n  Rel(availability_checker, data_access_layer, \"Queries\")\n  Rel(data_access_layer, restaurant_db, \"Reads/Writes\")\n\n  UpdateLayoutConfig($c4ShapeInRow=\"2\", $c4BoundaryInRow=\"1\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a digital wallet application showing components such as transaction processing, user authentication, and third-party payment integration.",
        "planning": "**C4 Diagram Plan: Digital Wallet Application**\n\n**Context (Level 1):**\n\n*   **User:** Uses the Digital Wallet Application.\n*   **Digital Wallet Application:** The system in scope.\n*   **Bank:** External banking system.\n*   **Third-Party Payment Provider:** External payment gateway (e.g., PayPal, Stripe).\n\n**Containers (Level 2):**\n\n*   **Mobile App (Client):** User interface (iOS/Android).\n*   **API Gateway:** Entry point for all requests.\n*   **Authentication Service:** Handles user login and authentication.\n*   **Transaction Service:** Processes and records transactions.\n*   **Payment Integration Service:** Communicates with third-party payment providers.\n*   **Database:** Stores user data, transaction history, wallet balances.\n\n**Components (Level 3 - Example for Transaction Service):**\n\n*   **Transaction Request Handler:** Receives transaction requests.\n*   **Balance Checker:** Verifies sufficient funds.\n*   **Transaction Logger:** Records transaction details.\n*   **Notification Service:** Sends transaction confirmation to the user.\n\n**Interactions:**\n\n*   User (via Mobile App) -> API Gateway: Initiates actions (login, payment).\n*   API Gateway -> Authentication Service: Verifies user credentials.\n*   API Gateway -> Transaction Service: Submits transaction requests.\n*   Transaction Service -> Balance Checker: Checks account balance.\n*   Transaction Service -> Payment Integration Service: Processes payments via third-party providers.\n*   Transaction Service -> Database: Stores transaction data.\n*   Transaction Service -> Notification Service: Sends user notifications.\n*   Transaction Service -> Bank: Initiates bank transfers or balance checks.\n*   Payment Integration Service -> Third-Party Payment Provider: Processing payment.",
        "output": "C4Container\n\nPerson(user, User, \"Uses the Digital Wallet Application\")\nSystem_Ext(bank, Bank, \"External banking system\")\nSystem_Ext(payment_provider, \"Third Party\", \"External payment gateway\")\n\nContainer_Boundary(wallet, \"Digital Wallet Application\") {\n    Container(mobile_app, \"Mobile App\", \"iOS/Android\", \"User interface\")\n    Container(api_gateway, \"API Gateway\", \"\", \"Entry point for requests\")\n    Container(auth_service, \"Authentication\", \"\", \"Handles user login\")\n    Container(transaction_service, \"Transaction\", \"\", \"Processes transactions\")\n    Container(payment_integration, \"Payment\", \"\", \"Third-party integration\")\n    ContainerDb(database, \"Database\", \"\", \"Stores user data\")\n}\n\nRel(user, mobile_app, \"Uses\")\nRel(mobile_app, api_gateway, \"Requests\")\nRel(api_gateway, auth_service, \"Authenticates\")\nRel(api_gateway, transaction_service, \"Manages transactions\")\nRel(transaction_service, database, \"Stores data\")\nRel(transaction_service, payment_integration, \"Processes payments\")\nRel(transaction_service, bank, \"Initiates transfers\")\nRel(payment_integration, payment_provider, \"Payment processing\")\n\nUpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a ride-sharing application focusing on key components like a driver app, rider app, matching engine, and payment service.",
        "planning": "**C4 Diagram Plan for Ride-Sharing Application**\n\n**Level 1: System Context**\n\n*   **System:** Ride-Sharing Application\n*   **Users:**\n    *   Driver: Uses Driver App.\n    *   Rider: Uses Rider App.\n*   **External Systems:**\n    *   Payment Gateway (e.g., Stripe, PayPal)\n    *   Mapping Service (e.g., Google Maps)\n\n**Level 2: Container Diagram**\n\n*   **Containers:**\n    *   Driver App (Mobile App):\n        *   Technology: Native Mobile (iOS/Android)\n        *   Purpose: Driver interface for accepting ride requests, navigation, and managing account.\n    *   Rider App (Mobile App):\n        *   Technology: Native Mobile (iOS/Android)\n        *   Purpose: Rider interface for requesting rides, tracking driver, and making payments.\n    *   Matching Engine (API/Application):\n        *   Technology: Cloud-based (e.g., AWS, Azure, GCP)\n        *   Purpose: Matches riders with available drivers based on location, availability, and other criteria.\n    *   Payment Service (API/Application):\n        *   Technology: Cloud-based\n        *   Purpose: Handles payment processing, fare calculation, and payouts.\n    *   Database (Data Store):\n        *   Technology: Relational or NoSQL (e.g., PostgreSQL, MongoDB)\n        *   Purpose: Stores user data, ride history, location data, and payment information.\n\n*   **Interactions:**\n    *   Rider App -> Matching Engine: Ride request\n    *   Driver App -> Matching Engine: Availability updates\n    *   Matching Engine -> Driver App: Ride offer\n    *   Driver App -> Rider App: Location updates, communication\n    *   Rider App -> Payment Service: Payment processing\n    *   Payment Service -> Payment Gateway: External payment processing\n    *   Matching Engine -> Database: Store ride data, driver/rider data.\n    *   Driver App -> Mapping Service: Navigation.\n    *   Rider App -> Mapping Service: Location services, estimated time of arrival (ETA).\n\n**Level 3: Component Diagram (Example: Matching Engine)**\n\n*   **Components:**\n    *   Location Tracker: Tracks driver/rider locations.\n    *   Matching Algorithm: Implements the logic for matching riders and drivers.\n    *   Notification Service: Sends notifications to drivers and riders.\n    *   Rate Limiter: Protects from abuse.\n\n*   **Interactions (within Matching Engine):**\n    *   Location Tracker -> Matching Algorithm: Provides location data.\n    *   Matching Algorithm -> Notification Service: Triggers notifications.\n    *   External (Driver App/Rider App) -> Rate Limiter -> other components.",
        "output": "C4Container\n  Person(rider, Rider, \"Requests rides\")\n  Person(driver, Driver, \"Accepts ride requests\")\n\n  Container_Boundary(ride_sharing, \"Ride-Sharing Application\") {\n    Container(driver_app, \"Driver App\", \"Mobile App iOS/Android\", \"Driver interface for accepting ride requests navigation and managing account\")\n    Container(rider_app, \"Rider App\", \"Mobile App iOS/Android\", \"Rider interface for requesting rides tracking driver and making payments\")\n    Container(matching_engine, \"Matching Engine\", \"Cloud-based\", \"Matches riders with available drivers based on location and availability\")\n    Container(payment_service, \"Payment Service\", \"Cloud-based\", \"Handles payment processing fare calculation and payouts\")\n    ContainerDb(database, \"Database\", \"Relational/NoSQL\", \"Stores user data ride history location and payment information\")\n  }\n\n  System_Ext(payment_gateway, \"Payment Gateway\", \"External Payment Processing\")\n  System_Ext(mapping_service, \"Mapping Service\", \"Location and Mapping Data\")\n\n  Rel(rider_app, matching_engine, \"Ride request\")\n  Rel(driver_app, matching_engine, \"Availability updates\")\n  Rel(matching_engine, driver_app, \"Ride offer\")\n  Rel(driver_app, rider_app, \"Location updates communication\")\n  Rel(rider_app, payment_service, \"Payment processing\")\n  Rel(payment_service, payment_gateway, \"External payment processing\")\n  Rel(matching_engine, database, \"Store ride data driver/rider data\")\n  Rel(driver_app, mapping_service, \"Navigation\")\n  Rel(rider_app, mapping_service, \"Location services ETA\")\n\n  UpdateRelStyle(rider_app, matching_engine, $offsetY=\"-20\")\n  UpdateRelStyle(driver_app, matching_engine, $offsetY=\"20\")\n  UpdateRelStyle(matching_engine, driver_app, $offsetX=\"30\")\n  UpdateRelStyle(driver_app, rider_app, $offsetY=\"-40\", $offsetX=\"-30\")\n  UpdateRelStyle(rider_app, payment_service, $offsetY=\"30\")\n  UpdateRelStyle(payment_service, payment_gateway, $offsetY=\"-30\")\n  UpdateRelStyle(matching_engine, database, $offsetX=\"-50\")\n  UpdateRelStyle(driver_app, mapping_service, $offsetX=\"50\")\n  UpdateRelStyle(rider_app, mapping_service, $offsetX=\"-50\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for an event management platform showing modules like event scheduling, registration service, and notification service.",
        "planning": "**Context (Level 1):**\n\n*   **System:** Event Management Platform - Container for all services.\n*   **Users:** Event Organizers, Attendees.\n\n**Containers (Level 2):**\n\n*   **Web Application:** UI for organizers and attendees.\n*   **API Application:** Backend REST API for the web application.\n*   **Event Scheduling Service:** Manages event creation, updates, and deletion.\n*   **Registration Service:** Handles attendee registration and ticketing.\n*   **Notification Service:** Sends email and SMS notifications.\n*   **Database:** Stores event data, user data, registration data.\n\n**Components (Level 3, For Key Containers):**\n\n*   **API Application Components:**\n    *   Authentication/Authorization Module\n    *   Event API\n    *   Registration API\n    *   Notification API\n*   **Event Scheduling Service Components:**\n    *   Event Creation Module\n    *   Event Update Module\n    *   Event Retrieval Module\n*   **Registration Service Components:**\n    *   Registration Processing Module\n    *   Payment Processing Module\n    *   Ticket Generation Module\n*   **Notification Service Components:**\n    *   Email Sending Module\n    *   SMS Sending Module\n\n**Interactions:**\n\n*   **User -> Web Application:** Browses events, registers, manages events (organizers).\n*   **Web Application -> API Application:** Calls APIs for event data, registration, etc.\n*   **API Application -> Event Scheduling Service:** Gets/creates/updates event data.\n*   **API Application -> Registration Service:** Registers attendees, processes payments.\n*   **Registration Service -> Notification Service:** Triggers registration confirmation notifications.\n*   **Event Scheduling Service -> Notification Service:** Triggers event update notifications.\n*   **API Application -> Database:** Stores and retrieves data.\n*   **Event Scheduling Service -> Database:** Stores and retrieves event related data\n*   **Registration Service -> Database:** Stores and retrieves registration related data",
        "output": "C4Container\n  Person(organizer, Event Organizer, \"Creates and manages events\")\n  Person(attendee, Attendee, \"Registers for events\")\n\n  Container_Boundary(platform, EventManagementPlatform) {\n    Container(web_app, WebApplication, \"Angular\", \"UI for organizers and attendees\")\n    Container(api_app, APIApplication, \"Java Spring\", \"Backend REST API\")\n    Container(event_service, EventSchedulingService, \"Java\", \"Manages event scheduling\")\n    Container(registration_service, RegistrationService, \"Java\", \"Handles registration and ticketing\")\n    Container(notification_service, NotificationService, \"Python\", \"Sends notifications\")\n    ContainerDb(database, Database, \"PostgreSQL\", \"Stores event data, user data\")\n  }\n\n  Rel(organizer, web_app, \"Uses\")\n  Rel(attendee, web_app, \"Uses\")\n  Rel(web_app, api_app, \"Calls API\", \"HTTPS/JSON\")\n  Rel(api_app, event_service, \"Uses\")\n  Rel(api_app, registration_service, \"Uses\")\n  Rel(registration_service, notification_service, \"Sends via\")\n  Rel(event_service, notification_service, \"Sends via\")\n  Rel(api_app, database, \"Reads/Writes\")\n  Rel(event_service, database, \"Reads/Writes\")\n  Rel(registration_service, database, \"Reads/Writes\")\n\n  C4Component\nContainer(api_app, 'API Application', 'Java Spring', 'Backend REST API') {\n  Component(auth, 'Authentication/Authorization Module', 'Spring Security', 'Handles user authentication and authorization.')\n  Component(event_api, 'Event API', 'REST Controller', 'Provides endpoints for managing events.')\n  Component(registration_api, 'Registration API', 'REST Controller', 'Provides endpoints for managing registrations.')\n  Component(notification_api, 'Notification API', 'REST Controller', 'Provides endpoints for sending notifications.')\n\n  Rel(auth, database, 'Reads/Writes', 'JDBC')\n  Rel(event_api, event_service, 'Uses', 'gRPC')\n  Rel(registration_api, registration_service, 'Uses', 'gRPC')\n  Rel(notification_api, notification_service, 'Uses', 'gRPC')\n}\n\nContainer(event_service, 'Event Scheduling Service', 'Java', 'Manages event scheduling.') {\n  Component(event_creation, 'Event Creation Module', 'Java Class', 'Handles the creation of new events.')\n  Component(event_update, 'Event Update Module', 'Java Class', 'Handles updating existing events.')\n  Component(event_retrieval, 'Event Retrieval Module', 'Java Class', 'Handles retrieving event information.')\n\n  Rel(event_creation, database, 'Writes', 'JDBC')\n  Rel(event_update, database, 'Writes', 'JDBC')\n  Rel(event_retrieval, database, 'Reads', 'JDBC')\n}\n\nContainer(registration_service, 'Registration Service', 'Java', 'Handles registration and ticketing.') {\n  Component(registration_processing, 'Registration Processing Module', 'Java Class', 'Handles the processing of event registrations.')\n  Component(payment_processing, 'Payment Processing Module', 'Java Class', 'Handles payment processing for registrations.')\n  Component(ticket_generation, 'Ticket Generation Module', 'Java Class', 'Generates tickets for registered attendees.')\n\n  Rel(registration_processing, database, 'Writes', 'JDBC')\n  Rel(payment_processing, notification_service, 'Uses', 'REST API')\n  Rel(ticket_generation, database, 'Writes', 'JDBC')\n}\n\nContainer(notification_service, 'Notification Service', 'Python', 'Sends notifications.') {\n  Component(email_sending, 'Email Sending Module', 'Python Script', 'Sends email notifications.')\n  Component(sms_sending, 'SMS Sending Module', 'Python Script', 'Sends SMS notifications.')\n\n  Rel(email_sending, database, 'Reads', 'File')\n  Rel(sms_sending, database, 'Reads', 'File')\n}"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for an e-government portal representing components such as a citizen portal, service management, and backend processing.",
        "planning": "**C4 Diagram Plan: E-Government Portal**\n\n*   **Level 1: Context Diagram**\n    *   System: E-Government Portal\n    *   Users: Citizens (interacting via Citizen Portal)\n    *   External Systems: Government Departments (backend data), Payment Gateway.\n    *   Interaction: Citizens use portal to access services; Portal retrieves/updates data from departments; Portal uses gateway for payments.\n\n*   **Level 2: Container Diagram**\n    *   Containers:\n        *   Citizen Portal (Web Application)\n        *   Service Management (Web Application)\n        *   API Gateway\n        *   Backend Processing (Application)\n        *   Database\n    *   Interaction:\n        *   Citizen Portal uses API Gateway.\n        *   Service Management uses API Gateway.\n        *   API Gateway routes requests to Backend Processing.\n        *   Backend Processing interacts with Database.\n\n*   **Level 3: Component Diagram (Example: Citizen Portal Container)**\n    *   Components:\n        *   Authentication/Authorization\n        *   Service Catalogue\n        *   Forms Engine\n        *   Notification Service\n    *   Interaction:\n        *   User authenticates.\n        *   Service Catalogue displays available services.\n        *   Forms Engine renders forms.\n        *   Notification Service sends updates.\n        *   Components call the API Gateway.\n\n    *   Interaction: Each component interacts with the API Gateway container for backend data and operations. Similar diagrams can be created for Service Management and Backend Processing containers.",
        "output": "C4Context\n  Enterprise_Boundary(egov, E-Government){\n    Person(citizen, Citizen, \"Uses the portal to access services\")\n    System(egov_portal, \"E-Government Portal\", \"Provides access to government services\")\n    System_Ext(gov_dept, \"Government Departments\", \"Provides backend data\")\n    System_Ext(payment_gateway, \"Payment Gateway\", \"Processes payments\")\n  }\n\n  BiRel(citizen, egov_portal, \"Uses\")\n  Rel(egov_portal, gov_dept, \"Retrieves/Updates Data\")\n  Rel(egov_portal, payment_gateway, \"Uses for Payments\")\n\nC4Container\n  System_Ext(gov_dept_c, \"Government Departments\", \"Provides backend data\")\n  Container(citizen_portal, \"Citizen Portal\", \"Web Application\", \"Provides citizen access to services\")\n  Container(service_mgmt, \"Service Management\", \"Web Application\", \"Manages government services\")\n  Container(api_gateway, \"API Gateway\", \"Application\", \"Routes requests and handles authentication\")\n  Container(backend_processing, \"Backend Processing\", \"Application\", \"Processes requests and interacts with data\")\n  ContainerDb(database, \"Database\", \"Database\", \"Stores application data\")\n\n  Rel(citizen_portal, api_gateway, \"Uses\")\n  Rel(service_mgmt, api_gateway, \"Uses\")\n  Rel(api_gateway, backend_processing, \"Routes Requests\")\n  Rel(backend_processing, database, \"Interacts with\")\n  Rel(backend_processing, gov_dept_c, \"Retrieves data from\")\n\nC4Component\n  Container(api_gateway_c, \"API Gateway\", \"\", \"\")\n  Container(citizen_portal_c, \"Citizen Portal\", \"Web Application\", \"\"){\n    Component(auth, \"Authentication/Authorization\", \"\", \"Manages user authentication and authorization\")\n    Component(service_catalog, \"Service Catalogue\", \"\", \"Displays available services\")\n    Component(forms_engine, \"Forms Engine\", \"\", \"Renders dynamic forms\")\n    Component(notification_service, \"Notification Service\", \"\", \"Sends user notifications\")\n\n    Rel(auth, api_gateway_c, \"Uses\")\n    Rel(service_catalog, api_gateway_c, \"Uses\")\n    Rel(forms_engine, api_gateway_c, \"Uses\")\n    Rel(notification_service, api_gateway_c, \"Uses\")\n  }\n\nUpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a job recruitment platform, detailing interaction between user profiles, job listings, and employer dashboards.",
        "planning": "**Level 1: System Context**\n\n*   **System:** Job Recruitment Platform\n*   **Users:** Job Seekers (External) - Interact to search jobs and manage profiles.\n*   **Users:** Employers (External) - Interact to post jobs and manage applications.\n\n**Level 2: Container Diagram**\n\n*   **Web Application:** (Container) - User interface for job seekers and employers.\n*   **API Application:** (Container) - Exposes API endpoints for web application.\n*   **Database:** (Container) - Stores user profiles, job listings, and application data.\n\n**Level 3: Component Diagram (Focus: User Profiles, Job Listings, Employer Dashboards)**\n\n*   **User Profile Component:**\n    *   Interacts with Database: Read/Write user data.\n    *   Interacts with Job Listing Component: Applies for jobs.\n    *   Accessed via API Application\n*   **Job Listing Component:**\n    *   Interacts with Database: Read/Write job data.\n    *   Interacts with User Profile Component: Receives applications.\n    *   Interacts with Employer Dashboard Component: Created and managed by employers.\n    *   Accessed via API Application\n*   **Employer Dashboard Component:**\n    *   Interacts with Database: Read/Write employer data, job postings, application data.\n    *   Interacts with Job Listing Component: Creates/Updates job listings.\n    *   Accessed via API Application\n*   **API Application**: Orchestrates interactions between the components and data access to the Database.\n\n**Interactions:**\n\n*   Job Seekers -> Web Application -> API -> User Profile Component & Job Listing Component -> Database.\n*   Employers -> Web Application -> API -> Employer Dashboard Component & Job Listing Component -> Database.\n*   User Profile Component <-> Job Listing Component (Application Process).",
        "output": "C4Context\n  UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n  Person(jobSeeker, \"Job Seeker\", \"Searches jobs and manages profiles\")\n  Person(employer, \"Employer\", \"Posts jobs and manages applications\")\n  System(jobPlatform, \"Job Recruitment Platform\", \"Connects job seekers with employers\")\n\n  Rel(jobSeeker, jobPlatform, \"Uses\")\n  Rel(employer, jobPlatform, \"Uses\")\n\n\nC4Container\n  UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n  Container(webApp, \"Web Application\", \"User interface for job seekers and employers\")\n  Container(apiApp, \"API Application\", \"Exposes API endpoints\")\n  ContainerDb(database, \"Database\", \"Stores user data and job listings\")\n\n  Rel(jobSeeker, webApp, \"Uses\")\n  Rel(employer, webApp, \"Uses\")\n  Rel(webApp, apiApp, \"Uses API\")\n  Rel(apiApp, database, \"Reads/Writes Data\")\n\n\nC4Component\n  UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")\n  Container(apiContainer, \"API Application\") {\n Component(userProfile, \"User Profile Component\", \"Manages user profiles\")\n    Component(jobListing, \"Job Listing Component\", \"Manages job listings\")\n    Component(employerDashboard, \"Employer Dashboard Component\", \"Manages employer data and applications\")\n\n    Rel(userProfile, database, \"Read/Write\", \"JDBC\")\n    Rel(jobListing, database, \"Read/Write\", \"JDBC\")\n    Rel(employerDashboard, database, \"Read/Write\", \"JDBC\")\n\n    Rel(userProfile, jobListing, \"Applies for\", \"HTTPS\")\n    Rel(employerDashboard, jobListing, \"Creates/Updates\", \"HTTPS\")\n  }\n  Rel(webApp, apiContainer, \"Uses\")"
    },
    {
        "diagram_type": "c4",
        "prompt": "Generate a C4 diagram for a smart home automation system illustrating components such as sensor modules, a central hub, and a user control application.",
        "planning": "*   **Level 1 (System Context):**\n    *   Smart Home Automation System (Central Box): The overall system being described.\n    *   User (Person): Interacts with the system via the User Control Application.\n    *   External Services (Cloud, etc.): Integrations with other platforms (e.g., weather services, voice assistants).\n\n*   **Level 2 (Container Diagram):**\n    *   User Control Application (Mobile App/Web App): Allows user to control and monitor the system.\n    *   Central Hub (Application): Core application managing all smart home logic.\n    *   Sensor Modules (Physical Devices): Hardware devices that collects data from environment.\n    *   Database (Data Store): Stores system configurations, sensor data, and user preferences.\n\n*   **Level 3 (Component Diagram - Central Hub):**\n    *   Communication Manager: Handles communication with Sensor Modules and User Control Application.\n    *   Automation Engine: Executes defined automation rules.\n    *   Data Processing Module: Processes data received from Sensor Modules.\n    *   Security Module: Manages security and authentication.\n\n*   **Level 3 (Component Diagram - Sensor Modules):**\n    *   Sensor Interface: Hardware interface for data acquisition.\n    *   Data Transmission Module: Transmits data to the Central Hub (e.g., using Zigbee, Z-Wave, Wi-Fi).\n\n*   **Interactions:**\n    *   User interacts with the User Control Application.\n    *   User Control Application communicates with the Central Hub.\n    *   Sensor Modules send data to the Central Hub.\n    *   Central Hub processes data and executes automation.\n    *   Central Hub stores data in the Database.\n    *   Central Hub interacts with external services.",
        "output": "```mermaid\nC4Context\n  title Smart Home Automation System Context Diagram\n\n  Person(user, User, \"Controls and monitors the smart home\")\n\n  System(smart_home, \"Smart Home Automation System\", \"Automates home functions based on sensor data and user preferences\")\n\n  System_Ext(external_services, \"External Services\", \"Cloud services, weather data, voice assistants\")\n\n  Rel(user, smart_home, \"Interacts with\")\n  Rel(smart_home, external_services, \"Integrates with\")\n\nC4Container\n  title Smart Home Automation System Container Diagram\n\n  Person(user_container, User, \" \")\n\n  Container(user_app, \"User Control Application\", \"Mobile App/Web App\", \"Allows user to control and monitor the system\")\n\n  Container(central_hub, \"Central Hub\", \"Application\", \"Core application managing all smart home logic\")\n\n  Container(sensor_modules, \"Sensor Modules\", \"Physical Devices\", \"Collects data from environment\")\n\n  ContainerDb(database, \"Database\", \"Data Store\", \"Stores system configurations, sensor data, and user preferences\")\n\n  Rel(user_container, user_app, \"Uses\")\n  Rel(user_app, central_hub, \"Communicates with\")\n  Rel(sensor_modules, central_hub, \"Sends data to\")\n  Rel(central_hub, database, \"Stores data in\")\n\nC4Component\n  title Central Hub Component Diagram\n\n  Container(central_hub_container, \"Central Hub\", \" \", \" \")\n\n  Component(communication_manager, \"Communication Manager\", \" \", \"Handles communication with Sensor Modules and User Control Application\")\n\n  Component(automation_engine, \"Automation Engine\", \" \", \"Executes defined automation rules\")\n\n  Component(data_processing_module, \"Data Processing Module\", \" \", \"Processes data received from Sensor Modules\")\n\n  Component(security_module, \"Security Module\", \" \", \"Manages security and authentication\")\n\n  Rel(central_hub_container, communication_manager, \"Uses\")\n  Rel(central_hub_container, automation_engine, \"Uses\")\n  Rel(central_hub_container, data_processing_module, \"Uses\")\n  Rel(central_hub_container, security_module, \"Uses\")\n\nC4Component\n  title Sensor Modules Component Diagram\n\n  Container(sensor_modules_container, \"Sensor Modules\", \" \", \" \")\n\n  Component(sensor_interface, \"Sensor Interface\", \"Hardware\", \"Hardware interface for data acquisition\")\n\n  Component(data_transmission_module, \"Data Transmission Module\", \" \", \"Transmits data to the Central Hub\")\n\n  Rel(sensor_modules_container, sensor_interface, \"Uses\")\n  Rel(sensor_modules_container, data_transmission_module, \"Uses\")\n\n\nUpdateLayoutConfig($c4ShapeInRow=\"2\", $c4BoundaryInRow=\"1\")\n```"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Provide a class diagram for a simplified E-commerce system showing classes for Product, Order, Customer, and Payment.",
        "planning": "*   **Classes:** Product, Order, Customer, Payment.\n\n*   **Product:**\n    *   Attributes: productId, name, description, price.\n    *   Methods: (Optional: getDetails, updatePrice).\n\n*   **Order:**\n    *   Attributes: orderId, orderDate, orderTotal.\n    *   Methods: addProduct, removeProduct, calculateTotal.\n    *   Relationships: One-to-many relationship with Product (Order contains many Products), One-to-one relationship with Customer, One-to-one relationship with Payment.\n\n*   **Customer:**\n    *   Attributes: customerId, name, address, email.\n    *   Methods: placeOrder, updateDetails.\n    *   Relationship: One-to-many with Order (Customer can place many Orders).\n\n*   **Payment:**\n    *   Attributes: paymentId, paymentDate, paymentMethod, amount.\n    *   Methods: processPayment.\n    *   Relationship: One-to-one with Order (each Order has one Payment).\n\n*   **Relationships:**\n    *   Association: Customer places Order.\n    *   Aggregation/Composition: Order contains Products. Order requires Payment.",
        "output": "classDiagram\n  class Product{\n    +String productId\n    +String name\n    +String description\n    +float price\n  }\n\n  class Order{\n    +String orderId\n    +String orderDate\n    +float orderTotal\n    +addProduct(Product)\n    +removeProduct(Product)\n    +calculateTotal()\n  }\n\n  class Customer{\n    +String customerId\n    +String name\n    +String address\n    +String email\n    +placeOrder(Order)\n    +updateDetails()\n  }\n\n  class Payment{\n    +String paymentId\n    +String paymentDate\n    +String paymentMethod\n    +float amount\n    +processPayment()\n  }\n\n  Customer \"1\" -- \"*\" Order : places\n  Order \"1\" *-- \"*\" Product : contains\n  Order \"1\" -- \"1\" Payment : requires\n  Order \"1\" -- \"1\" Customer : belongs to"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Create a class diagram for a ride sharing app with Driver, Rider, Vehicle, and Trip classes.",
        "planning": "**Classes:**\n\n*   **Driver:** Attributes (driver ID, name, availability, rating). Operations (acceptTrip(), completeTrip()).\n*   **Rider:** Attributes (rider ID, name, payment info). Operations (requestRide(), cancelRide()).\n*   **Vehicle:** Attributes (vehicle ID, type, license plate, location).\n*   **Trip:** Attributes (trip ID, start location, end location, fare, status). Operations (calculateFare(), startTrip(), endTrip()).\n\n**Relationships:**\n\n*   Driver *-- 1 Vehicle: \"operates\"\n*   Driver 1 -- * Trip: \"completes\"\n*   Rider 1 -- * Trip: \"requests\"\n*   Trip 1 -- 1 Driver: \"assigned to\"\n*   Trip 1 -- 1 Rider: \"contains\"\n*   Vehicle 1 -- * Trip: \"used in\"\n\n**Interactions:**\n\n*   Rider requests a ride.\n*   The system finds an available driver (and vehicle).\n*   Driver accepts the trip.\n*   Trip starts, progresses, and ends.\n*   Fare is calculated.\n*   Driver completes the trip.",
        "output": "classDiagram\n    class Driver{\n        +String driverID\n        +String name\n        +String availability\n        +double rating\n        +acceptTrip()\n        +completeTrip()\n    }\n\n    class Rider{\n        +String riderID\n        +String name\n        +String paymentInfo\n        +requestRide()\n        +cancelRide()\n    }\n\n    class Vehicle{\n        +String vehicleID\n        +String type\n        +String licensePlate\n        +String location\n    }\n\n    class Trip{\n        +String tripID\n        +String startLocation\n        +String endLocation\n        +double fare\n        +String status\n        +calculateFare()\n        +startTrip()\n        +endTrip()\n    }\n\n    Driver \"1\" -- \"1\" Vehicle : operates\n    Driver \"1\" -- \"*\" Trip : completes\n    Rider \"1\" -- \"*\" Trip : requests\n    Trip \"1\" -- \"1\" Driver : assigned to\n    Trip \"1\" -- \"1\" Rider : contains\n    Vehicle \"1\" -- \"*\" Trip : used in"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Generate a class diagram for a basic Banking system including Account, Customer, Transaction, and Branch classes.",
        "planning": "*   **Classes:** Account, Customer, Transaction, Branch\n*   **Account:**\n    *   Attributes: account number, balance, account type\n    *   Relationships: Belongs to Customer, has Transactions\n*   **Customer:**\n    *   Attributes: customer ID, name, address, contact details\n    *   Relationships: Owns Accounts\n*   **Transaction:**\n    *   Attributes: transaction ID, date, type, amount\n    *   Relationships:  Associated with Account\n*   **Branch:**\n    *   Attributes: branch ID, name, address\n    *   Relationships: Manages Accounts (indirectly), may have Customers associated for service.\n*   **Relationships/Interactions:**\n    *   Customer *owns* Account (one-to-many)\n    *   Account *has* Transaction (one-to-many)\n    *   Account *is managed by* Branch (many-to-one)",
        "output": "classDiagram\n    class Account{\n        +String accountNumber\n        +BigDecimal balance\n        +String accountType\n    }\n    class Customer{\n        +String customerID\n        +String name\n        +String address\n        +String contactDetails\n    }\n    class Transaction{\n        +String transactionID\n        +Date date\n        +String type\n        +BigDecimal amount\n    }\n    class Branch{\n        +String branchID\n        +String name\n        +String address\n    }\n\n    Customer \"1\" -- \"1..*\" Account : owns\n    Account \"1\" -- \"1..*\" Transaction : has\n    Account \"*\" -- \"1\" Branch : managed by\n    Account \"*\" -- \"1\" Customer : belongs to"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Design a class diagram for a Library Management system that includes Book, Member, Librarian, and Loan classes.",
        "planning": "**Classes:**\n\n*   **Book:**\n    *   Attributes: Title, Author, ISBN, Publication Date, Status (Available, Loaned, Reserved).\n    *   Interactions: Related to Loan (one book can be on many loans over time), Member (can be reserved by a member).\n\n*   **Member:**\n    *   Attributes: Member ID, Name, Address, Contact Info.\n    *   Interactions: Related to Loan (one member can have many loans), Book (can reserve books).\n\n*   **Librarian:**\n    *   Attributes: Librarian ID, Name, Staff ID.\n    *   Interactions: Manages Loans (creates, updates, and closes loans), manages Book (adds, updates, and removes books), and manages members (adds, updates, and removes members).\n\n*   **Loan:**\n    *   Attributes: Loan ID, Loan Date, Due Date, Return Date, Loan Status.\n    *   Interactions: Connects Book and Member (indicates which book is loaned to which member), managed by Librarian.\n\n**Relationships:**\n\n*   **Association:** Member borrows Book (one-to-many - one member can borrow many books).\n*   **Association:** Book is loaned on Loan (one-to-many - one book can be present in many loans)\n*   **Association:** Loan belongs to Member (one-to-one or one-to-many - One loan is for a specific member).\n*   **Association:** Librarian manages Book (one-to-many - one librarian can manage many books).\n*   **Association:** Librarian manages Loan (one-to-many - one librarian can manage many loans).\n*   **Association:** Librarian manages Member (one-to-many - one librarian can manage many members).",
        "output": "classDiagram\n    class Book{\n        Title\n        Author\n        ISBN\n        Publication_Date\n        Status\n    }\n    class Member{\n        Member_ID\n        Name\n        Address\n        Contact_Info\n    }\n    class Librarian{\n        Librarian_ID\n        Name\n        Staff_ID\n    }\n    class Loan{\n        Loan_ID\n        Loan_Date\n        Due_Date\n        Return_Date\n        Loan_Status\n    }\n\n    Member --> \"borrows\" Book : 1..* \n    Book --> \"is loaned on\" Loan : 1..*\n    Loan --> \"belongs to\" Member : 1\n    Librarian --> \"manages\" Book : 1..*\n    Librarian --> \"manages\" Loan : 1..*\n    Librarian --> \"manages\" Member : 1..*"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Generate a class diagram for a simplified Chat application with classes for User, ChatRoom, Message, and Moderator.",
        "planning": "*   **User:**\n    *   Attributes: userId, userName\n    *   Operations: sendMessage(), joinChatRoom(), leaveChatRoom()\n*   **ChatRoom:**\n    *   Attributes: chatRoomId, chatRoomName\n    *   Operations: addMessage(), addUser(), removeUser()\n*   **Message:**\n    *   Attributes: messageId, messageText, timestamp\n    *   Operations:  (None, mostly data container)\n*   **Moderator:**\n    *   Attributes: moderatorId (inherits from User or separate)\n    *   Operations: removeMessage(), muteUser() (or banUser())\n\n**Relationships/Interactions:**\n\n*   User *--* ChatRoom:  User joins and leaves ChatRoom (Many-to-many, use association class maybe membership with roles)\n*   User *--* Message: User sends Message (One-to-many, unidirectional)\n*   ChatRoom *--* Message: ChatRoom contains Message (One-to-many, unidirectional)\n*   Moderator *--* ChatRoom:  Moderator moderates ChatRoom (One-to-many, unidirectional, or inheritance from User, role in membership)\n*   Moderator *--* User: Moderator acts on User (association or operations directly affecting User)",
        "output": "classDiagram\n    class User{\n        +String userId\n        +String userName\n        +sendMessage(messageText)\n        +joinChatRoom(chatRoomId)\n        +leaveChatRoom(chatRoomId)\n    }\n    class ChatRoom{\n        +String chatRoomId\n        +String chatRoomName\n        +addMessage(messageId)\n        +addUser(userId)\n        +removeUser(userId)\n    }\n    class Message{\n        +String messageId\n        +String messageText\n        +String timestamp\n    }\n    class Moderator{\n        +String moderatorId\n        +removeMessage(messageId)\n        +muteUser(userId)\n    }\n\n    User --> \"1..*\" Message : sends\n    ChatRoom --> \"1..*\" Message : contains\n    User \"*\" -- \"*\" ChatRoom : Membership\n    Moderator --|> User : inherits\n    Moderator \"1\" -- \"1..*\" ChatRoom : moderates\n    Moderator --> User : acts on"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Provide a class diagram for an Academic Management system with Student, Course, Instructor, and Enrollment classes.",
        "planning": "**Classes:**\n\n*   **Student:** Attributes (studentID, name, major). Methods (enrollInCourse(), viewGrades()).\n*   **Course:** Attributes (courseID, courseName, credits). Methods (addStudent(), assignInstructor()).\n*   **Instructor:** Attributes (instructorID, name, department). Methods (teachCourse(), assignGrade()).\n*   **Enrollment:** Attributes (enrollmentID, grade). Methods (recordGrade()).\n\n**Relationships/Interactions:**\n\n*   **Student - Enrollment:** One-to-many (One student can have multiple enrollments).\n*   **Course - Enrollment:** One-to-many (One course can have multiple enrollments).\n*   **Student - Course:** Many-to-many (A student can enroll in many courses, and a course can have many students).  Represented through the Enrollment class.\n*   **Course - Instructor:** One-to-many (One course has one instructor, but an instructor can teach many courses).\n*   **Instructor - Course:** Many-to-many(Implemented by instructorID in Course)",
        "output": "classDiagram\n    class Student{\n        +String studentID\n        +String name\n        +String major\n        +enrollInCourse()\n        +viewGrades()\n    }\n\n    class Course{\n        +String courseID\n        +String courseName\n        +int credits\n        +addStudent()\n        +assignInstructor()\n    }\n\n    class Instructor{\n        +String instructorID\n        +String name\n        +String department\n        +teachCourse()\n        +assignGrade()\n    }\n\n    class Enrollment{\n        +String enrollmentID\n        +String grade\n        +recordGrade()\n    }\n\n    Student \"1\" -- \"*\" Enrollment : enrolls in\n    Course \"1\" -- \"*\" Enrollment : has\n    Course \"1\" -- \"1\" Instructor : teaches"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Create a class diagram for a Hospital Management system featuring Patient, Doctor, Appointment, and MedicalRecord classes.",
        "planning": "*   **Classes:** Patient, Doctor, Appointment, MedicalRecord.\n*   **Patient:** Attributes: patientID, name, address, phone number, date of birth.\n*   **Doctor:** Attributes: doctorID, name, specialization, contact number.\n*   **Appointment:** Attributes: appointmentID, date, time, reason.\n*   **MedicalRecord:** Attributes: recordID, diagnosis, treatment, prescriptions, date.\n*   **Relationships:**\n    *   Patient *has* MedicalRecord (One-to-Many: A patient can have multiple medical records).\n    *   Patient *makes* Appointment (One-to-Many: A patient can make multiple appointments).\n    *   Doctor *handles* Appointment (One-to-Many: A doctor can handle multiple appointments).\n    *   Appointment *relates to* Patient (One-to-One or Many-to-One from Appointment perspective).\n    *   Appointment *relates to* Doctor (One-to-One or Many-to-One from Appointment perspective).\n    *   MedicalRecord *relates to* Appointment (One-to-One or One-to-Many from MedicalRecord perspective. An appointment generates a medical record.).",
        "output": "classDiagram\n    class Patient{\n        +String patientID\n        +String name\n        +String address\n        +String phoneNumber\n        +String dateOfBirth\n    }\n    class Doctor{\n        +String doctorID\n        +String name\n        +String specialization\n        +String contactNumber\n    }\n    class Appointment{\n        +String appointmentID\n        +String date\n        +String time\n        +String reason\n    }\n    class MedicalRecord{\n        +String recordID\n        +String diagnosis\n        +String treatment\n        +String prescriptions\n        +String date\n    }\n\n    Patient \"1\" -- \"0..*\" MedicalRecord : has\n    Patient \"1\" -- \"0..*\" Appointment : makes\n    Doctor \"1\" -- \"0..*\" Appointment : handles\n    Appointment --> Patient : relates to\n    Appointment --> Doctor : relates to\n    MedicalRecord --> Appointment : relates to\n\n    note for Patient \"Patient Details\"\n    note for Doctor \"Doctor Details\"\n    note for Appointment \"Appointment Details\"\n    note for MedicalRecord \"Medical Record Details\""
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Generate a class diagram for a Social Media platform with classes for User, Post, Comment, and Like.",
        "planning": "*   **Classes:** User, Post, Comment, Like\n\n*   **User:**\n    *   Attributes: userId, username, password, email, profilePicture, etc.\n    *   Relationships:\n        *   Creates Posts (1 to many)\n        *   Writes Comments (1 to many)\n        *   Gives Likes (1 to many)\n        *   Follows other Users (many to many, self-referencing)\n\n*   **Post:**\n    *   Attributes: postId, content, timestamp, etc.\n    *   Relationships:\n        *   Belongs to a User (1 to 1)\n        *   Has Comments (1 to many)\n        *   Has Likes (1 to many)\n\n*   **Comment:**\n    *   Attributes: commentId, content, timestamp, etc.\n    *   Relationships:\n        *   Belongs to a User (1 to 1)\n        *   Belongs to a Post (1 to 1)\n\n*   **Like:**\n    *   Attributes: likeId, timestamp, etc.\n    *   Relationships:\n        *   Belongs to a User (1 to 1)\n        *   Belongs to a Post (1 to 1)",
        "output": "classDiagram\n    class User{\n        +String userId\n        +String username\n        +String password\n        +String email\n        +String profilePicture\n    }\n    class Post{\n        +String postId\n        +String content\n        +DateTime timestamp\n    }\n    class Comment{\n        +String commentId\n        +String content\n        +DateTime timestamp\n    }\n    class Like{\n        +String likeId\n        +DateTime timestamp\n    }\n\n    User \"1\" -- \"1..*\" Post : Creates\n    User \"1\" -- \"1..*\" Comment : Writes\n    User \"1\" -- \"1..*\" Like : Gives\n    User \"*\" -- \"*\" User : Follows\n\n    Post \"1\" -- \"1\" User : Belongs to\n    Post \"1\" -- \"1..*\" Comment : Has\n    Post \"1\" -- \"1..*\" Like : Has\n\n    Comment \"1\" -- \"1\" User : Belongs to\n    Comment \"1\" -- \"1\" Post : Belongs to\n\n    Like \"1\" -- \"1\" User : Belongs to\n    Like \"1\" -- \"1\" Post : Belongs to"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Design a class diagram for an Inventory Management system including Product, Supplier, Inventory, and PurchaseOrder classes.",
        "planning": "*   **Product:**\n    *   Attributes: `productID`, `name`, `description`, `price`.\n    *   Interaction: Associated with `Inventory` (specifies the product being inventoried) and `PurchaseOrder` (specifies the product being ordered).\n\n*   **Supplier:**\n    *   Attributes: `supplierID`, `name`, `contactInfo`.\n    *   Interaction: Associated with `PurchaseOrder` (identifies the supplier of the order).\n\n*   **Inventory:**\n    *   Attributes: `inventoryID`, `quantity`, `reorderLevel`.\n    *   Interaction: Associated with `Product` (tracks inventory of a specific product).\n\n*   **PurchaseOrder:**\n    *   Attributes: `orderID`, `orderDate`, `quantity`, `totalAmount`.\n    *   Interaction: Associated with `Supplier` (placed with a supplier), and `Product` (contains products).",
        "output": "classDiagram\n    class Product {\n        +String productID\n        +String name\n        +String description\n        +double price\n    }\n\n    class Supplier {\n        +String supplierID\n        +String name\n        +String contactInfo\n    }\n\n    class Inventory {\n        +String inventoryID\n        +int quantity\n        +int reorderLevel\n    }\n\n    class PurchaseOrder {\n        +String orderID\n        +String orderDate\n        +int quantity\n        +double totalAmount\n    }\n\n    Product \"1\" -- \"1\" Inventory : tracks\n    Product \"1\" -- \"*\" PurchaseOrder : contains\n    Supplier \"1\" -- \"*\" PurchaseOrder : placed with\n\n    note for Product \"Specifies product details\"\n    note for Supplier \"Provides supplier information\"\n    note for Inventory \"Manages product stock levels\"\n    note for PurchaseOrder \"Records order details\""
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Provide a class diagram for an Online Food Delivery application with Restaurant, Menu, Order, and DeliveryPerson classes.",
        "planning": "*   **Classes:** Restaurant, Menu, Order, DeliveryPerson\n*   **Restaurant:**\n    *   Attributes: restaurantID, name, address, cuisine\n    *   Relationships:\n        *   Contains (1-to-many) Menu items\n        *   Has (1-to-many) Orders\n*   **Menu:**\n    *   Attributes: itemID, name, description, price, category\n    *   Relationships:\n        *   Belongs to (1) Restaurant\n*   **Order:**\n    *   Attributes: orderID, customerName, orderDate, deliveryAddress, totalAmount, orderStatus\n    *   Relationships:\n        *   Belongs to (1) Restaurant\n        *   Has (many) Menu items (Order Details - association class with quantity)\n        *   Assigned to (1) DeliveryPerson\n*   **DeliveryPerson:**\n    *   Attributes: deliveryPersonID, name, vehicleType, availability\n    *   Relationships:\n        *   Handles (many) Orders\n*   **Associations/Relationships:**\n    *   Composition: Restaurant-Menu (Menu is part of the Restaurant)\n    *   Aggregation/Association: Restaurant-Order (Restaurant has Orders)\n    *   Association with attributes: Order-Menu (through an \"OrderItem\" or \"OrderDetail\" association class)\n    *   Association: Order-DeliveryPerson (Order is assigned to a DeliveryPerson)",
        "output": "classDiagram\n    class Restaurant{\n        +String restaurantID\n        +String name\n        +String address\n        +String cuisine\n    }\n    class Menu{\n        +String itemID\n        +String name\n        +String description\n        +double price\n        +String category\n    }\n    class Order{\n        +String orderID\n        +String customerName\n        +String orderDate\n        +String deliveryAddress\n        +double totalAmount\n        +String orderStatus\n    }\n    class DeliveryPerson{\n        +String deliveryPersonID\n        +String name\n        +String vehicleType\n        +bool availability\n    }\n    class OrderDetail{\n        +int quantity\n    }\n\n    Restaurant *-- Menu : contains\n    Restaurant o-- Order : has\n    Order *-- DeliveryPerson : assigned to\n    Order *-- OrderDetail : contains\n    Menu <--> OrderDetail : item details\n    Restaurant \"1\" -- \"1\" Menu : belongs to"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Create a class diagram for a Task Management system featuring Task, Project, User, and Comment classes.",
        "planning": "*   **Classes:** Task, Project, User, Comment\n\n*   **Task:**\n    *   Attributes: taskId, name, description, dueDate, status (e.g., \"To Do\", \"In Progress\", \"Completed\")\n    *   Relationships: Belongs to one Project, assigned to one User, can have multiple Comments\n\n*   **Project:**\n    *   Attributes: projectId, name, description, startDate, endDate\n    *   Relationships: Contains multiple Tasks, managed by one or more Users\n\n*   **User:**\n    *   Attributes: userId, name, email, password\n    *   Relationships: Assigned to multiple Tasks, manages (or participates in) multiple Projects, creates multiple Comments\n\n*   **Comment:**\n    *   Attributes: commentId, text, timestamp\n    *   Relationships: Belongs to one Task, created by one User\n\n*   **Relationships & Interactions:**\n    *   **Association:** User <-> Project (Many-to-Many - User participates in many projects. A project can have multiple users)\n    *   **Aggregation/Composition:** Project <-> Task (Project *has* many Tasks. if project is deleted, Tasks might be or might not be deleted)\n    *   **Association:** Task <-> User (One-to-One/Many - Task assigned to one User. User assigned to multiple tasks)\n    *   **Association:** Task <-> Comment (One-to-Many - Task has multiple comments, comment belongs to one task)\n    *   **Association:** User <-> Comment (One-to-Many - User creates multiple Comments)",
        "output": "classDiagram\n    class Task{\n        int taskId\n        String name\n        String description\n        String dueDate\n        String status\n    }\n    class Project{\n        int projectId\n        String name\n        String description\n        String startDate\n        String endDate\n    }\n    class User{\n        int userId\n        String name\n        String email\n        String password\n    }\n    class Comment{\n        int commentId\n        String text\n        String timestamp\n    }\n\n    Project \"1\" -- \"1..*\" Task : contains\n    Task \"1\" -- \"1\" User : assigned to\n    Task \"1\" -- \"*\" Comment : has\n    User \"1\" -- \"*\" Project : manages\n    User \"1\" -- \"*\" Comment : creates\n    Task \"1\" -- \"1\" Project : belongs to"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Generate a class diagram for a Content Management System (CMS) that includes Page, User, Article, and Media classes.",
        "planning": "*   **Classes:** Page, User, Article, Media.\n*   **Page:**\n    *   Attributes: `pageID`, `title`, `content`, `publicationDate`, `authorID`.\n    *   Relationships:\n        *   `authorID` (FK to User) \u2013 One Page has one Author (User).\n        *   Contains multiple Articles (Composition or Aggregation, depending on if Article existence depends on Page).\n        *   Contains multiple Media (Aggregation \u2013 Media can exist independently).\n*   **User:**\n    *   Attributes: `userID`, `username`, `password`, `email`, `role`.\n    *   Relationships:\n        *   Authors multiple Pages (One-to-many with Page).\n*   **Article:**\n    *   Attributes: `articleID`, `title`, `body`, `authorID`.\n    *   Relationships:\n        *   `authorID` (FK to User) \u2013 One Article has one Author (User).\n        *   Belongs to one Page (Aggregation).\n        *   May reference multiple Media (Aggregation).\n*   **Media:**\n    *   Attributes: `mediaID`, `filename`, `fileType`, `uploadDate`.\n    *   Relationships:\n        *   Referenced by multiple Pages and Articles (Many-to-many or independent relationship).\n*   **Interactions:**\n    *   User creates/edits Page, Article, and uploads Media.\n    *   Page contains Articles and Media.\n    *   Article references Media.\n    *   User authors Page and Article.",
        "output": "classDiagram\n    class Page{\n        +int pageID\n        +String title\n        +String content\n        +String publicationDate\n        +int authorID\n    }\n\n    class User{\n        +int userID\n        +String username\n        +String password\n        +String email\n        +String role\n    }\n\n    class Article{\n        +int articleID\n        +String title\n        +String body\n        +int authorID\n    }\n\n    class Media{\n        +int mediaID\n        +String filename\n        +String fileType\n        +String uploadDate\n    }\n\n    Page \"1\" -- \"1\" User : author\n    Page \"1\" -- \"*\" Article : contains\n    Page \"1\" -- \"*\" Media : includes\n    Article \"1\" -- \"1\" User : author\n    Article \"1\" -- \"1\" Page : partOf\n    Article \"*\" -- \"*\" Media : references\n\n    note for Page \"authorID is FK to User\"\n    note for Article \"authorID is FK to User\""
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Design a class diagram for a Human Resources system with Employee, Manager, Department, and Payroll classes.",
        "planning": "**Classes & Attributes:**\n\n*   **Employee:** employeeId, name, address, phone, email, hireDate, jobTitle, salary.\n*   **Manager:** (inherits from Employee) + departmentManaged.\n*   **Department:** departmentId, departmentName, location.\n*   **Payroll:** payrollId, payPeriodStart, payPeriodEnd, paymentDate, netPay, grossPay.\n\n**Relationships:**\n\n*   **Employee--Department:** Employee *works in* one Department. Department *has* many Employees. (One-to-Many)\n*   **Manager--Department:** Manager *manages* one Department. Department *is managed by* one Manager. (One-to-One)\n*   **Employee--Payroll:** Employee *receives* many Payroll records. Payroll *belongs to* one Employee. (One-to-Many)\n\n**Inheritance:**\n\n*   Manager *is a type of* Employee (Inheritance: Manager inherits from Employee).",
        "output": "classDiagram\n    class Employee {\n        +employeeId\n        +name\n        +address\n        +phone\n        +email\n        +hireDate\n        +jobTitle\n        +salary\n    }\n\n    class Manager extends Employee {\n        +departmentManaged\n    }\n\n    class Department {\n        +departmentId\n        +departmentName\n        +location\n    }\n\n    class Payroll {\n        +payrollId\n        +payPeriodStart\n        +payPeriodEnd\n        +paymentDate\n        +netPay\n        +grossPay\n    }\n\n    Employee \"1\" -- \"1\" Department : works in\n    Department \"1\" -- \"*\" Employee : has\n\n    Manager \"1\" -- \"1\" Department : manages\n\n    Employee \"1\" -- \"*\" Payroll : receives\n    Payroll \"1\" -- \"1\" Employee : belongs to"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Provide a class diagram for a Notification system with Notification, User, Channel, and Preference classes.",
        "planning": "*   **Notification:**\n    *   Attributes: `notificationID`, `message`, `timestamp`, `type` (e.g., email, SMS, push).\n    *   Relationships: Association with `Channel`.\n\n*   **User:**\n    *   Attributes: `userID`, `username`, `email`, `phoneNumber`.\n    *   Relationships: Association with `Notification` (receives), Association with `Preference`.\n\n*   **Channel:**\n    *   Attributes: `channelID`, `channelType` (e.g., EmailChannel, SMSChannel, PushNotificationChannel).\n    *   Relationships: Association with `Notification` (used to send).\n\n*   **Preference:**\n    *   Attributes: `preferenceID`, `notificationType`, `isEnabled`.\n    *   Relationships: Association with `User` (owns).",
        "output": "classDiagram\n    class Notification{\n        +String notificationID\n        +String message\n        +String timestamp\n        +String type\n    }\n    class User{\n        +String userID\n        +String username\n        +String email\n        +String phoneNumber\n    }\n    class Channel{\n        +String channelID\n        +String channelType\n    }\n    class Preference{\n        +String preferenceID\n        +String notificationType\n        +boolean isEnabled\n    }\n\n    Notification --> Channel : sent via\n    User --> Notification : receives\n    User --> Preference : owns"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Generate a class diagram for a file storage application including File, Folder, User, and Permission classes.",
        "planning": "*   **Classes:** File, Folder, User, Permission\n*   **File:**\n    *   Attributes: name, size, creationDate, content (or content pointer)\n    *   Methods: read(), write()\n*   **Folder:**\n    *   Attributes: name, creationDate\n    *   Methods: addFile(File), addFolder(Folder), removeFile(File), removeFolder(Folder)\n    *   Relationship: Contains multiple Files (Aggregation/Composition), Contains multiple Folders (Aggregation/Composition)\n*   **User:**\n    *   Attributes: userID, username, password\n    *   Methods: createFile(Folder, File), createFolder(Folder, Folder), deleteFile(File), deleteFolder(Folder)\n    *   Relationship: Has Permissions (Aggregation/Composition)\n*   **Permission:**\n    *   Attributes: permissionType (e.g., read, write, execute), userID\n    *   Methods: grantPermission(User), revokePermission(User)\n    *   Relationship: Associated with File and Folder\n\n*   **Relationships:**\n    *   Folder *contains* File (Aggregation/Composition).\n    *   Folder *contains* Folder (Aggregation/Composition).\n    *   User *has* Permission (Aggregation/Composition).\n    *   Permission *applies to* File (Association).\n    *   Permission *applies to* Folder (Association).\n    *   User *creates* File(Association).\n    *   User *creates* Folder(Association).",
        "output": "classDiagram\n    class File {\n        String name\n        int size\n        String creationDate\n        String content\n        +read()\n        +write()\n    }\n\n    class Folder {\n        String name\n        String creationDate\n        +addFile(File file)\n        +addFolder(Folder folder)\n        +removeFile(File file)\n        +removeFolder(Folder folder)\n    }\n\n    class User {\n        String userID\n        String username\n        String password\n        +createFile(Folder folder, File file)\n        +createFolder(Folder folder, Folder folder)\n        +deleteFile(File file)\n        +deleteFolder(Folder folder)\n    }\n\n    class Permission {\n        String permissionType\n        String userID\n        +grantPermission(User user)\n        +revokePermission(User user)\n    }\n\n    Folder *--  File : contains\n    Folder *--  Folder : contains\n    User *--  Permission : has\n    Permission --> File : applies to\n    Permission --> Folder : applies to\n    User --> File : creates\n    User --> Folder : creates\n\n    note for File \"File stores data\"\n    note for Folder \"Folder stores files and folders\"\n    note for User \"User accounts\"\n    note for Permission \"Access control\""
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Create a class diagram for an E-learning platform with Course, Student, Instructor, and Quiz classes.",
        "planning": "*   **Classes:** Course, Student, Instructor, Quiz.\n*   **Course Attributes:** courseID, courseName, description, credits.\n*   **Student Attributes:** studentID, name, email, password.\n*   **Instructor Attributes:** instructorID, name, email, password, department.\n*   **Quiz Attributes:** quizID, title, description, totalMarks.\n*   **Course Methods:** addModule(), viewContent().\n*   **Student Methods:** enrollCourse(), viewCourse(), takeQuiz().\n*   **Instructor Methods:** createCourse(), createQuiz(), gradeQuiz().\n*   **Quiz Methods:** addQuestion(), startQuiz(), submitQuiz().\n*   **Relationships:**\n    *   Student *--* * Course (many-to-many): Student enrolls in Courses.\n    *   Instructor 1--* Course (one-to-many): Instructor teaches Courses.\n    *   Course 1--* * Quiz (one-to-many): Course has Quizzes.\n    *   Student *--* * Quiz (many-to-many): Student takes Quizzes.",
        "output": "classDiagram\n    class Course{\n        courseID\n        courseName\n        description\n        credits\n        addModule()\n        viewContent()\n    }\n    class Student{\n        studentID\n        name\n        email\n        password\n        enrollCourse()\n        viewCourse()\n        takeQuiz()\n    }\n    class Instructor{\n        instructorID\n        name\n        email\n        password\n        department\n        createCourse()\n        createQuiz()\n        gradeQuiz()\n    }\n    class Quiz{\n        quizID\n        title\n        description\n        totalMarks\n        addQuestion()\n        startQuiz()\n        submitQuiz()\n    }\n\n    Student \"*\" -- \"*\" Course : enrolls in\n    Instructor \"1\" -- \"*\" Course : teaches\n    Course \"1\" -- \"*\" Quiz : has\n    Student \"*\" -- \"*\" Quiz : takes"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Design a class diagram for a Ticket Booking system with Ticket, Customer, Event, and Payment classes.",
        "planning": "*   **Classes:** Ticket, Customer, Event, Payment\n*   **Ticket:**\n    *   Attributes: Ticket ID, Event (reference to Event), Customer (reference to Customer), Price, Seat Number.\n    *   Methods: `getTicketDetails()`.\n*   **Customer:**\n    *   Attributes: Customer ID, Name, Email, Phone.\n    *   Methods: `bookTicket()`, `makePayment()`.\n*   **Event:**\n    *   Attributes: Event ID, Name, Date, Venue, Available Seats, Ticket Price.\n    *   Methods: `getEventDetails()`, `updateAvailableSeats()`.\n*   **Payment:**\n    *   Attributes: Payment ID, Amount, Payment Date, Payment Method.\n    *   Methods: `processPayment()`.\n*   **Relationships:**\n    *   Customer `books` Ticket (One-to-Many: One customer can book many tickets).\n    *   Ticket `belongs to` Event (One-to-One/Many: One ticket belongs to one event, one event can have many tickets).\n    *   Ticket `has` Payment (One-to-One: One ticket has one payment).",
        "output": "classDiagram\n    class Ticket{\n        +String Ticket_ID\n        +String Seat_Number\n        +BigDecimal Price\n        +getTicketDetails()\n    }\n    class Customer{\n        +String Customer_ID\n        +String Name\n        +String Email\n        +String Phone\n        +bookTicket()\n        +makePayment()\n    }\n    class Event{\n        +String Event_ID\n        +String Name\n        +String Date\n        +String Venue\n        +int Available_Seats\n        +BigDecimal Ticket_Price\n        +getEventDetails()\n        +updateAvailableSeats()\n    }\n    class Payment{\n        +String Payment_ID\n        +BigDecimal Amount\n        +String Payment_Date\n        +String Payment_Method\n        +processPayment()\n    }\n\n    Customer \"1\" -- \"*\" Ticket : books\n    Ticket \"1\" -- \"1\" Payment : has\n    Ticket \"1\" -- \"1\" Event : belongs to\n\n    Ticket --|> Customer : Customer\n    Ticket --|> Event : Event"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Generate a class diagram for a Scheduling system featuring Appointment, Calendar, User, and Reminder classes.",
        "planning": "*   **Classes:** Appointment, Calendar, User, Reminder\n*   **Relationships:**\n    *   **User - Calendar:** User *owns/creates* Calendar (Aggregation/Composition - likely composition as the calendar is tightly bound to the user).\n    *   **Calendar - Appointment:** Calendar *has many* Appointments (Aggregation/Composition).\n    *   **Appointment - User:** Appointment *belongs to* User (Association \u2013 who created/owns the appointment, or many-to-many if multiple attendees).\n    *   **Appointment - Reminder:** Appointment *has* Reminder(s) (Aggregation/Composition).\n*   **Attributes (Examples):**\n    *   **User:** userId, username, password, email\n    *   **Calendar:** calendarId, name\n    *   **Appointment:** appointmentId, title, startTime, endTime, location, description\n    *   **Reminder:** reminderId, timeBefore, method (e.g., email, SMS)\n*   **Operations (Examples):**\n    *   **User:** createUser, login, viewCalendar\n    *   **Calendar:** addAppointment, removeAppointment, viewAppointments\n    *   **Appointment:** reschedule, cancel, edit\n    *   **Reminder:** sendReminder\n*   **Interactions:**\n    *   User creates Appointment, which is added to a Calendar.\n    *   Appointment triggers Reminder at specified time, sending notification to User.\n    *   User views Calendar to see Appointments.\n*   **Cardinality:** Indicate one-to-many relationships where applicable (e.g., one User to many Appointments via Calendar).",
        "output": "classDiagram\n  class User{\n    +String userId\n    +String username\n    +String password\n    +String email\n    +createUser()\n    +login()\n    +viewCalendar()\n  }\n\n  class Calendar{\n    +String calendarId\n    +String name\n    +addAppointment(Appointment)\n    +removeAppointment(Appointment)\n    +viewAppointments()\n  }\n\n  class Appointment{\n    +String appointmentId\n    +String title\n    +String startTime\n    +String endTime\n    +String location\n    +String description\n    +reschedule()\n    +cancel()\n    +edit()\n  }\n\n  class Reminder{\n    +String reminderId\n    +String timeBefore\n    +String method\n    +sendReminder()\n  }\n\n  User *--  Calendar : owns/creates\n  Calendar --* Appointment : has many\n  Appointment --> User : belongs to\n  Appointment --o Reminder : has\n\n  note for User \"Stores user information\"\n  note for Calendar \"Manages appointments\"\n  note for Appointment \"Represents a scheduled event\"\n  note for Reminder \"Sends notifications for appointments\""
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Provide a class diagram for a Digital Wallet system with Wallet, User, Transaction, and Merchant classes.",
        "planning": "*   **Wallet:**\n    *   Attributes: walletId, balance.\n    *   Methods: deposit(), withdraw(), getBalance().\n\n*   **User:**\n    *   Attributes: userId, name, email.\n    *   Methods: register(), login(), addWallet().\n    *   Association: Has one or more Wallets.\n\n*   **Transaction:**\n    *   Attributes: transactionId, amount, timestamp, type (e.g., debit, credit).\n    *   Methods: processTransaction().\n    *   Association: Associated with one Wallet (source) and potentially one Wallet or Merchant (destination).\n\n*   **Merchant:**\n    *   Attributes: merchantId, name.\n    *   Methods: processPayment(), refund().\n    *   Association: Receives Transactions.\n\n*   **Relationships:**\n    *   User 1--* Wallet: User *owns* one or more Wallets.\n    *   Wallet 1--* Transaction: Wallet is the *source* and/or *destination* of one or more Transactions.\n    *   Merchant 1--* Transaction: Merchant *receives* one or more Transactions.\n    *   Aggregation (or composition) of Transaction to Wallet.",
        "output": "classDiagram\n    class Wallet{\n        +String walletId\n        +BigDecimal balance\n        +deposit(amount)\n        +withdraw(amount)\n        +getBalance()\n    }\n    class User{\n        +String userId\n        +String name\n        +String email\n        +register()\n        +login()\n        +addWallet()\n    }\n    class Transaction{\n        +String transactionId\n        +BigDecimal amount\n        +String timestamp\n        +String type\n        +processTransaction()\n    }\n    class Merchant{\n        +String merchantId\n        +String name\n        +processPayment()\n        +refund()\n    }\n\n    User \"1\" -- \"*\" Wallet : owns\n    Wallet \"1\" -- \"*\" Transaction : source\n    Merchant \"1\" -- \"*\" Transaction : receives"
    },
    {
        "diagram_type": "classDiagram",
        "prompt": "Create a class diagram for a Recommendation system that includes User, Item, Rating, and Recommendation classes.",
        "planning": "*   **User:** Attributes (userId, profileInfo), Methods (rateItem(), viewRecommendations()).\n*   **Item:** Attributes (itemId, itemDetails), Methods (getAverageRating()).\n*   **Rating:** Attributes (userId, itemId, ratingValue, timestamp), Relationship (User 1-to-many Rating, Item 1-to-many Rating).\n*   **Recommendation:** Attributes (userId, itemId, score), Relationship (User 1-to-many Recommendation, Item 1-to-many Recommendation).\n*   **Interaction:** User creates Rating for Item. Recommendation System generates Recommendation for User based on Ratings and Item attributes. User views Recommendations. Item's average rating is calculated from Ratings.",
        "output": "classDiagram\n    class User{\n        +String userId\n        +String profileInfo\n        +rateItem()\n        +viewRecommendations()\n    }\n    class Item{\n        +String itemId\n        +String itemDetails\n        +getAverageRating()\n    }\n    class Rating{\n        +String userId\n        +String itemId\n        +int ratingValue\n        +String timestamp\n    }\n    class Recommendation{\n        +String userId\n        +String itemId\n        +double score\n    }\n\n    User \"1\" -- \"*\" Rating : creates\n    Item \"1\" -- \"*\" Rating : receives\n    User \"1\" -- \"*\" Recommendation : receives\n    Item \"1\" -- \"*\" Recommendation : is for\n\n    note for User \"User profile and actions\"\n    note for Item \"Item details and rating\"\n    note for Rating \"User rating for an item\"\n    note for Recommendation \"Item recommended to a user\""
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Design an ER diagram for a university registration system that includes entities like Students, Courses, and Enrollments.",
        "planning": "*   **Entities:**\n    *   **Students:** Attributes: StudentID (PK), Name, Major, Address, DateOfBirth\n    *   **Courses:** Attributes: CourseID (PK), CourseName, Credits, Department\n    *   **Enrollments:** Attributes: StudentID (FK), CourseID (FK), EnrollmentDate, Grade\n\n*   **Relationships:**\n    *   **Students ENROLL in Courses:** Many-to-Many relationship represented by the Enrollments entity. Each student can enroll in multiple courses, and each course can have multiple students enrolled.\n    *   Enrollments links Students and Courses together, also holding enrollment-specific data.\n\n*   **Keys:**\n    *   StudentID is the Primary Key (PK) for Students.\n    *   CourseID is the PK for Courses.\n    *   StudentID and CourseID together form a composite PK for Enrollments.\n\n*   **Cardinality:**\n    *   One Student can enroll in Zero or Many Courses.\n    *   One Course can be enrolled in by Zero or Many Students.",
        "output": "```mermaid\nerDiagram\n    Student ||--o{ Enrollment : enrolls\n    Course ||--o{ Enrollment : is_part_of\n\n    Student {\n        string StudentID PK\n        string Name\n        string Major\n        string Address\n        string DateOfBirth\n    }\n\n    Course {\n        string CourseID PK\n        string CourseName\n        int Credits\n        string Department\n    }\n\n    Enrollment {\n        string StudentID FK\n        string CourseID FK\n        string EnrollmentDate\n        string Grade\n    }\n```"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Generate an ER diagram for a library management system with entities such as Books, Authors, Categories, and Borrowers.",
        "planning": "*   **Entities:** Books, Authors, Categories, Borrowers.\n*   **Relationships:**\n    *   Books are written by Authors (one-to-many: one author can write multiple books).\n    *   Books belong to Categories (many-to-many: a book can belong to multiple categories, and a category can have multiple books).\n    *   Books are borrowed by Borrowers (many-to-many: a book can be borrowed by multiple borrowers over time, and a borrower can borrow multiple books).  This typically requires an intermediary entity, Borrowing.\n*   **Attributes:**\n    *   **Books:** BookID (PK), Title, ISBN, PublicationYear.\n    *   **Authors:** AuthorID (PK), AuthorName.\n    *   **Categories:** CategoryID (PK), CategoryName.\n    *   **Borrowers:** BorrowerID (PK), BorrowerName, Address, Phone.\n    *   **Borrowing:** BorrowingID(PK), BookID(FK), BorrowerID(FK), BorrowDate, DueDate, ReturnDate.\n*   **Cardinality:** Define clearly one-to-many, many-to-many relationships and the minimum and maximum occurrences.",
        "output": "erDiagram\n    Books ||--o{ Authors : written_by\n    Books }o--o{ Categories : belongs_to\n    Borrowing ||--o{ Books : borrows\n    Borrowing ||--o{ Borrowers : borrowed_by\n\n    Books {\n        int BookID PK\n        string Title\n        string ISBN\n        int PublicationYear\n    }\n\n    Authors {\n        int AuthorID PK\n        string AuthorName\n    }\n\n    Categories {\n        int CategoryID PK\n        string CategoryName\n    }\n\n    Borrowers {\n        int BorrowerID PK\n        string BorrowerName\n        string Address\n        string Phone\n    }\n\n    Borrowing {\n        int BorrowingID PK\n        int BookID FK\n        int BorrowerID FK\n        string BorrowDate\n        string DueDate\n        string ReturnDate\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Create an ER diagram for a simple e-commerce system covering Customers, Orders, Products, and Reviews.",
        "planning": "*   **Customers:**\n    *   Attributes: CustomerID (PK), Name, Address, Email, Phone.\n    *   Relationship to Orders: One-to-many (A customer can place multiple orders).\n    *   Relationship to Reviews: One-to-many (A customer can write multiple reviews).\n*   **Orders:**\n    *   Attributes: OrderID (PK), CustomerID (FK), OrderDate, TotalAmount, ShippingAddress.\n    *   Relationship to Customers: Many-to-one (Many orders belong to one customer).\n    *   Relationship to Products: Many-to-many (An order can contain many products, and a product can be in many orders) using an Order_Items associative entity.\n*   **Products:**\n    *   Attributes: ProductID (PK), Name, Description, Price, Category.\n    *   Relationship to Orders: Many-to-many (A product can be in many orders, and an order can contain many products) using an Order_Items associative entity.\n    *   Relationship to Reviews: One-to-many (A product can have many reviews).\n*   **Reviews:**\n    *   Attributes: ReviewID (PK), ProductID (FK), CustomerID (FK), Rating, Comment.\n    *   Relationship to Customers: Many-to-one (Many reviews are written by one customer).\n    *   Relationship to Products: Many-to-one (Many reviews are for one product).\n*   **Order_Items (Associative Entity):**\n    *   Attributes: OrderID (FK), ProductID (FK), Quantity, Price.\n    *   Resolves the many-to-many relationship between Orders and Products.",
        "output": "erDiagram\n    CUSTOMER ||--o{ ORDER : places\n    CUSTOMER ||--o{ REVIEW : writes\n    PRODUCT ||--o{ REVIEW : receives\n    ORDER ||--o{ ORDER_ITEMS : includes\n    PRODUCT ||--o{ ORDER_ITEMS : is_included_in\n\n    CUSTOMER {\n        int CustomerID PK\n        string Name\n        string Address\n        string Email\n        string Phone\n    }\n\n    ORDER {\n        int OrderID PK\n        int CustomerID FK\n        string OrderDate\n        float TotalAmount\n        string ShippingAddress\n    }\n\n    PRODUCT {\n        int ProductID PK\n        string Name\n        string Description\n        float Price\n        string Category\n    }\n\n    REVIEW {\n        int ReviewID PK\n        int ProductID FK\n        int CustomerID FK\n        int Rating\n        string Comment\n    }\n\n    ORDER_ITEMS {\n        int OrderID FK\n        int ProductID FK\n        int Quantity\n        float Price\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Design an ER diagram for a hospital management system that includes Patients, Doctors, Appointments, and Prescriptions.",
        "planning": "*   **Entities:**\n    *   **Patient:** Attributes: PatientID (PK), Name, Address, Phone, DOB, Insurance Info.\n    *   **Doctor:** Attributes: DoctorID (PK), Name, Specialty, Department, Contact Info.\n    *   **Appointment:** Attributes: AppointmentID (PK), Date, Time, Room Number.\n    *   **Prescription:** Attributes: PrescriptionID (PK), Medication Name, Dosage, Frequency, Start Date, End Date.\n\n*   **Relationships:**\n    *   **Patient --< Appointment:**  One patient can have many appointments. One appointment belongs to one patient.\n    *   **Doctor --< Appointment:** One doctor can have many appointments. One appointment is with one doctor.\n    *   **Appointment --> Prescription:** One appointment can result in one prescription (or none). One prescription is related to one appointment.\n    *   **Doctor --< Patient:** (Optional) One Doctor can treat many patients. One patient may have multiple doctors (e.g., primary care and specialist).",
        "output": "erDiagram\n    PATIENT ||--o{ APPOINTMENT : schedules\n    PATIENT {\n        int PatientID PK\n        string Name\n        string Address\n        string Phone\n        string DOB\n        string InsuranceInfo\n    }\n\n    DOCTOR ||--o{ APPOINTMENT : has\n    DOCTOR {\n        int DoctorID PK\n        string Name\n        string Specialty\n        string Department\n        string ContactInfo\n    }\n\n    APPOINTMENT ||--o| PRESCRIPTION : generates\n    APPOINTMENT {\n        int AppointmentID PK\n        string Date\n        string Time\n        string RoomNumber\n    }\n\n    PRESCRIPTION {\n        int PrescriptionID PK\n        string MedicationName\n        string Dosage\n        string Frequency\n        string StartDate\n        string EndDate\n    }\n\n    DOCTOR }|..|{ PATIENT : treats"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Generate an ER diagram for a bank account system with entities such as Customers, Accounts, Transactions, and Branches.",
        "planning": "*   **Entities:**\n    *   Customers: Holds customer information.\n    *   Accounts: Holds account details.\n    *   Transactions: Records all transactions.\n    *   Branches: Stores branch information.\n\n*   **Relationships:**\n    *   Customer *owns* Account (One-to-many: One customer can have multiple accounts).\n    *   Account *belongs to* Branch (One-to-many: One account belongs to one branch).\n    *   Account *involved in* Transactions (One-to-many: One account can be involved in multiple transactions as a source or destination).\n\n*   **Attributes (Key Examples):**\n    *   Customers: CustomerID (PK), Name, Address, ContactInfo\n    *   Accounts: AccountNumber (PK), AccountType, Balance, OpenDate\n    *   Transactions: TransactionID (PK), Date, Type, Amount, AccountNumber (FK source), AccountNumber (FK destination)\n    *   Branches: BranchID (PK), BranchName, Location\n\n*   **Key Considerations:**\n    *   Primary Keys (PK) uniquely identify each entity.\n    *   Foreign Keys (FK) establish relationships between entities.\n    *   Transactions can involve two accounts (source and destination).",
        "output": "erDiagram\n    CUSTOMER ||--o{ ACCOUNT : owns\n    ACCOUNT ||--|| BRANCH : belongs_to\n    ACCOUNT ||--o{ TRANSACTION : involved_in_source\n    ACCOUNT ||--o{ TRANSACTION : involved_in_destination\n\n    CUSTOMER {\n        string CustomerID PK\n        string Name\n        string Address\n        string ContactInfo\n    }\n\n    ACCOUNT {\n        string AccountNumber PK\n        string AccountType\n        decimal Balance\n        date OpenDate\n    }\n\n    TRANSACTION {\n        string TransactionID PK\n        date Date\n        string Type\n        decimal Amount\n        string SourceAccountNumber FK\n        string DestinationAccountNumber FK\n    }\n\n    BRANCH {\n        string BranchID PK\n        string BranchName\n        string Location\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Develop an ER diagram for a restaurant ordering system featuring Orders, Menu Items, and Customers.",
        "planning": "**Entities:**\n\n*   **Customer:** Attributes: CustomerID (PK), Name, Address, Phone Number.\n*   **Menu Item:** Attributes: ItemID (PK), Name, Description, Price.\n*   **Order:** Attributes: OrderID (PK), OrderDate, TotalAmount.\n\n**Relationships:**\n\n*   **Customer places Order:** A Customer can place many Orders. An Order is placed by one Customer. (One-to-Many).\n*   **Order contains Menu Item:** An Order can contain many Menu Items. A Menu Item can be in many Orders. (Many-to-Many, resolve with Order_Item associative entity).\n*   **Order_Item (Associative Entity):** Attributes: OrderID (FK), ItemID (FK), Quantity. Represents the quantity of a specific menu item in a specific order. Links Order and Menu Item.",
        "output": "erDiagram\n    CUSTOMER ||--o{ ORDER : places\n    CUSTOMER {\n        int CustomerID PK\n        string Name\n        string Address\n        string PhoneNumber\n    }\n    ORDER ||--o{ ORDER_ITEM : contains\n    ORDER {\n        int OrderID PK\n        string OrderDate\n        float TotalAmount\n    }\n    MENU_ITEM ||--o{ ORDER_ITEM : includes\n    MENU_ITEM {\n        int ItemID PK\n        string Name\n        string Description\n        float Price\n    }\n    ORDER_ITEM {\n        int OrderID FK\n        int ItemID FK\n        int Quantity\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Create an ER diagram for a basic social media platform with entities like Users, Posts, Comments, and Likes.",
        "planning": "*   **Entities:**\n    *   User: Represents a user of the platform.\n    *   Post: Represents a user's created content.\n    *   Comment: Represents a user's response to a post.\n    *   Like: Represents a user's positive reaction to a post or comment.\n\n*   **Relationships:**\n    *   User *creates* Post (One-to-many: One user can create many posts).\n    *   User *writes* Comment (One-to-many: One user can write many comments).\n    *   Post *has* Comment (One-to-many: One post can have many comments).\n    *   User *likes* Post (Many-to-many: Users can like many posts, posts can be liked by many users - resolves to a linking table/entity).\n    *   User *likes* Comment (Many-to-many: Users can like many comments, comments can be liked by many users - resolves to a linking table/entity).\n    *   Comment *belongs to* Post (One-to-many: A comment is only written for one specific post).\n\n*   **Attributes (Examples, include primary keys):**\n    *   User: UserID (PK), Username, Password, Email, RegistrationDate\n    *   Post: PostID (PK), UserID (FK), PostDate, Content\n    *   Comment: CommentID (PK), UserID (FK), PostID (FK), CommentDate, CommentText\n    *   Like (Post): UserID (FK), PostID (FK), LikeDate (Composite PK).\n    *   Like (Comment): UserID (FK), CommentID (FK), LikeDate (Composite PK).",
        "output": "erDiagram\n    User ||--o{ Post : creates\n    User ||--o{ Comment : writes\n    Post ||--o{ Comment : has\n    User }|..|{ PostLike : likes\n    Post ||--o{ PostLike : is liked by\n    User }|..|{ CommentLike : likes\n    Comment ||--o{ CommentLike : is liked by\n    Comment }|..|| Post : belongs to\n\n    User {\n        int UserID PK\n        string Username\n        string Password\n        string Email\n        date RegistrationDate\n    }\n\n    Post {\n        int PostID PK\n        int UserID FK\n        date PostDate\n        string Content\n    }\n\n    Comment {\n        int CommentID PK\n        int UserID FK\n        int PostID FK\n        date CommentDate\n        string CommentText\n    }\n\n    PostLike {\n        int UserID FK\n        int PostID FK\n        date LikeDate PK\n    }\n\n    CommentLike {\n        int UserID FK\n        int CommentID FK\n        date LikeDate PK\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Design an ER diagram for a movie rental service including Movies, Customers, Rentals, and Payments.",
        "planning": "*   **Movies:**\n    *   Attributes: MovieID (PK), Title, Genre, ReleaseDate, RentalPrice\n*   **Customers:**\n    *   Attributes: CustomerID (PK), Name, Address, Phone, RegistrationDate\n*   **Rentals:**\n    *   Attributes: RentalID (PK), CustomerID (FK), MovieID (FK), RentalDate, ReturnDate, DueDate\n    *   Relationship: Relates Customers to Movies through the act of renting.\n*   **Payments:**\n    *   Attributes: PaymentID (PK), RentalID (FK), PaymentDate, PaymentAmount, PaymentMethod\n    *   Relationship: Records payments made for specific rentals.\n*   **Relationships:**\n    *   A Customer can rent many Movies (via Rentals).\n    *   A Movie can be rented by many Customers (via Rentals).\n    *   Each Rental is associated with one Customer and one Movie.\n    *   Each Rental can have one or more Payments.",
        "output": "erDiagram\n    CUSTOMER ||--o{ RENTAL : rents\n    MOVIE ||--o{ RENTAL : is_rented\n    RENTAL ||--|{ PAYMENT : receives\n\n    CUSTOMER {\n        int CustomerID PK\n        string Name\n        string Address\n        string Phone\n        date RegistrationDate\n    }\n\n    MOVIE {\n        int MovieID PK\n        string Title\n        string Genre\n        date ReleaseDate\n        float RentalPrice\n    }\n\n    RENTAL {\n        int RentalID PK\n        int CustomerID FK\n        int MovieID FK\n        date RentalDate\n        date ReturnDate\n        date DueDate\n    }\n\n    PAYMENT {\n        int PaymentID PK\n        int RentalID FK\n        date PaymentDate\n        float PaymentAmount\n        string PaymentMethod\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Generate an ER diagram for a school timetable system that involves entities such as Students, Teachers, Classes, and Courses.",
        "planning": "*   **Entities:**\n    *   **Students:** StudentID (PK), Name, Major\n    *   **Teachers:** TeacherID (PK), Name, Department\n    *   **Classes:** ClassID (PK), Room, Time, Capacity\n    *   **Courses:** CourseID (PK), Name, Credits\n\n*   **Relationships:**\n    *   **Enrollment (Students <-> Classes):** Many-to-Many. A student can enroll in many classes; a class can have many students. Contains attribute: Grade.\n    *   **Teaching (Teachers <-> Classes):** One-to-Many. A teacher can teach many classes; a class is taught by one teacher.\n    *   **Course Offering (Courses <-> Classes):** One-to-Many. A course can have many classes; a class belongs to one course.\n\n*   **Primary Keys (PK):** Uniquely identify each entity instance.\n*   **Foreign Keys (FK):** Establish relationships between entities (e.g., Class includes TeacherID as FK referencing Teachers).",
        "output": "erDiagram\n    STUDENTS ||--o{ CLASSES : enrolls\n    TEACHERS ||--o{ CLASSES : teaches\n    COURSES ||--o{ CLASSES : offers\n\n    STUDENTS {\n        string StudentID PK\n        string Name\n        string Major\n    }\n\n    TEACHERS {\n        string TeacherID PK\n        string Name\n        string Department\n    }\n\n    CLASSES {\n        string ClassID PK\n        string Room\n        string Time\n        int Capacity\n    }\n\n    COURSES {\n        string CourseID PK\n        string Name\n        int Credits\n    }\n\n    CLASSES { \n        string Grade\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Design an ER diagram for a hotel booking system with entities like Guests, Bookings, Rooms, and Services.",
        "planning": "*   **Entities:**\n    *   **Guests:** (GuestID, Name, ContactInfo) - Stores guest information.\n    *   **Rooms:** (RoomID, RoomType, Price, Capacity) - Stores room details.\n    *   **Bookings:** (BookingID, GuestID, RoomID, CheckInDate, CheckOutDate, TotalCost) - Stores booking information.\n    *   **Services:** (ServiceID, ServiceName, Description, Price) - Stores available services (e.g., spa, restaurant).\n\n*   **Relationships:**\n    *   **Guests 1--* Bookings:** One guest can have multiple bookings.\n    *   **Rooms 1--* Bookings:** One room can be booked multiple times (different dates).\n    *   **Bookings *--1 Rooms:** Each booking is for one room.\n    *   **Bookings *--* Services:** Bookings can use multiple services and one service can be used for multiple bookings. (Many-to-many relationship, requiring a linking table BookedServices).\n\n*   **Linking Table (for Bookings and Services):**\n    *   **BookedServices:** (BookingID, ServiceID, Quantity) - Resolves the many-to-many relationship between Bookings and Services, tracking which services are associated with each booking and how many.",
        "output": "erDiagram\n    GUESTS ||--o{ BOOKINGS : places\n    ROOMS ||--o{ BOOKINGS : books\n    BOOKINGS }|--|| ROOMS : is_for\n    BOOKINGS ||--o{ BOOKEDSERVICES : uses\n    SERVICES ||--o{ BOOKEDSERVICES : is_used_in\n    BOOKEDSERVICES }|--|| BOOKINGS : belongs_to\n    BOOKEDSERVICES }|--|| SERVICES : includes\n\n    GUESTS {\n        string GuestID PK\n        string Name\n        string ContactInfo\n    }\n\n    ROOMS {\n        string RoomID PK\n        string RoomType\n        float Price\n        int Capacity\n    }\n\n    BOOKINGS {\n        string BookingID PK\n        string GuestID FK\n        string RoomID FK\n        string CheckInDate\n        string CheckOutDate\n        float TotalCost\n    }\n\n    SERVICES {\n        string ServiceID PK\n        string ServiceName\n        string Description\n        float Price\n    }\n\n    BOOKEDSERVICES {\n        string BookingID FK, PK\n        string ServiceID FK, PK\n        int Quantity\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Create an ER diagram for a project management application featuring entities such as Projects, Tasks, Users, and Teams.",
        "planning": "*   **Entities:** Projects, Tasks, Users, Teams\n*   **Attributes:**\n    *   **Projects:** ProjectID (PK), ProjectName, Description, StartDate, EndDate\n    *   **Tasks:** TaskID (PK), ProjectID (FK), TaskName, Description, StartDate, EndDate, Status, AssignedUserID (FK)\n    *   **Users:** UserID (PK), Username, Email, Password\n    *   **Teams:** TeamID (PK), TeamName\n*   **Relationships:**\n    *   **Project-Task:** One-to-Many (A project can have many tasks)\n    *   **Project-Team:** Many-to-Many (A project can have multiple teams, a team can be in multiple projects) - Requires linking table ProjectTeams with ProjectID(FK), TeamID(FK).\n    *   **User-Task:** One-to-Many (A user can be assigned many tasks, but a task is assigned to one user)\n    *   **User-Team:** Many-to-Many (A user can belong to multiple teams, a team can have multiple users) - Requires linking table UserTeams with UserID(FK), TeamID(FK).",
        "output": "erDiagram\n    PROJECT ||--o{ TASK : has\n    PROJECT ||--o{ PROJECTTEAMS : includes\n    TEAM ||--o{ PROJECTTEAMS : part_of\n    USER ||--o{ TASK : assigned_to\n    USER ||--o{ USERTEAMS : belongs_to\n    TEAM ||--o{ USERTEAMS : has\n\n    PROJECT {\n        int ProjectID PK\n        string ProjectName\n        string Description\n        date StartDate\n        date EndDate\n    }\n\n    TASK {\n        int TaskID PK\n        int ProjectID FK\n        string TaskName\n        string Description\n        date StartDate\n        date EndDate\n        string Status\n        int AssignedUserID FK\n    }\n\n    USER {\n        int UserID PK\n        string Username\n        string Email\n        string Password\n    }\n\n    TEAM {\n        int TeamID PK\n        string TeamName\n    }\n\n    PROJECTTEAMS {\n        int ProjectID FK\n        int TeamID FK\n    }\n\n    USERTEAMS {\n        int UserID FK\n        int TeamID FK\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Generate an ER diagram for a music streaming application that includes Users, Playlists, Songs, and Artists.",
        "planning": "**Entities:**\n\n*   **User:** Stores user information (user ID, username, password, email, etc.)\n*   **Playlist:** Stores playlist information (playlist ID, playlist name, description, creation date, etc.)\n*   **Song:** Stores song information (song ID, title, duration, release date, etc.)\n*   **Artist:** Stores artist information (artist ID, artist name, genre, etc.)\n\n**Relationships:**\n\n*   **User *creates* Playlist:** A user can create many playlists. A playlist is created by one user. (One-to-Many)\n*   **Playlist *contains* Song:** A playlist can contain many songs. A song can be in many playlists. (Many-to-Many) Resolved with a linking table called `Playlist_Song`.\n*   **Song *performed by* Artist:** A song is performed by one artist. An artist can perform many songs. (One-to-Many)\n\n**Attributes (Examples):**\n\n*   **User:** `UserID` (PK), `Username`, `Password`, `Email`, `RegistrationDate`.\n*   **Playlist:** `PlaylistID` (PK), `UserID` (FK), `PlaylistName`, `Description`, `CreationDate`.\n*   **Song:** `SongID` (PK), `ArtistID` (FK), `Title`, `Duration`, `ReleaseDate`.\n*   **Artist:** `ArtistID` (PK), `ArtistName`, `Genre`.\n*   **Playlist_Song:** `PlaylistID` (FK), `SongID` (FK), `AddedDate` (composite PK).\n\n**Interactions:**\n\n*   Users create and manage playlists.\n*   Playlists contain songs.\n*   Songs are performed by artists.\n*   Users listen to songs in playlists or individually.",
        "output": "erDiagram\n    User ||--o{ Playlist : creates\n    User {\n        string UserID PK\n        string Username\n        string Password\n        string Email\n        string RegistrationDate\n    }\n    Playlist ||--|{ Playlist_Song : contains\n    Playlist {\n        string PlaylistID PK\n        string UserID FK\n        string PlaylistName\n        string Description\n        string CreationDate\n    }\n    Song ||--|{ Playlist_Song : in\n    Song ||--o{ Artist : performed_by\n    Song {\n        string SongID PK\n        string ArtistID FK\n        string Title\n        string Duration\n        string ReleaseDate\n    }\n    Artist {\n        string ArtistID PK\n        string ArtistName\n        string Genre\n    }\n    Playlist_Song {\n        string PlaylistID FK\n        string SongID FK\n        string AddedDate PK\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Design an ER diagram for a research publication repository with entities such as Authors, Papers, Conferences, and Citations.",
        "planning": "*   **Entities:**\n    *   **Author:** (AuthorID, Name, Affiliation)\n    *   **Paper:** (PaperID, Title, Abstract, PublicationDate)\n    *   **Conference:** (ConferenceID, Name, Location, Dates)\n    *   **Citation:** (CitationID) - Representing the relationship between papers.\n\n*   **Relationships:**\n\n    *   **Writes:** Author *<->* Paper (Many-to-Many): An author can write multiple papers, and a paper can have multiple authors.\n    *   **Presents:** Paper *<->* Conference (Many-to-One): Many papers can be presented at one conference. A paper can be presented at only one conference.\n    *   **Cites:** Paper *<->* Paper (Many-to-Many): A paper can cite multiple papers, and a paper can be cited by multiple papers. The Citation entity implicitly represents the Cites relationship.\n    *   **Published_in:** Paper *<->* Conference (Many-to-One): Many papers can be published in one conference. A paper can be published in only one conference.\n\n*   **Attributes (within Entities):**\n    *   Underline primary keys (AuthorID, PaperID, ConferenceID, CitationID).\n    *   Include relevant attributes for each entity (e.g., Author's Affiliation, Paper's Abstract, Conference Dates).\n\n*   **Cardinality/Multiplicity:**\n    *   Specify cardinality constraints for each relationship (e.g., one-to-many, many-to-many).\n    *   Consider participation constraints (e.g., is it mandatory for a paper to be presented at a conference?).",
        "output": "erDiagram\n    AUTHOR ||--o{ PAPER : writes\n    PAPER ||--o{ AUTHOR : writes\n\n    PAPER }|--o| CONFERENCE : presents\n\n    PAPER ||--o{ CITATION : cites\n    PAPER ||--o{ CITATION : cited_by\n\n    PAPER }|--o| CONFERENCE : published_in\n\n    AUTHOR {\n        string AuthorID PK\n        string Name\n        string Affiliation\n    }\n\n    PAPER {\n        string PaperID PK\n        string Title\n        string Abstract\n        string PublicationDate\n    }\n\n    CONFERENCE {\n        string ConferenceID PK\n        string Name\n        string Location\n        string Dates\n    }\n\n    CITATION {\n        string CitationID PK\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Create an ER diagram for a car rental system consisting of entities like Cars, Customers, Rentals, and Locations.",
        "planning": "*   **Entities:**\n    *   **Cars:** (CarID, Make, Model, Year, LicensePlate, DailyRate)\n    *   **Customers:** (CustomerID, Name, Address, Phone, Email)\n    *   **Rentals:** (RentalID, RentalDate, ReturnDate, TotalAmount)\n    *   **Locations:** (LocationID, Address, City, State, Zip)\n\n*   **Relationships:**\n    *   **Cars *are located at* Locations:** (Many-to-One relationship; a car is at one location, a location has many cars)\n    *   **Customers *rent* Rentals:** (One-to-Many relationship; a customer can rent many times, a rental is by one customer)\n    *   **Rentals *include* Cars:** (Many-to-Many relationship; a rental can include many cars, a car can be in many rentals. Requires a linking entity: RentalCars (RentalID, CarID, DailyRate))\n    *   **Cars *have a starting location* Locations:** (Many-to-One relationship; a car has an original location, a location has many cars)\n\n*   **Attributes:** Attributes listed in parenthesis above for each entity. Primary keys are underlined (CarID, CustomerID, RentalID, LocationID). Foreign keys will be present in linking entities and as appropriate, e.g. LocationID in Cars.",
        "output": "erDiagram\n    Cars {\n        string CarID PK\n        string Make\n        string Model\n        int Year\n        string LicensePlate\n        float DailyRate\n        string LocationID FK\n    }\n    Customers {\n        string CustomerID PK\n        string Name\n        string Address\n        string Phone\n        string Email\n    }\n    Rentals {\n        string RentalID PK\n        string RentalDate\n        string ReturnDate\n        float TotalAmount\n        string CustomerID FK\n    }\n    Locations {\n        string LocationID PK\n        string Address\n        string City\n        string State\n        string Zip\n    }\n    RentalCars {\n        string RentalID FK\n        string CarID FK\n        float DailyRate\n    }\n\n    Cars }o--|| Locations : \"is located at\"\n    Customers ||--o{ Rentals : \"rent\"\n    Rentals ||--o{ RentalCars : \"includes\"\n    Cars ||--o{ RentalCars : \"is included in\"\n    Cars }o--|| Locations : \"has starting location\""
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Generate an ER diagram for a food delivery system that involves Restaurants, Menus, Orders, and Deliveries.",
        "planning": "*   **Restaurants:**\n    *   Attributes: RestaurantID (PK), Name, Address, Phone number, Cuisine type.\n    *   Interaction: HAS Menus, RECEIVES Orders.\n*   **Menus:**\n    *   Attributes: MenuID (PK), RestaurantID (FK), Item Name, Description, Price.\n    *   Interaction: BELONGS TO a Restaurant, CONTAINED IN Orders.\n*   **Orders:**\n    *   Attributes: OrderID (PK), CustomerID (FK - implied), RestaurantID (FK), Order Date, Total Amount, Delivery Address.\n    *   Interaction: PLACES Orders, CONTAINS Menu Items, REQUIRES Delivery.\n*   **Deliveries:**\n    *   Attributes: DeliveryID (PK), OrderID (FK), Delivery Driver (FK - implied), Delivery Date, Delivery Time, Delivery Status.\n    *   Interaction: RELATED TO an Order, HANDLED BY a Delivery Driver.",
        "output": "erDiagram\n    Restaurant ||--o{ Menu : has\n    Restaurant { \n        int RestaurantID PK\n        string Name\n        string Address\n        string PhoneNumber\n        string CuisineType\n    }\n    Menu { \n        int MenuID PK\n        int RestaurantID FK\n        string ItemName\n        string Description\n        float Price\n    }\n    Order ||--|{ MenuItem : contains\n    Order ||--o{ Delivery : requires\n    Restaurant ||--o{ Order : receives\n    Order {\n        int OrderID PK\n        int CustomerID FK\n        int RestaurantID FK\n        string OrderDate\n        float TotalAmount\n        string DeliveryAddress\n    }\n    Delivery {\n        int DeliveryID PK\n        int OrderID FK\n        int DeliveryDriver FK\n        string DeliveryDate\n        string DeliveryTime\n        string DeliveryStatus\n    }\n    Menu ||--o{ MenuItem : includes\n    MenuItem {\n        int ItemID PK\n        int MenuID FK\n        string ItemName\n        string Description\n        float Price\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Design an ER diagram for an event management system with entities such as Events, Attendees, Venues, and Tickets.",
        "planning": "*   **Entities:**\n    *   **Event:** EventID (PK), EventName, Description, Date, Time, Capacity.\n    *   **Attendee:** AttendeeID (PK), Name, Email, Phone.\n    *   **Venue:** VenueID (PK), VenueName, Address, Capacity.\n    *   **Ticket:** TicketID (PK), Price, TicketType.\n\n*   **Relationships:**\n    *   **Event \"is held at\" Venue:** One-to-Many (One Venue can host multiple Events).\n    *   **Attendee \"attends\" Event:** Many-to-Many (Many Attendees can attend many Events). Resolved with associative entity \"Registration\".\n    *   **Registration:** RegistrationID (PK), EventID (FK), AttendeeID (FK), RegistrationDate. (Many-to-Many between Attendee and Event)\n    *   **Event \"has\" Tickets:** One-to-Many (One Event can have multiple Tickets).\n    *   **Ticket \"is purchased by\" Attendee:** Many-to-Many (Many Attendees can purchase many Tickets). Resolved with associative entity \"Purchase\".\n    *   **Purchase:** PurchaseID (PK), TicketID (FK), AttendeeID (FK), PurchaseDate. (Many-to-Many between Attendee and Ticket)",
        "output": "erDiagram\n    Event ||--o{ Venue : \"is held at\"\n    Event { \n        int EventID PK\n        string EventName\n        string Description\n        date Date\n        time Time\n        int Capacity\n    }\n    Venue { \n        int VenueID PK\n        string VenueName\n        string Address\n        int Capacity\n    }\n    Attendee ||--o{ Registration : \"\"\n    Event ||--o{ Registration : \"\"\n    Attendee { \n        int AttendeeID PK\n        string Name\n        string Email\n        string Phone\n    }\n    Registration { \n        int RegistrationID PK\n        int EventID FK\n        int AttendeeID FK\n        date RegistrationDate\n    }\n    Event ||--o{ Ticket : \"has\"\n    Ticket ||--o{ Purchase : \"\"\n    Attendee ||--o{ Purchase : \"\"\n    Ticket { \n        int TicketID PK\n        float Price\n        string TicketType\n    }\n    Purchase {\n        int PurchaseID PK\n        int TicketID FK\n        int AttendeeID FK\n        date PurchaseDate\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Create an ER diagram for a school library system including Students, Librarians, Books, and Borrowings.",
        "planning": "*   **Entities:**\n    *   **Student:** Attributes: StudentID (PK), Name, Address, Major, Phone\n    *   **Book:** Attributes: BookID (PK), Title, Author, ISBN, PublicationYear\n    *   **Librarian:** Attributes: LibrarianID (PK), Name, EmployeeID, Department\n    *   **Borrowing:** Attributes: BorrowID (PK), BorrowDate, DueDate, ReturnDate\n\n*   **Relationships:**\n    *   **Student borrows Book:** Many-to-many (A student can borrow many books, and a book can be borrowed by many students).  Requires a Borrowing entity to resolve.  Relationship to Borrowing is one-to-many from Student and Book.\n    *   **Librarian manages Borrowing:** One-to-many (A librarian manages many borrowings, but a borrowing is managed by one librarian). Relationship to Borrowing is one-to-many from Librarian.",
        "output": "erDiagram\n    Student ||--o{ Borrowing : borrows\n    Book ||--o{ Borrowing : is_borrowed\n    Librarian ||--o{ Borrowing : manages\n\n    Student {\n        string StudentID PK\n        string Name\n        string Address\n        string Major\n        string Phone\n    }\n\n    Book {\n        string BookID PK\n        string Title\n        string Author\n        string ISBN\n        int PublicationYear\n    }\n\n    Librarian {\n        string LibrarianID PK\n        string Name\n        string EmployeeID\n        string Department\n    }\n\n    Borrowing {\n        string BorrowID PK\n        string BorrowDate\n        string DueDate\n        string ReturnDate\n        string StudentID FK\n        string BookID FK\n        string LibrarianID FK\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Generate an ER diagram for a retail inventory management system that includes entities like Products, Suppliers, Orders, and Categories.",
        "planning": "*   **Entities:**\n    *   **Products:** Core items for sale (e.g., name, description, price, SKU).\n    *   **Suppliers:** Companies providing products (e.g., name, contact info).\n    *   **Orders:** Customer purchases (e.g., order date, order ID, shipping address).\n    *   **Categories:** Product classifications (e.g., name, description).\n\n*   **Relationships:**\n    *   **Products** *belong to* **Categories** (Many-to-One: A product belongs to only one category, a category can have many products).\n    *   **Products** *are supplied by* **Suppliers** (Many-to-Many: A product can be supplied by multiple suppliers, a supplier can supply multiple products - often resolved with a linking entity).\n    *   **Orders** *contain* **Products** (Many-to-Many: An order contains multiple products, a product can be in multiple orders - needs a linking/junction table, Order_Items).\n    *   **Suppliers** *supply* **Products** (Many-to-Many: Supplier-Product relationship mediated by a junction table for quantity and cost - typically called Supplier_Products or similar).\n\n*   **Attributes (Key examples - each entity has more):**\n    *   **Products:** ProductID (PK), Name, Description, Price, CategoryID (FK).\n    *   **Suppliers:** SupplierID (PK), Name, ContactInfo.\n    *   **Orders:** OrderID (PK), OrderDate, ShippingAddress.\n    *   **Categories:** CategoryID (PK), Name, Description.\n    *   **Order_Items (Linking Table):** OrderID (FK), ProductID (FK), Quantity.\n    *   **Supplier_Products (Linking Table):** SupplierID (FK), ProductID (FK), Price, Quantity_Available.\n\n*   **Interactions:**\n    *   Customers place Orders containing Products.\n    *   Products are categorized into Categories.\n    *   Suppliers provide Products, and the Supplier_Products table tracks pricing and quantities.",
        "output": "erDiagram\n    Products ||--o{ Categories : belongs_to\n    Products { \n        string ProductID PK\n        string Name\n        string Description\n        float Price\n        string CategoryID FK\n    }\n    Categories { \n        string CategoryID PK\n        string Name\n        string Description\n    }\n    Suppliers ||--o{ Supplier_Products : supplies\n    Products ||--o{ Supplier_Products : is_supplied_by\n    Supplier_Products { \n        string SupplierID FK\n        string ProductID FK\n        float Price\n        int Quantity_Available\n    }\n    Suppliers { \n        string SupplierID PK\n        string Name\n        string ContactInfo\n    }\n    Orders ||--o{ Order_Items : contains\n    Products ||--o{ Order_Items : is_in\n    Orders { \n        string OrderID PK\n        date OrderDate\n        string ShippingAddress\n    }\n    Order_Items { \n        string OrderID FK\n        string ProductID FK\n        int Quantity\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Design an ER diagram for a customer feedback system involving Customers, Feedback, Products, and Responses.",
        "planning": "**Entities:**\n\n*   **Customer:** (CustomerID, Name, Email, etc.) - Stores customer information.\n*   **Product:** (ProductID, ProductName, Description, etc.) - Stores product details.\n*   **Feedback:** (FeedbackID, FeedbackText, Rating, DateSubmitted, etc.) - Stores the feedback provided by customers.\n*   **Response:** (ResponseID, ResponseText, DateResponded, Responder, etc.) - Stores the responses to the feedback.\n\n**Relationships:**\n\n*   **Customer *gives* Feedback:** A customer can give multiple feedbacks. Feedback is given by one customer. (One-to-Many)\n*   **Feedback *is about* Product:** Feedback is related to one product. A product can have many feedbacks. (One-to-Many)\n*   **Feedback *receives* Response:** Feedback can receive multiple responses. A response is for one feedback. (One-to-Many)",
        "output": "erDiagram\n    CUSTOMER ||--o{ FEEDBACK : gives\n    FEEDBACK }|--|| PRODUCT : is_about\n    FEEDBACK ||--o{ RESPONSE : receives\n\n    CUSTOMER {\n        int CustomerID PK\n        string Name\n        string Email\n    }\n\n    PRODUCT {\n        int ProductID PK\n        string ProductName\n        string Description\n    }\n\n    FEEDBACK {\n        int FeedbackID PK\n        string FeedbackText\n        int Rating\n        date DateSubmitted\n    }\n\n    RESPONSE {\n        int ResponseID PK\n        string ResponseText\n        date DateResponded\n        string Responder\n    }"
    },
    {
        "diagram_type": "entityRelationshipDiagram",
        "prompt": "Create an ER diagram for a travel booking system with entities such as Travelers, Trips, Itineraries, and Bookings.",
        "planning": "*   **Travelers:** Attributes: TravelerID (PK), Name, Contact Information.\n*   **Trips:** Attributes: TripID (PK), Destination, StartDate, EndDate, Description.\n*   **Itineraries:** Attributes: ItineraryID (PK), TripID (FK), Day, Activity, Location.\n*   **Bookings:** Attributes: BookingID (PK), TravelerID (FK), ItineraryID (FK), BookingDate, Price.\n\n**Relationships:**\n\n*   A Traveler can make many Bookings (one-to-many).\n*   A Trip can have many Itineraries (one-to-many).\n*   An Itinerary belongs to one Trip (many-to-one).\n*   A Booking is associated with one Traveler (many-to-one).\n*   A Booking is associated with one Itinerary (many-to-one).",
        "output": "erDiagram\n    TRAVELER ||--o{ BOOKING : makes\n    TRIP ||--o{ ITINERARY : has\n    ITINERARY }o--|| TRIP : partOf\n    BOOKING }o--|| TRAVELER : isFor\n    BOOKING }o--|| ITINERARY : includes\n\n    TRAVELER {\n        string TravelerID PK\n        string Name\n        string ContactInformation\n    }\n\n    TRIP {\n        string TripID PK\n        string Destination\n        string StartDate\n        string EndDate\n        string Description\n    }\n\n    ITINERARY {\n        string ItineraryID PK\n        string TripID FK\n        string Day\n        string Activity\n        string Location\n    }\n\n    BOOKING {\n        string BookingID PK\n        string TravelerID FK\n        string ItineraryID FK\n        string BookingDate\n        string Price\n    }"
    },
    {
        "diagram_type": "examples",
        "prompt": "Generate a Mermaid examples diagram showing the flow of TCP connection establishment.",
        "planning": "*   **Client:** The initiator of the TCP connection.\n*   **Server:** The receiver of the connection request.\n*   **SYN (Synchronization):** The first segment sent by the client.\n*   **SYN-ACK (Synchronization-Acknowledgement):** The server's response to the SYN.\n*   **ACK (Acknowledgement):** The client's final acknowledgement, completing the handshake.\n*   **Flow:** Client sends SYN to Server, Server sends SYN-ACK to Client, Client sends ACK to Server.",
        "output": "sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: TCP 3-Way Handshake\n\n    Client->>Server: SYN\n    Server->>Client: SYN-ACK\n    Client->>Server: ACK\n\n    Note over Client,Server: Connection Established"
    },
    {
        "diagram_type": "examples",
        "prompt": "Produce a Mermaid examples diagram for how data packets are transferred in a TCP connection.",
        "planning": "*   **Client:** Represents the initiating machine.\n    *   Sends SYN packet to the server.\n    *   Receives SYN-ACK packet from the server.\n    *   Sends ACK packet to the server.\n    *   Sends Data packets to the server.\n    *   Receives ACK packets for data from the server.\n    *   Sends FIN packet to the server (Connection termination).\n    *   Receives ACK for FIN and FIN from server.\n    *   Sends ACK for server's FIN.\n*   **Server:** Represents the receiving machine.\n    *   Receives SYN packet from the client.\n    *   Sends SYN-ACK packet to the client.\n    *   Receives ACK packet from the client.\n    *   Receives Data packets from the client.\n    *   Sends ACK packets for data to the client.\n    *   Sends FIN packet to the client (Connection termination - can happen from either side).\n    *   Receives ACK for FIN and FIN from client.\n    *   Sends ACK for client's FIN.\n*   **Packets:** Shows the flow of key TCP packets.\n    *   SYN: Synchronization packet (connection initiation).\n    *   SYN-ACK: Synchronization-Acknowledgment packet (server response).\n    *   ACK: Acknowledgment packet (acknowledges receipt).\n    *   Data: Application data packets.\n    *   FIN: Finish packet (connection termination).\n\n*   **Arrows:** Indicate the direction of packet flow.\n    *   Labeled with packet type (SYN, SYN-ACK, ACK, Data, FIN).\n    *   Shows the sequence of packet exchange.",
        "output": "sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: TCP 3-Way Handshake\n    Client->>Server: SYN\n    Server->>Client: SYN-ACK\n    Client->>Server: ACK\n\n    Note over Client,Server: Data Transfer\n    Client->>Server: Data\n    Server->>Client: ACK\n\n    Client->>Server: Data\n    Server->>Client: ACK\n\n    Note over Client,Server: Connection Termination\n    Client->>Server: FIN\n    Server->>Client: ACK\n    Server->>Client: FIN\n    Client->>Server: ACK"
    },
    {
        "diagram_type": "examples",
        "prompt": "Create a Mermaid examples diagram that illustrates the OAuth authentication process in an E-commerce application.",
        "planning": "*   **User:** Initiates login.\n*   **E-commerce Application (Client):** Requests authorization from the Authorization Server.\n*   **Authorization Server:** Authenticates user, requests consent, issues Authorization Code.\n*   **Resource Server:** Hosts protected resources.\n*   **Interaction flow:**\n    1.  User clicks \"Login.\"\n    2.  E-commerce App redirects to Authorization Server.\n    3.  User authenticates with Authorization Server.\n    4.  Authorization Server requests user consent.\n    5.  Authorization Server redirects back to E-commerce App with Authorization Code.\n    6.  E-commerce App exchanges Authorization Code for Access Token.\n    7.  E-commerce App accesses protected resources from Resource Server using Access Token.",
        "output": "sequenceDiagram\n    participant U as User\n    participant EC as E-commerce App\n    participant AS as Authorization Server\n    participant RS as Resource Server\n\n    Note over U, RS: OAuth Authentication Flow\n\n    U->>EC: Clicks Login\n    EC->>AS: Redirects to Authorization Server\n    activate AS\n    AS->>U: Authenticates User\n    AS->>U: Requests Consent\n    U-->>AS: Grants Consent\n    AS->>EC: Redirects back with Authorization Code\n    deactivate AS\n    EC->>AS: Exchanges Code for Access Token\n    activate AS\n    AS-->>EC: Issues Access Token\n    deactivate AS\n    EC->>RS: Accesses Protected Resources with Token\n    activate RS\n    RS-->>EC: Returns Resources\n    deactivate RS\n\n    Note right of EC: Access Token used for authorized requests"
    },
    {
        "diagram_type": "examples",
        "prompt": "Give a Mermaid examples diagram showing a block diagram of the RSA cryptography algorithm.",
        "planning": "*   **Components:**\n    *   Key Generation: Produces Public Key (e, n) and Private Key (d, n).\n    *   Encryption: Encrypts the plaintext using the Public Key (e, n).\n    *   Decryption: Decrypts the ciphertext using the Private Key (d, n).\n\n*   **Interactions:**\n    *   Key Generation creates and outputs both Public and Private keys.\n    *   Encryption receives Plaintext and Public Key, outputs Ciphertext.\n    *   Decryption receives Ciphertext and Private Key, outputs Plaintext.",
        "output": "graph LR\n    subgraph KeyGeneration [Key Generation]\n        A[Choose p and q] --> B{n = p*q}\n        B --> C{phi = (p-1)*(q-1)}\n        C --> D[Choose e: 1 < e < phi coprime to phi]\n        D --> E{Calculate d: d*e = 1 mod phi}\n        E --> F(Public Key: e n)\n        E --> G(Private Key: d n)\n    end\n\n    subgraph Encryption [Encryption]\n        H[Plaintext] --> I(Public Key: e n)\n        I --> J{Ciphertext = Plaintext^e mod n}\n    end\n\n    subgraph Decryption [Decryption]\n        K[Ciphertext] --> L(Private Key: d n)\n        L --> M{Plaintext = Ciphertext^d mod n}\n    end\n\n    F --> I\n    G --> L"
    },
    {
        "diagram_type": "examples",
        "prompt": "Draw a Mermaid examples diagram for the message exchange sequence in a simple chat application.",
        "planning": "*   **Participants:** User A, User B, Chat Server\n*   **Message Flow:**\n    *   User A sends message to Chat Server.\n    *   Chat Server forwards message to User B.\n    *   User B sends acknowledgement to Chat Server (optional).\n    *   Chat Server forwards acknowledgement to User A (optional).\n*   **Key Interactions:** `sendMessage`, `receiveMessage`, `forwardMessage`\n*   **Focus:** Highlighting message direction and component roles.",
        "output": "sequenceDiagram\n    participant UserA as User A\n    participant ChatServer as Chat Server\n    participant UserB as User B\n\n    UserA->>ChatServer: sendMessage\n    activate ChatServer\n    ChatServer->>UserB: forwardMessage\n    activate UserB\n    UserB-->>ChatServer: receiveMessage\n    deactivate UserB\n    ChatServer-->>UserA: receiveMessage\n    deactivate ChatServer"
    },
    {
        "diagram_type": "examples",
        "prompt": "Design a Mermaid examples diagram representing the state transitions in a fork-join process in parallel computing.",
        "planning": "*   **Initial State:** Represents the starting point of the parallel process.\n*   **Fork:** Shows the split into parallel execution paths. Label with \"Fork\" or a suitable description.\n*   **Parallel Activities/States:** Depict the concurrent tasks being executed. Use multiple states, each representing a task, clearly labeled (e.g., \"Task A,\" \"Task B\").\n*   **Join:** Represents the synchronization point where all parallel tasks converge. Label as \"Join.\"\n*   **Final State:** Represents the completion of the overall parallel process.\n*   **Transitions:** Arrows showing the flow:\n    *   From Initial State to Fork.\n    *   From Fork to each parallel activity.\n    *   From each parallel activity to Join.\n    *   From Join to Final State.\n*   **Interaction:** The fork starts parallel execution, parallel tasks run independently, and the join waits for all tasks to finish before proceeding to the final state.",
        "output": "graph LR\n    Initial --> Fork\n    Fork --> TaskA\n    Fork --> TaskB\n    Fork --> TaskC\n    TaskA --> Join\n    TaskB --> Join\n    TaskC --> Join\n    Join --> Final\n    \n    subgraph Legend\n        Initial(Initial State)\n        Fork[Fork]\n        TaskA(Task A)\n        TaskB(Task B)\n        TaskC(Task C)\n        Join[Join]\n        Final(Final State)\n    end\n\n    style Fork fill:#f9f,stroke:#333,stroke-width:2px\n    style Join fill:#f9f,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "examples",
        "prompt": "Generate a Mermaid examples diagram depicting the basic software architecture of a RAG-based system.",
        "planning": "*   **User:** Represents the end-user initiating the query.\n*   **User Query:** User's input question/prompt.\n*   **Retrieval:** Component responsible for fetching relevant context.\n    *   **Vector Database:** Stores embeddings of knowledge base chunks.\n    *   **Embedding Model:** Transforms both query and knowledge base chunks into embeddings.\n*   **Generation:** Component that uses retrieved context and the original query to generate an answer.\n    *   **LLM (Large Language Model):** The core component responsible for generating the final answer.\n*   **Knowledge Base:** The source of information for the RAG system.\n    *   **Data Ingestion:** Component responsible for loading and processing the knowledge base.\n*   **Output:** The generated answer presented to the user.\n\n**Interactions:**\n\n1.  User sends a query.\n2.  Query is embedded.\n3.  Retrieval searches the Vector Database using the embedded query.\n4.  Relevant context is retrieved from the Vector Database.\n5.  LLM receives the query and the retrieved context.\n6.  LLM generates an answer.\n7.  Answer is presented to the User.\n8.  Data Ingestion loads data into Knowledge Base and generates embeddings for the Vector Database.",
        "output": "graph LR\n    User[User] --> UserQuery(User Query)\n    UserQuery --> EmbeddingModel[Embedding Model]\n\n    EmbeddingModel -- Embed Query --> Retrieval[Retrieval]\n\n    Retrieval --> VectorDB(Vector Database)\n    VectorDB -- Relevant Context --> LLM[LLM]\n\n    UserQuery --> LLM\n    LLM --> Output(Output)\n    Output --> User\n\n    KnowledgeBase[Knowledge Base] --> DataIngestion(Data Ingestion)\n    DataIngestion --> VectorDB\n    DataIngestion --> EmbeddingModel\n\n    style User fill:#f9f,stroke:#333,stroke-width:2px\n    style Output fill:#f9f,stroke:#333,stroke-width:2px\n    style LLM fill:#ccf,stroke:#333,stroke-width:2px\n    style Retrieval fill:#ccf,stroke:#333,stroke-width:2px\n    style VectorDB fill:#ccf,stroke:#333,stroke-width:2px\n    style KnowledgeBase fill:#ffc,stroke:#333,stroke-width:2px\n    style DataIngestion fill:#ffc,stroke:#333,stroke-width:2px\n    style EmbeddingModel fill:#ccf,stroke:#333,stroke-width:2px\n    style UserQuery fill:#f9f,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "examples",
        "prompt": "Create a Mermaid examples diagram for a Kanban board representing tasks such as 'In Progress' and 'Completed'.",
        "planning": "*   **Columns:** Represent Kanban board stages (e.g., \"To Do,\" \"In Progress,\" \"Done\"). Use `state` or `stateTitle` to define them.\n*   **Tasks:** Represent individual tasks within each column. Use nodes within the `state` definitions.\n*   **Transitions:** Show the flow of tasks between columns. Use arrows (`-->`) to indicate movement.\n*   **Subtasks (Optional):** If needed, show subtasks within a task using nested nodes.\n*   **Grouping (Optional):** Group related tasks visually using `subgraph`.",
        "output": "stateDiagram\n    state ToDo {\n        Task1 : Task 1\n        Task2 : Task 2\n    }\n\n    state InProgress {\n        Task3 : Task 3\n        Task4 : Task 4\n    }\n\n    state Done {\n        Task5 : Task 5\n        Task6 : Task 6\n    }\n\n    ToDo --> InProgress : Move to In Progress\n    InProgress --> Done : Move to Done\n    InProgress --> ToDo : Reopen"
    },
    {
        "diagram_type": "examples",
        "prompt": "Provide a Mermaid examples diagram detailing the block structure of a TCP header.",
        "planning": "*   **Source Port:** Identifies the sending application.\n*   **Destination Port:** Identifies the receiving application.\n*   **Sequence Number:** Tracks the order of transmitted data segments.\n*   **Acknowledgment Number:** Indicates the next expected sequence number from the receiver.\n*   **Data Offset:** Specifies the size of the TCP header (where the data begins).\n*   **Reserved:** Reserved bits for future use.\n*   **Flags (Control Bits):** (SYN, ACK, FIN, RST, PSH, URG) Control the connection establishment, termination, and data flow.\n*   **Window Size:** Indicates the receiver's available buffer space.\n*   **Checksum:** Error detection for the header and data.\n*   **Urgent Pointer:** Points to urgent data within the segment.\n*   **Options:** (MSS, Window Scale, SACK, etc.) Optional features.\n*   **Padding:** Used to ensure the header ends on a 32-bit boundary.\n*   **Data:** The actual application data being transmitted (follows the header).\n\nInteraction/Flow:\n\n1.  Header fields combine to form the complete TCP packet header.\n2.  Data is appended after the header.\n3.  Flags influence connection states and data handling.\n4.  Ports define endpoints; Sequence & Acknowledgment numbers ensure reliability.\n5.  Window Size manages flow control.",
        "output": "graph LR\n    subgraph TCP Header\n        A[Source Port] --> B(Destination Port)\n        B --> C{Sequence Number}\n        C --> D[Acknowledgment Number]\n        D --> E(Data Offset)\n        E --> F{Reserved}\n        F --> G[Flags Control Bits]\n        G --> H(Window Size)\n        H --> I{Checksum}\n        I --> J[Urgent Pointer]\n        J --> K(Options)\n        K --> L{Padding}\n    end\n    \n    L --> M[Data]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#ccf,stroke:#333,stroke-width:2px\n    style C fill:#f9f,stroke:#333,stroke-width:2px\n    style D fill:#ccf,stroke:#333,stroke-width:2px\n    style E fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#ccf,stroke:#333,stroke-width:2px\n    style G fill:#f9f,stroke:#333,stroke-width:2px\n    style H fill:#ccf,stroke:#333,stroke-width:2px\n    style I fill:#f9f,stroke:#333,stroke-width:2px\n    style J fill:#ccf,stroke:#333,stroke-width:2px\n    style K fill:#f9f,stroke:#333,stroke-width:2px\n    style L fill:#ccf,stroke:#333,stroke-width:2px\n    style M fill:#fff,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "examples",
        "prompt": "Draw a Mermaid examples diagram for a packet flow illustration of a UDP packet.",
        "planning": "*   **Source Application:** (e.g., Game, Video Streaming) - Initiates the data transmission.\n*   **Source Operating System:** (OS Kernel) - Handles the application's request to send data.\n*   **UDP Protocol:** - Encapsulates data into a UDP datagram (adds UDP header).\n*   **IP Protocol:** - Adds IP header (source/destination IP addresses).\n*   **Network Interface Card (NIC):** Sends the IP packet onto the network.\n*   **Network (Internet/Local Network):** Represents the path the packet travels.\n*   **Destination NIC:** Receives the IP packet.\n*   **Destination Operating System:** Decapsulates the IP packet.\n*   **UDP Protocol (Destination):** Decapsulates the UDP datagram.\n*   **Destination Application:** Receives the data.\n\n**Interactions:**\n\n1.  Application -> OS Kernel (Data transfer request)\n2.  OS Kernel -> UDP (Encapsulation)\n3.  UDP -> IP (Encapsulation)\n4.  IP -> NIC (Transmission)\n5.  NIC -> Network (Packet travels)\n6.  Network -> Destination NIC (Reception)\n7.  Destination NIC -> Destination OS Kernel\n8.  OS Kernel -> IP (Decapsulation)\n9.  IP -> UDP (Decapsulation)\n10. UDP -> Application (Data delivery)",
        "output": "sequenceDiagram\n    participant AppSource as Source Application\n    participant OSSource as Source OS\n    participant UDPSource as UDP\n    participant IPSource as IP\n    participant NICSource as Source NIC\n    participant Network\n    participant NICDest as Destination NIC\n    participant OSDest as Destination OS\n    participant UDPDest as UDP\n    participant AppDest as Destination Application\n\n    AppSource->>OSSource: Data Transfer Request\n    OSSource->>UDPSource: Encapsulation\n    UDPSource->>IPSource: Encapsulation\n    IPSource->>NICSource: Transmission\n    NICSource->>Network: Packet Travels\n    Network->>NICDest: Reception\n    NICDest->>OSDest: Packet Delivery\n    OSDest->>UDPDest: Decapsulation\n    UDPDest->>AppDest: Data Delivery"
    },
    {
        "diagram_type": "examples",
        "prompt": "Generate a Mermaid examples diagram for a quadrant chart showing the SWOT analysis for OpenAI.",
        "planning": "*   **Overall Structure:** Four quadrants representing Strengths, Weaknesses, Opportunities, and Threats.\n*   **Quadrant Labels:** Clear labels for each quadrant: \"Strengths,\" \"Weaknesses,\" \"Opportunities,\" \"Threats.\"\n*   **Content within Quadrants:** Each quadrant will contain bullet points (or short phrases) listing specific SWOT factors for OpenAI. The content interacts by providing a comprehensive overview of internal (Strengths, Weaknesses) and external (Opportunities, Threats) factors.\n*   **Connectors/Flow:** While not mandatory, arrows or lines could visually connect related elements across quadrants (e.g., a strength that mitigates a threat). This shows interaction/relationship between factors.\n*   **Central Subject:** The chart is implicitly about OpenAI. No explicit \"OpenAI\" label *needs* to be in the diagram itself, but the content within each quadrant relates to OpenAI.",
        "output": "quadrantChart\n    x-axis Strengths --> Weaknesses\n    y-axis Opportunities --> Threats\n\n    quadrant 1 [Strengths]\n        Internal expertise in AI\n        Strong brand recognition\n        Cutting-edge technology\n        Large research budget\n\n    quadrant 2 [Weaknesses]\n        High operational costs\n        Dependence on large datasets\n        Limited transparency in algorithms\n        Potential for misuse\n\n    quadrant 3 [Opportunities]\n        Expansion into new markets\n        Partnerships with other companies\n        Growing demand for AI solutions\n        Development of new AI applications\n\n    quadrant 4 [Threats]\n        Increasing competition\n        Ethical concerns\n        Regulatory scrutiny\n        Rapid technological advancements"
    },
    {
        "diagram_type": "examples",
        "prompt": "Create a Mermaid examples diagram illustrating the flow of an HTTP request in a web server environment.",
        "planning": "*   **Client (Browser):** Initiates the HTTP request.\n*   **Network (Internet):** Transports the request to the server.\n*   **Web Server (e.g., Nginx, Apache):** Receives the request.\n*   **Application Server (e.g., Node.js, Python/Flask):** Processes the request (if needed).\n*   **Database (e.g., MySQL, PostgreSQL):** Stores and retrieves data (if needed).\n*   **Response:** HTTP response returned to the client.\n\n**Interactions:**\n\n1.  Client sends HTTP Request -> Network.\n2.  Network delivers Request -> Web Server.\n3.  Web Server routes Request -> Application Server (if needed, otherwise handles directly).\n4.  Application Server queries -> Database (if data is needed).\n5.  Database returns Data -> Application Server.\n6.  Application Server builds Response -> Web Server.\n7.  Web Server sends Response -> Network.\n8.  Network delivers Response -> Client.",
        "output": "sequenceDiagram\n    participant Client as Browser\n    participant Network as Internet\n    participant WebServer as Web Server\n    participant AppServer as Application Server\n    participant Database\n\n    Client->>Network: HTTP Request\n    Network->>WebServer: Deliver Request\n    WebServer->>AppServer: Route Request\n    AppServer->>Database: Query Data\n    Database-->>AppServer: Return Data\n    AppServer->>WebServer: Build Response\n    WebServer->>Network: Send Response\n    Network->>Client: Deliver Response"
    },
    {
        "diagram_type": "examples",
        "prompt": "Design a Mermaid examples diagram for the lifecycle of a software bug from report to resolution.",
        "planning": "*   **States:**\n    *   Reported: Initial state when a bug is logged.\n    *   New: Bug is acknowledged but not yet assigned.\n    *   Assigned: Bug is assigned to a developer.\n    *   In Progress: Developer is actively working on the bug.\n    *   Fixed: Developer believes the bug is resolved.\n    *   In Review: Code fix is being reviewed.\n    *   Testing: QA is testing the fix.\n    *   Reopened: QA found the bug is not fixed.\n    *   Resolved: QA confirmed the fix.\n    *   Closed: Bug is verified and no longer an issue.\n\n*   **Transitions (Actions/Edges):**\n    *   Report Bug -> Reported\n    *   Reported -> New\n    *   New -> Assigned\n    *   Assigned -> In Progress\n    *   In Progress -> Fixed\n    *   Fixed -> In Review\n    *   In Review -> Testing\n    *   Testing -> Resolved\n    *   Testing -> Reopened\n    *   Reopened -> Assigned\n    *   Resolved -> Closed\n\n*   **Actors (Optional for clarity, could be included as notes or labels):**\n    *   Reporter (User)\n    *   Triage\n    *   Developer\n    *   Reviewer\n    *   QA/Tester\n\n*   **Interactions (Implicit in transitions but can be emphasized):**\n    *   User reports bug to the system.\n    *   Triage assigns the bug.\n    *   Developer fixes and submits for review.\n    *   Reviewer reviews code.\n    *   QA tests the fix.\n    *   QA either resolves or reopens the bug.",
        "output": "graph LR\n    subgraph Bug Lifecycle\n\n    A[Report Bug] --> B(Reported)\n\n    B --> C(New)\n\n    C --> D(Assigned)\n\n    D --> E(In Progress)\n\n    E --> F(Fixed)\n\n    F --> G(In Review)\n\n    G --> H(Testing)\n\n    H --> I(Resolved)\n\n    H --> J(Reopened)\n\n    J --> D\n\n    I --> K(Closed)\n    end\n\n    style A fill:#ccf,stroke:#333,stroke-width:2px\n    style B fill:#ccf,stroke:#333,stroke-width:2px\n    style C fill:#ccf,stroke:#333,stroke-width:2px\n    style D fill:#ccf,stroke:#333,stroke-width:2px\n    style E fill:#ccf,stroke:#333,stroke-width:2px\n    style F fill:#ccf,stroke:#333,stroke-width:2px\n    style G fill:#ccf,stroke:#333,stroke-width:2px\n    style H fill:#ccf,stroke:#333,stroke-width:2px\n    style I fill:#ccf,stroke:#333,stroke-width:2px\n    style J fill:#ccf,stroke:#333,stroke-width:2px\n    style K fill:#ccf,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "examples",
        "prompt": "Provide a Mermaid examples diagram outlining the RSA encryption and decryption workflow.",
        "planning": "*   **Entities:**\n    *   PlainText (Message)\n    *   Sender\n    *   Receiver\n    *   Encryption Key (Public Key)\n    *   Decryption Key (Private Key)\n    *   Ciphertext\n*   **Interactions:**\n    *   Sender uses Public Key to encrypt PlainText -> Ciphertext\n    *   Ciphertext is sent from Sender to Receiver.\n    *   Receiver uses Private Key to decrypt Ciphertext -> PlainText\n*   **Flow:**\n    1.  PlainText originates with Sender.\n    2.  Sender encrypts PlainText with Public Key.\n    3.  Result is Ciphertext.\n    4.  Ciphertext is transmitted to Receiver.\n    5.  Receiver decrypts Ciphertext with Private Key.\n    6.  Result is PlainText (recovered message).",
        "output": "sequenceDiagram\n    participant S as Sender\n    participant R as Receiver\n    participant PK as Public Key\n    participant PrK as Private Key\n    participant PT as PlainText\n    participant CT as Ciphertext\n\n    Note over S,PT: 1. Message Originates\n    S->>PK: Encrypt PT\n    activate PK\n    PK-->>S: CT\n    deactivate PK\n    Note over S,CT: 2. Encryption with Public Key\n    S->>R: CT\n    Note over S,R: 3. Ciphertext Transmission\n    activate R\n    R->>PrK: Decrypt CT\n    activate PrK\n    PrK-->>R: PT\n    deactivate PrK\n    R-->>R: PT\n    deactivate R\n    Note over R,PT: 4. Decryption with Private Key"
    },
    {
        "diagram_type": "examples",
        "prompt": "Draw a Mermaid examples diagram for the architecture of a simple E-commerce payment system.",
        "planning": "*   **User:** Initiates payment, interacts with Frontend.\n*   **Frontend:** Presents product, cart, payment options; communicates with Backend.\n*   **Backend:** Handles order processing, communicates with Payment Gateway, Database.\n*   **Database:** Stores product, user, order, and payment information.\n*   **Payment Gateway:** Securely processes payment with external services (Credit Card, PayPal), returns transaction status to Backend.\n*   **External Payment Service (e.g., Bank, PayPal):** Actual payment processor.\n\n**Interactions:**\n\n1.  User -> Frontend: Selects product, adds to cart, initiates checkout.\n2.  Frontend -> Backend: Sends order details, payment request.\n3.  Backend -> Database: Retrieves product information, updates order status.\n4.  Backend -> Payment Gateway: Sends payment details.\n5.  Payment Gateway -> External Payment Service: Processes payment.\n6.  External Payment Service -> Payment Gateway: Returns transaction status.\n7.  Payment Gateway -> Backend: Relays transaction status.\n8.  Backend -> Database: Updates payment status, order information.\n9.  Backend -> Frontend: Confirms payment status to User.",
        "output": "sequenceDiagram\n    participant User\n    participant Frontend\n    participant Backend\n    participant Database\n    participant PaymentGateway as Payment Gateway\n    participant ExternalPaymentService as External Payment Service\n\n    User->>Frontend: Selects product adds to cart initiates checkout\n    Frontend->>Backend: Sends order details payment request\n    Backend->>Database: Retrieves product information updates order status\n    Backend->>PaymentGateway: Sends payment details\n    PaymentGateway->>ExternalPaymentService: Processes payment\n    ExternalPaymentService->>PaymentGateway: Returns transaction status\n    PaymentGateway->>Backend: Relays transaction status\n    Backend->>Database: Updates payment status order information\n    Backend->>Frontend: Confirms payment status to User"
    },
    {
        "diagram_type": "examples",
        "prompt": "Generate a Mermaid examples diagram showing the flow of data processing in a chat messaging app.",
        "planning": "*   **User Interface (UI):**\n    *   *Interaction:* User types and sends message. Receives and displays messages.\n\n*   **Client App:**\n    *   *Interaction:* Captures message from UI. Sends message to the Server. Receives messages from Server and updates UI.\n\n*   **Server:**\n    *   *Interaction:* Receives message from Client. Stores message in Database. Sends message to recipient(s).\n\n*   **Database:**\n    *   *Interaction:* Stores and retrieves messages.\n\n*   **Push Notification Service (Optional):**\n    *   *Interaction:* Server triggers push notification to recipient if offline.\n\n*   **Recipient Client App:**\n    *   *Interaction:* Receives message from Server. Updates recipient UI. May receive push notification.\n\n*   **Recipient User Interface:**\n    *   *Interaction:* Displays message to the recipient user.\n\n*   **Data Flow Direction:** Should be clearly indicated with arrows (e.g., UI -> Client App, Client App -> Server, Server -> Database, Server -> Recipient Client).",
        "output": "sequenceDiagram\n    participant UI as User Interface\n    participant Client as Client App\n    participant Server\n    participant DB as Database\n    participant Push as Push Notification Service\n    participant RecipientClient as Recipient Client App\n    participant RecipientUI as Recipient User Interface\n\n    UI->>Client: User types and sends message\n    Client->>Server: Send message to Server\n    Server->>DB: Store message in Database\n    alt Recipient Offline\n        Server->>Push: Trigger push notification to recipient\n        Push->>RecipientClient: Send push notification\n    end\n    Server->>RecipientClient: Send message to Recipient Client\n    RecipientClient->>RecipientUI: Update Recipient UI with message\n    Client->>UI: Receive messages from Server and updates UI\n\n    Note right of UI: User types and sends message <br/> Receives and displays messages.\n    Note right of Client: Captures message from UI. <br/> Sends message to the Server. <br/>Receives messages from Server and updates UI.\n    Note right of Server: Receives message from Client. <br/>Stores message in Database. <br/>Sends message to recipient(s).\n    Note right of DB: Stores and retrieves messages.\n    Note right of Push: Server triggers push notification to recipient if offline.\n    Note right of RecipientClient: Receives message from Server.<br/> Updates recipient UI. <br/>May receive push notification.\n    Note right of RecipientUI: Displays message to the recipient user."
    },
    {
        "diagram_type": "examples",
        "prompt": "Create a Mermaid examples diagram for a simplified TCP/IP suite packet diagram.",
        "planning": "*   **Layers:** Application, Transport, Network (Internet), Data Link, Physical.\n*   **Application Layer:** Example data (e.g., \"Hello\").\n*   **Transport Layer:** Adds TCP/UDP header (Source Port, Destination Port, Sequence Number, ACK Number).\n*   **Network Layer:** Adds IP header (Source IP, Destination IP).\n*   **Data Link Layer:** Adds MAC header and trailer (Source MAC, Destination MAC, CRC).\n*   **Physical Layer:** Transmission medium representation.\n*   **Flow:** Data originates at Application Layer and flows down through each layer, being encapsulated at each stage.\n*   **Interaction:** Each layer receives data from the layer above, adds its header (and trailer), and passes it to the layer below.\n*   **Diagram Type:** Flowchart or sequence diagram is appropriate.",
        "output": "graph LR\n    A[Application Layer] --> B(Transport Layer)\n    B --> C{Network Layer}\n    C --> D[Data Link Layer]\n    D --> E((Physical Layer))\n\n    subgraph Data Encapsulation\n        A -- \"Data: Hello\" --> B\n        B -- \"TCP/UDP Header: SrcPort DstPort Seq Ack\" --> C\n        C -- \"IP Header: SrcIP DstIP\" --> D\n        D -- \"MAC Header/Trailer: SrcMAC DstMAC CRC\" --> E\n    end\n\n    style A fill:#ccf,stroke:#333,stroke-width:2px\n    style B fill:#ccf,stroke:#333,stroke-width:2px\n    style C fill:#ccf,stroke:#333,stroke-width:2px\n    style D fill:#ccf,stroke:#333,stroke-width:2px\n    style E fill:#ccf,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "examples",
        "prompt": "Provide a Mermaid examples diagram representing state transitions in a finite state machine for a vending machine.",
        "planning": "*   **States:** Represent different stages of the vending machine operation (e.g., Idle, Selecting, Dispensing, Out of Stock).\n*   **Events/Transitions:** Represent actions that cause state changes (e.g., Coin Inserted, Product Selected, Dispense Button Pressed, No Stock). Transitions are arrows connecting states.\n*   **Initial State:** Indicate the starting state (typically Idle).\n*   **Inputs:** User actions (e.g., inserting coins, selecting a product).\n*   **Outputs:** Vending machine responses (e.g., displaying product prices, dispensing product, returning change). (Implied from Transitions)\n*   **Decision Points:** Represent conditions that affect state transition (e.g., enough money inserted, product in stock). (Implied from Transitions)",
        "output": "stateDiagram\n    state Idle {\n        [*] --> Idle\n        Idle --> Selecting : CoinInserted\n    }\n    state Selecting {\n        Selecting --> Dispensing : ProductSelected\n        Selecting --> ReturningChange : Cancel\n        Selecting --> Idle : Timeout\n    }\n    state Dispensing {\n        Dispensing --> Idle : ProductDispensed\n        Dispensing --> OutOfStock : NoStock\n    }\n    state OutOfStock {\n        OutOfStock --> Idle : Refilled\n    }\n    state ReturningChange {\n        ReturningChange --> Idle : ChangeReturned\n    }"
    },
    {
        "diagram_type": "examples",
        "prompt": "Draw a Mermaid examples diagram illustrating the flow of data in a RESTful API request-response cycle.",
        "planning": "*   **Client:** Initiates the request.\n*   **Request (HTTP):** Shows the type (e.g., GET, POST), endpoint, and optional data.\n*   **Server:** Receives and processes the request.\n*   **Application Logic:** Server-side code that handles the business logic.\n*   **Database (Optional):** If data is needed, show interaction.\n*   **Response (HTTP):** Includes status code and response data (e.g., JSON).\n*   **Client:** Receives and displays the response.",
        "output": "sequenceDiagram\n    participant Client\n    participant Server\n    participant AppLogic as Application Logic\n    participant Database\n\n    Client->>Server: HTTP Request <br/> Method: GET/POST/PUT/DELETE <br/> Endpoint: /api/resource\n    activate Server\n    Server->>AppLogic: Process Request\n    activate AppLogic\n    AppLogic->>Database: Query Data <br/> If Required\n    activate Database\n    Database-->>AppLogic: Return Data\n    deactivate Database\n    AppLogic-->>Server: Construct Response\n    deactivate AppLogic\n    Server-->>Client: HTTP Response <br/> Status Code: 200/400/500 <br/> Data: JSON\n    deactivate Server"
    },
    {
        "diagram_type": "examples",
        "prompt": "Generate a Mermaid examples diagram for a sequence diagram of a user registration process.",
        "planning": "**Plan:**\n\n*   **Participants:** User, Browser, Web Server, Database\n*   **User -> Browser:** User enters registration details.\n*   **Browser -> Web Server:** Sends registration request.\n*   **Web Server -> Database:** Checks if username exists.\n*   **Database -> Web Server:** Returns username availability.\n*   **Web Server -> Database:** Saves user data (if available).\n*   **Database -> Web Server:** Returns success/failure of saving.\n*   **Web Server -> Browser:** Returns registration status (success/failure).\n*   **Browser -> User:** Displays registration status.",
        "output": "sequenceDiagram\n    participant User\n    participant Browser\n    participant WebServer as Web Server\n    participant Database\n\n    User->>Browser: Enters registration details\n    Browser->>+WebServer: Sends registration request\n    WebServer->>+Database: Checks if username exists\n    Database-->>-WebServer: Returns username availability\n    alt Username Available\n        WebServer->>+Database: Saves user data\n        Database-->>-WebServer: Returns save status\n        alt Save Successful\n            WebServer->>Browser: Returns registration success\n            Browser->>User: Displays registration success\n        else Save Failed\n            WebServer->>Browser: Returns registration failure\n            Browser->>User: Displays registration failure\n        end\n    else Username Unavailable\n        WebServer->>Browser: Returns registration failure\n        Browser->>User: Displays registration failure\n    end"
    },
    {
        "diagram_type": "examples",
        "prompt": "Produce a Mermaid examples diagram detailing the block diagram of a blockchain transaction flow.",
        "planning": "*   **User:** Initiates transaction (signs with private key).\n*   **Transaction:** Contains data, sender, receiver, value, signature.\n*   **Node/Wallet:** Creates and broadcasts transaction.\n*   **Network:** Transmits transaction to other nodes.\n*   **Mempool:** Node stores unconfirmed transactions.\n*   **Miner/Validator:** Selects transactions from mempool.\n*   **Block:** Groups transactions together.\n*   **Hashing Algorithm:** Creates a unique hash for the block.\n*   **Blockchain:** Adds new block to the chain.\n*   **Ledger:** Distributed, immutable record of all transactions.\n*   **Consensus Mechanism:** Validates the new block (Proof-of-Work, Proof-of-Stake, etc.).\n*   **Nodes (revisited):** Receive and verify the new block.\n*   **Confirmation:** Network confirms the transaction.\n*   **User(receiver):** Receives transaction.",
        "output": "graph LR\n    subgraph User_Initiation\n        A[User] --> B{Initiate Transaction} \n        B --> C[Sign Transaction with Private Key]\n    end\n    \n    C --> D(Transaction: Data Sender Receiver Value Signature)\n    D --> E[Node/Wallet: Create & Broadcast]\n    E --> F(Network: Transmit to Nodes)\n    F --> G[Mempool: Unconfirmed Transactions]\n    G --> H{Miner/Validator: Select Transactions}\n    H --> I[Block: Group Transactions]\n    I --> J{Hashing Algorithm: Create Block Hash}\n    J --> K[Blockchain: Add Block to Chain]\n    K --> L(Ledger: Distributed Immutable Record)\n    L --> M{Consensus Mechanism: Validate Block}\n    M --> N[Nodes: Receive & Verify Block]\n    N --> O{Confirmation: Network Confirmation}\n    O --> P[User Receiver: Receive Transaction]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style P fill:#f9f,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram of how a TCP connection is established.",
        "planning": "*   **Client (Initiator):**\n    *   Sends SYN (Synchronization) packet to the server.\n    *   Transitions to SYN-SENT state.\n\n*   **Server (Listener):**\n    *   Receives SYN packet from the client.\n    *   Sends SYN-ACK (Synchronization-Acknowledgment) packet to the client.\n    *   Transitions to SYN-RECEIVED state.\n\n*   **Client (Initiator):**\n    *   Receives SYN-ACK packet from the server.\n    *   Sends ACK (Acknowledgment) packet to the server.\n    *   Transitions to ESTABLISHED state.\n\n*   **Server (Listener):**\n    *   Receives ACK packet from the client.\n    *   Transitions to ESTABLISHED state.",
        "output": "flowchart TD\n    subgraph Client\n      A[Start] --> B(SYN); \n      B --> C{SYN-SENT}\n      C --> D(Receive SYN-ACK)\n      D --> E(ACK)\n      E --> F{ESTABLISHED}\n      end\n    subgraph Server\n      G[Listen] --> H(Receive SYN)\n      H --> I{SYN-RECEIVED}\n      I --> J(SYN-ACK)\n      J --> K(Receive ACK)\n      K --> L{ESTABLISHED}\n      end\n\n    B -- Sends SYN --> H\n    J -- Sends SYN-ACK --> D\n    E -- Sends ACK --> K"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram showing how data packets are transferred in a TCP communication.",
        "planning": "*   **Start:** Initiation of Communication (Application on Client initiates connection).\n*   **Client (Sender):**\n    *   Sends SYN packet to Server.\n    *   Receives SYN-ACK packet from Server.\n    *   Sends ACK packet to Server.\n    *   Sends Data Packets (Data + TCP Header) to Server.\n    *   Receives ACK for Data Packets from Server.\n*   **Server (Receiver):**\n    *   Receives SYN packet from Client.\n    *   Sends SYN-ACK packet to Client.\n    *   Receives ACK packet from Client.\n    *   Receives Data Packets from Client.\n    *   Sends ACK for Data Packets to Client.\n*   **Network:** Represent the path/channel where packets travel between Client and Server.\n*   **Acknowledgement (ACK):** Indicates successful receipt of data or control packets. Used by both Client and Server.\n*   **Error Handling/Retransmission (Implicit):** (Not explicitly boxes, but implied within data transfer loop. Consider adding if space allows). If ACK not received, resend data.\n*   **End:** Connection Termination (FIN, ACK sequence - optional).",
        "output": "flowchart TD\n    A[Start: Client Application Initiates Connection] --> B(Client: Sends SYN Packet) \n    B --> Network[Network]\n    Network --> C(Server: Receives SYN Packet)\n    C --> D(Server: Sends SYN-ACK Packet)\n    D --> Network\n    Network --> E(Client: Receives SYN-ACK Packet)\n    E --> F(Client: Sends ACK Packet)\n    F --> Network\n    Network --> G(Server: Receives ACK Packet)\n    G --> H(Server: Ready to Receive Data)\n    H --> I(Server: Sends ACK for Data Packets)\n    I --> Network\n    J(Client: Sends Data Packets \\n + TCP Header) --> Network\n    Network --> K(Server: Receives Data Packets)\n    K --> I\n    J --> L(Client: Receives ACK for Data Packets)\n    L --> M{Data Transfer Complete?}\n    M -- Yes --> N[End: Connection Termination]\n    M -- No --> J\n    style Network fill:#ccf,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram that outlines the process of user authentication in a simple e-commerce web application.",
        "planning": "*   **Start:** Beginning of the authentication process.\n*   **User Enters Credentials:** User inputs username/email and password.\n*   **Validate Input:** Check if the input fields are properly filled (not empty).\n*   **Retrieve User Data:** Fetch user data from the database based on the entered username/email.\n*   **Verify Password:** Compare the entered password with the stored hashed password.\n*   **Authentication Successful?:** Conditional check \u2013 did the passwords match?\n    *   **Yes:** Proceed to generate authentication token/session.\n    *   **No:** Display \"Invalid Credentials\" error message.\n*   **Generate Auth Token/Session:** Create a unique token or session ID for the authenticated user.\n*   **Store Session/Token:** Store the authentication token/session on the server side (e.g., database, cache).\n*   **Set Cookie/Return Token:** Send the token/session ID to the client-side (browser) as a cookie or return it in the response body.\n*   **Access Granted:** User is authenticated and can access protected resources.\n*   **End:** End of the authentication process (successful or failed).",
        "output": "flowchart TD\n    A[Start] --> B{User Enters Credentials}\n    B --> C{Validate Input}\n    C -- Valid --> D{Retrieve User Data}\n    D --> E{Verify Password}\n    E -- Password Match --> F{Authentication Successful?}\n    F -- Yes --> G{Generate Auth Token/Session}\n    G --> H{Store Session/Token}\n    H --> I{Set Cookie/Return Token}\n    I --> J[Access Granted]\n    J --> K[End]\n    F -- No --> L{Invalid Credentials}\n    L --> K"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram illustrating the login process in a basic chat application.",
        "planning": "*   **Start:** Represents the beginning of the login process.\n*   **User Enters Credentials:** Input of username/email and password.\n*   **Validate Input:** Check if the entered data is in correct format and not empty.\n*   **Authentication:** Verify credentials against stored user data.\n*   **Credentials Valid?:** Decision point: yes or no.\n    *   **Yes:** Proceed to login success.\n    *   **No:** Proceed to login failure.\n*   **Login Success:** User granted access to chat application.\n*   **Login Failure:** Display error message to user.\n*   **End:** Represents the end of either successful or failed login attempt.",
        "output": "flowchart TD\n    Start[Start] --> Input[User Enters Credentials]\n    Input --> Validate[Validate Input]\n    Validate --> Authenticate[Authentication]\n    Authenticate --> CredentialsValid{Credentials Valid?}\n    CredentialsValid -- Yes --> Success[Login Success]\n    CredentialsValid -- No --> Failure[Login Failure]\n    Success --> End[End]\n    Failure --> End\n\n    style Start fill:#f9f,stroke:#333,stroke-width:2px\n    style Input fill:#ccf,stroke:#333,stroke-width:2px\n    style Validate fill:#ccf,stroke:#333,stroke-width:2px\n    style Authenticate fill:#ccf,stroke:#333,stroke-width:2px\n    style CredentialsValid fill:#ffc,stroke:#333,stroke-width:2px\n    style Success fill:#9f9,stroke:#333,stroke-width:2px\n    style Failure fill:#f66,stroke:#333,stroke-width:2px\n    style End fill:#f9f,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram to demonstrate the REST API request and response flow in a RAG-based application.",
        "planning": "*   **User/Client:** Initiates the request.\n*   **REST API Endpoint:** Receives the request.\n*   **RAG Application Server:** Processes the request.\n*   **Vector Database:** Stores and retrieves embeddings.\n*   **Large Language Model (LLM):** Generates the response.\n*   **Response:** The API sends the response back to the user/client.\n\n**Interactions:**\n\n1.  User/Client sends request to REST API Endpoint.\n2.  REST API Endpoint forwards to RAG Application Server.\n3.  RAG Application Server queries Vector Database.\n4.  Vector Database returns relevant context.\n5.  RAG Application Server prompts LLM with context.\n6.  LLM generates response.\n7.  RAG Application Server formats response and sends back to REST API Endpoint.\n8.  REST API Endpoint sends response to User/Client.",
        "output": "flowchart TD\n    Client[User/Client] --> API[REST API Endpoint]\n    API --> RAG[RAG Application Server]\n    RAG --> VectorDB[Vector Database]\n    VectorDB --> RAG\n    RAG --> LLM[Large Language Model]\n    LLM --> RAG\n    RAG --> API\n    API --> Client\n\n    style Client fill:#f9f,stroke:#333,stroke-width:2px\n    style API fill:#ccf,stroke:#333,stroke-width:2px\n    style RAG fill:#ccf,stroke:#333,stroke-width:2px\n    style VectorDB fill:#ccf,stroke:#333,stroke-width:2px\n    style LLM fill:#ccf,stroke:#333,stroke-width:2px\n\n    linkStyle 1 stroke:#333,stroke-width:2px\n    linkStyle 2 stroke:#333,stroke-width:2px\n    linkStyle 3 stroke:#333,stroke-width:2px\n    linkStyle 4 stroke:#333,stroke-width:2px\n    linkStyle 5 stroke:#333,stroke-width:2px\n    linkStyle 6 stroke:#333,stroke-width:2px\n    linkStyle 7 stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram that explains the CRUD operations workflow in a blogging platform.",
        "planning": "*   **Start:** Beginning of the process.\n*   **User Interface (UI):** User interaction point (e.g., web page).\n*   **Create:**\n    *   UI: User enters blog post data.\n    *   Logic: Platform validates data, creates post.\n    *   Database: Saves new blog post.\n*   **Read:**\n    *   UI: User requests a blog post (e.g., by ID).\n    *   Logic: Platform retrieves post from the database.\n    *   Database: Returns requested post.\n    *   UI: Display blog post to the user.\n*   **Update:**\n    *   UI: User edits an existing blog post.\n    *   Logic: Platform validates updated data.\n    *   Database: Updates blog post in the database.\n*   **Delete:**\n    *   UI: User requests deletion of a blog post.\n    *   Logic: Platform confirms deletion.\n    *   Database: Deletes blog post from the database.\n*   **Database:** Storage for blog posts.\n*   **End:** End of each operation.\n*   **Decision Points (Validation):** After Create/Update, check if data is valid. If not, loop back to UI.",
        "output": "flowchart LR\n    Start --> UI_Create\n    Start --> UI_Read\n    Start --> UI_Update\n    Start --> UI_Delete\n\n    %% Create Operation\n    UI_Create[UI: Enter Post Data] --> Logic_Create[Logic: Validate and Create]\n    Logic_Create --> Validate_Create{Data Valid?}\n    Validate_Create -- Yes --> DB_Create[Database: Save New Post]\n    DB_Create --> End_Create(End: Create)\n    Validate_Create -- No --> UI_Create\n\n    %% Read Operation\n    UI_Read[UI: Request Post by ID] --> Logic_Read[Logic: Retrieve Post]\n    Logic_Read --> DB_Read[Database: Return Post]\n    DB_Read --> UI_Display[UI: Display Post]\n    UI_Display --> End_Read(End: Read)\n\n    %% Update Operation\n    UI_Update[UI: Edit Existing Post] --> Logic_Update[Logic: Validate and Update]\n    Logic_Update --> Validate_Update{Data Valid?}\n    Validate_Update -- Yes --> DB_Update[Database: Update Post]\n    DB_Update --> End_Update(End: Update)\n    Validate_Update -- No --> UI_Update\n\n    %% Delete Operation\n    UI_Delete[UI: Request Post Deletion] --> Logic_Delete[Logic: Confirm Deletion]\n    Logic_Delete --> DB_Delete[Database: Delete Post]\n    DB_Delete --> End_Delete(End: Delete)"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram of the OAuth 2.0 authentication flow in an online banking application.",
        "planning": "*   **Resource Owner (User):** Initiates the process, grants access.\n*   **Client Application (Banking App):** Requests authorization.\n*   **Authorization Server (Bank's Auth Server):** Authenticates user, issues authorization code.\n*   **Resource Server (Bank's API):** Hosts user's bank account data.\n\n**Interactions:**\n\n1.  User uses Banking App.\n2.  Banking App redirects user to Authorization Server.\n3.  User authenticates with Authorization Server.\n4.  Authorization Server asks user for consent.\n5.  Authorization Server redirects user back to Banking App with Authorization Code.\n6.  Banking App exchanges Authorization Code for Access Token with Authorization Server.\n7.  Banking App accesses Resource Server (Bank's API) using Access Token.\n8.  Resource Server returns protected resource (account data) to Banking App.",
        "output": "flowchart LR\n    subgraph OAuth 2.0 Authentication Flow\n\n    User[Resource Owner] --> App[Client Application] : 1. Uses Banking App\n\n    App --> AuthServer[Authorization Server] : 2. Redirects to Auth Server\n\n    AuthServer --> User : 3. User Authenticates\n\n    AuthServer --> User : 4. Asks for Consent\n\n    AuthServer --> App : 5. Redirects with Auth Code\n\n    App --> AuthServer : 6. Exchanges Auth Code for Token\n\n    App --> API[Resource Server Bank's API] : 7. Accesses API with Token\n\n    API --> App : 8. Returns Account Data\n\n    end\n\n    style User fill:#f9f,stroke:#333,stroke-width:2px\n    style App fill:#ccf,stroke:#333,stroke-width:2px\n    style AuthServer fill:#ffc,stroke:#333,stroke-width:2px\n    style API fill:#cfc,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram representing the RSA encryption and decryption process.",
        "planning": "*   **Start:** Indicates the beginning of the process.\n\n*   **Key Generation:**\n    *   Choose two distinct prime numbers, *p* and *q*.\n    *   Calculate *n* = *p* \\* *q*. (Modulus)\n    *   Calculate \u03c6(*n*) = (*p*-1) \\* (*q*-1). (Euler's totient)\n    *   Choose an integer *e* such that 1 < *e* < \u03c6(*n*) and gcd(*e*, \u03c6(*n*)) = 1. (Public exponent)\n    *   Compute *d* such that *d* \\* *e* \u2261 1 (mod \u03c6(*n*)). (Private exponent)\n    *   Output: Public Key (*n*, *e*) and Private Key (*n*, *d*).\n\n*   **Encryption:**\n    *   Input: Plaintext message *M*.\n    *   Calculate ciphertext *C* = *M*<sup>*e*</sup> mod *n*.\n    *   Output: Ciphertext *C*.\n\n*   **Decryption:**\n    *   Input: Ciphertext *C*.\n    *   Calculate plaintext *M* = *C*<sup>*d*</sup> mod *n*.\n    *   Output: Plaintext message *M*.\n\n*   **End:** Indicates the end of the process.\n\n*   **Flow/Interaction:** The flow should go linearly from Start -> Key Generation -> Encryption -> Decryption -> End. Key Generation provides the necessary keys for Encryption and Decryption. Encryption's output is the input for Decryption.",
        "output": "flowchart TD\n    Start --> KeyGen\n    KeyGen --> Encryption\n    Encryption --> Decryption\n    Decryption --> End\n\n    subgraph KeyGen [Key Generation]\n        A[Choose primes p and q] --> B{n = p * q}\n        B --> C{\u03c6n = (p-1) * (q-1)}\n        C --> D{Choose e: 1 < e < \u03c6n and gcden = 1}\n        D --> E{Compute d: d*e \u2261 1 mod \u03c6n}\n        E --> F[Output Public Key: ne and Private Key: nd]\n    end\n\n    subgraph Encryption\n        G[Input Plaintext M] --> H{C = Me mod n}\n        H --> I[Output Ciphertext C]\n    end\n\n    subgraph Decryption\n        J[Input Ciphertext C] --> K{M = Cd mod n}\n        K --> L[Output Plaintext M]\n    end\n\n    style Start fill:#90EE90,stroke:#333,stroke-width:2px\n    style End fill:#90EE90,stroke:#333,stroke-width:2px\n    style KeyGen fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style Encryption fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style Decryption fill:#ADD8E6,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram outlining the packet switching process in a computer network.",
        "planning": "*   **Source Host:**\n    *   Starts the process by creating a data packet.\n    *   Interaction: Sends the packet to the first network node (router/switch).\n*   **Routers/Switches (Intermediate Nodes):**\n    *   Receives the packet.\n    *   Examines the destination address in the packet header.\n    *   Consults routing table to determine the next hop.\n    *   Forwards the packet to the next router/switch or destination.\n    *   Interaction: Receive from previous node, forward to next node based on routing.\n*   **Transmission Links (Communication Channels):**\n    *   Represent the physical links connecting nodes.\n    *   Interaction: Carries the packet between nodes.\n*   **Destination Host:**\n    *   Receives the packet.\n    *   Reassembles packets (if fragmented) to reconstruct the original data.\n    *   Interaction: Receives final packet(s) and reconstructs data.\n*   **Packet Fragmentation (Optional):**\n    *   Router might fragment the packet if the MTU of the next link is smaller than the packet size.\n    *   Destination host reassembles these fragments.\n    *   Interaction: If MTU is small it fragments, destination reconstructs.",
        "output": "flowchart TD\n    A[Source Host] --> B{Router/Switch}\n    B --> C{Router/Switch}\n    C --> D[Destination Host]\n\n    subgraph Source\n        A\n    end\n\n    subgraph Network\n        B -- Transmission Link --> C\n    end\n\n    subgraph Destination\n        D\n    end\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#ccf,stroke:#333,stroke-width:2px\n    style C fill:#ccf,stroke:#333,stroke-width:2px\n    style D fill:#f9f,stroke:#333,stroke-width:2px\n\n    Note left of A: Creates Data Packet\n    Note right of D: Reassembles Packets\n\n    subgraph Packet Fragmentation\n        E[MTU Check] --> F{Fragment?}\n        F -- Yes --> G[Fragment Packet]\n        G --> D\n        F -- No --> D\n        style E fill:#ffc,stroke:#333,stroke-width:2px\n        style F fill:#fcc,stroke:#333,stroke-width:2px\n        style G fill:#ffc,stroke:#333,stroke-width:2px\n        C --> E\n    end"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram that shows state transitions in a simplified peer-to-peer file sharing system.",
        "planning": "*   **States:**\n    *   Idle: Peer is online but not actively sharing or requesting.\n    *   Searching: Peer is querying the network for a specific file.\n    *   Downloading: Peer is receiving file chunks from another peer.\n    *   Uploading: Peer is sending file chunks to another peer.\n    *   Seeding: Peer has the complete file and is actively uploading to others.\n\n*   **Components:**\n    *   Peer: Represents a node in the P2P network.\n    *   Network: Represents the P2P network infrastructure (e.g., DHT).\n\n*   **Interactions:**\n    *   Idle -> Searching: Peer initiates a search for a file (trigger: user request). Interaction: Peer sends a query to the Network.\n    *   Searching -> Downloading: Peer finds a peer with the file and starts downloading. Interaction: Peer requests file chunks from another Peer (identified by the Network).\n    *   Searching -> Idle: No peer found. Interaction: Timeout or negative response from the Network.\n    *   Downloading -> Seeding: Peer finishes downloading the file. Interaction: File integrity check.\n    *   Downloading -> Idle: Download interrupted (e.g., connection loss). Interaction: Connection termination with the uploading peer.\n    *   Idle -> Uploading: Another peer requests file chunks from this peer. Interaction: Peer receives a request for a file chunk.\n    *   Uploading -> Idle: Upload finished or interrupted. Interaction: Connection termination with the downloading peer.\n    *   Seeding -> Uploading: Another peer requests file chunks from this peer. Interaction: Peer receives a request for a file chunk.\n    *   Seeding -> Idle: Peer stops seeding (user decision or system event).",
        "output": "flowchart LR\n    Idle -- User requests file --> Searching\n    Searching -- Peer found --> Downloading\n    Searching -- No peer found, Timeout --> Idle\n    Downloading -- Download complete, Integrity check --> Seeding\n    Downloading -- Download interrupted --> Idle\n    Idle -- Another peer requests file --> Uploading\n    Uploading -- Upload finished or interrupted --> Idle\n    Seeding -- Another peer requests file --> Uploading\n    Seeding -- User stops seeding --> Idle\n\n    subgraph States\n      Idle(Idle)\n      Searching(Searching)\n      Downloading(Downloading)\n      Uploading(Uploading)\n      Seeding(Seeding)\n    end\n\n    subgraph Components\n      Peer[Peer]\n      Network[Network]\n    end\n\n    style Idle fill:#f9f,stroke:#333,stroke-width:2px\n    style Searching fill:#ccf,stroke:#333,stroke-width:2px\n    style Downloading fill:#ccf,stroke:#333,stroke-width:2px\n    style Uploading fill:#ccf,stroke:#333,stroke-width:2px\n    style Seeding fill:#9f9,stroke:#333,stroke-width:2px\n\n    style Peer fill:#fff,stroke:#333,stroke-width:2px\n    style Network fill:#fff,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram illustrating the steps of a divide and conquer algorithm.",
        "planning": "*   **Start:** Represents the beginning of the algorithm.\n*   **Divide:**  Splits the problem into smaller subproblems.  Flows from Start.\n*   **Base Case Check:** Checks if subproblem is small enough to solve directly. Flows from Divide.\n*   **Solve Directly (Base Case):**  If Base Case is met, solve the subproblem directly. Flows from Base Case Check (YES).\n*   **Conquer (Recursive Call):** If Base Case is not met, recursively call the divide and conquer algorithm on the subproblems. Flows from Base Case Check (NO).\n*   **Combine:** Combines the solutions of the subproblems to obtain the solution for the original problem. Flows from Solve Directly and Conquer.\n*   **Return Solution:** Outputs the final solution. Flows from Combine.\n*   **End:** Represents the end of the algorithm. Flows from Return Solution.",
        "output": "flowchart TD\n    Start --> Divide\n    Divide --> BaseCaseCheck\n    BaseCaseCheck -- Yes --> SolveDirectly\n    BaseCaseCheck -- No --> Conquer\n    SolveDirectly --> Combine\n    Conquer --> Combine\n    Combine --> ReturnSolution\n    ReturnSolution --> End\n\n    subgraph Algorithm Steps\n      Start[Start]\n      Divide[Divide: Split Problem]\n      BaseCaseCheck{Base Case?}\n      SolveDirectly[Solve Directly]\n      Conquer[Conquer: Recursive Call]\n      Combine[Combine Solutions]\n      ReturnSolution[Return Solution]\n      End[End]\n    end"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram for the workflow of software version control using Git.",
        "planning": "*   **Start:** Represents the beginning of the workflow.\n*   **Working Directory:** Represents the developer's local files.\n    *   Interaction: Files are modified/added/deleted here.\n*   **Staging Area (Index):** Where changes are prepared for commit.\n    *   Interaction: Files are \"added\" from the working directory to the staging area using `git add`.\n*   **Local Repository:** The Git repository on the developer's machine.\n    *   Interaction: Changes in the staging area are \"committed\" to the local repository using `git commit`.\n*   **Remote Repository (e.g., GitHub):** The central repository.\n    *   Interaction:\n        *   Changes are \"pushed\" from the local repository to the remote repository using `git push`.\n        *   Changes are \"pulled\" from the remote repository to the local repository using `git pull` or `git fetch` + `git merge`.\n*   **Branching:** Creating separate lines of development.\n    *   Interaction: \"Branch\" off the main branch; \"merge\" branches back together.\n*   **Pull Request (Optional):** Request to merge a branch into another (often main) branch.\n    *   Interaction: Create pull request; review pull request; merge pull request.\n*   **End:** Represents the end of a specific workflow cycle (though the process is iterative).",
        "output": "flowchart TD\n    Start --> WorkingDirectory\n    WorkingDirectory -- Modify/Add/Delete Files --> WorkingDirectory\n    WorkingDirectory --> StagingArea\n    StagingArea -- git add --> StagingArea\n    StagingArea --> LocalRepository\n    LocalRepository -- git commit --> LocalRepository\n    LocalRepository --> RemoteRepository\n    RemoteRepository -- git push --> LocalRepository\n    LocalRepository --> RemoteRepository\n    RemoteRepository -- git pull/fetch+merge --> LocalRepository\n    LocalRepository --> Branching\n    Branching -- Branch/Merge --> Branching\n    Branching --> PullRequest\n    PullRequest -- Create/Review/Merge --> RemoteRepository\n    RemoteRepository --> End\n\n    style Start fill:#f9f,stroke:#333,stroke-width:4px\n    style End fill:#f9f,stroke:#333,stroke-width:4px\n\n    subgraph Components\n      WorkingDirectory[Working Directory]\n      StagingArea[Staging Area Index]\n      LocalRepository[Local Repository]\n      RemoteRepository[Remote Repository e.g. GitHub]\n      Branching[Branching]\n      PullRequest[Pull Request Optional]\n    end"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram depicting the lifecycle of a thread in a multi-threaded application.",
        "planning": "*   **States:** Include states like New, Runnable (Ready/Running), Blocked/Waiting, Timed Waiting, Terminated.\n*   **Start:** A \"New\" state representing thread creation.\n*   **Runnable:** From \"New,\" transition to \"Runnable\" when `start()` is called. Differentiate between Ready (waiting for CPU) and Running (currently executing).\n*   **Blocking/Waiting:** Show transitions to \"Blocked/Waiting\" due to operations like `wait()`, I/O blocking, or `sleep()`.\n*   **Timed Waiting:** Distinct from \"Blocked/Waiting\" - transition due to `sleep(time)`, `wait(time)`, or `join(time)`.\n*   **Transitions back to Runnable:** Show transitions back to \"Runnable\" when the blocking condition is resolved (e.g., `notify()`, I/O completion, timeout).\n*   **Termination:** A \"Terminated\" state, reached when the thread's `run()` method completes or an unhandled exception occurs.\n*   **Synchronization/Locking (Optional):** Briefly show how acquiring/releasing a lock (e.g., using `synchronized` keyword or Lock objects) can cause transitions to/from the \"Blocked/Waiting\" state.\n*   **Scheduling (Implicit):** The transition between \"Ready\" and \"Running\" is managed by the OS scheduler (not explicitly shown, but implied).\n*   **Interactions:** Arrows connecting the states, labeled with the events or operations causing the transition.",
        "output": "flowchart TD\n    New[New] --> Runnable\n    Runnable -- start() --> Ready\n    Ready --> Running\n    Running -- CPU Scheduler --> Ready\n    Running --> BlockedWaiting\n    Running -- wait\\nI-O Blocking\\nLock Acquisition --> BlockedWaiting\n    Running --> TimedWaiting\n    Running -- sleep(time)\\nwait(time)\\njoin(time) --> TimedWaiting\n    BlockedWaiting --> Ready\n    BlockedWaiting -- notify\\nI-O Completion\\nLock Release --> Ready\n    TimedWaiting --> Ready\n    TimedWaiting -- Timeout --> Ready\n    Running --> Terminated\n    Running -- run() completes\\nUnhandled Exception --> Terminated\n    Terminated[Terminated]\n\n    style New fill:#f9f,stroke:#333,stroke-width:2px\n    style Runnable fill:#ccf,stroke:#333,stroke-width:2px\n    style Ready fill:#ddf,stroke:#333,stroke-width:2px\n    style Running fill:#aaf,stroke:#333,stroke-width:2px\n    style BlockedWaiting fill:#fcc,stroke:#333,stroke-width:2px\n    style TimedWaiting fill:#fdd,stroke:#333,stroke-width:2px\n    style Terminated fill:#eee,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram representing the fork-join process in a parallel computing system.",
        "planning": "*   **Start:** Beginning of the parallel process.\n*   **Fork:** Split the process into multiple parallel tasks. Arrows go to parallel tasks.\n*   **Parallel Task 1, Parallel Task 2, ... Parallel Task N:** Represent individual tasks executing concurrently. Arrows come from Fork, arrows go to Join.\n*   **Join:** Synchronization point where parallel tasks merge back into a single process. Arrows come from each Parallel Task.\n*   **Continue:** The process continues after the join point. Arrow comes from Join.\n*   **End:** Termination of the parallel process. Arrow comes from Continue.\n*   **Decision diamonds (Optional):** Include decision points within parallel tasks for conditional execution.",
        "output": "flowchart TD\n    Start --> Fork\n    Fork --> ParallelTask1\n    Fork --> ParallelTask2\n    Fork --> ParallelTaskN\n\n    ParallelTask1 --> Join\n    ParallelTask2 --> Join\n    ParallelTaskN --> Join\n\n    Join --> Continue\n    Continue --> End\n\n    subgraph Parallel Tasks\n      ParallelTask1[Task 1]\n      ParallelTask2[Task 2]\n      ParallelTaskN[Task N]\n    end\n\n    Start(Start Process)\n    Fork{Fork}\n    Join{Join}\n    Continue(Continue Process)\n    End(End Process)"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram detailing the process of error handling in a web server application.",
        "planning": "*   **Start:** Represents the initial request received by the web server.\n*   **Receive Request:** The web server accepts an incoming HTTP request.\n*   **Process Request:** The core logic handling the request (e.g., routing, data retrieval, business logic).\n*   **Error Occurred?**: A decision point to check if any error occurred during request processing.\n*   **Yes (Error):** Leads to error handling routines.\n*   **No (Success):** Leads to successful response generation.\n*   **Log Error:** Record the error details (timestamp, error code, message) for debugging and monitoring.\n*   **Handle Error:** Implement specific error handling logic (e.g., retry, fallback, data correction).\n*   **Generate Error Response:** Create an appropriate HTTP error response (e.g., 500 Internal Server Error, 404 Not Found).\n*   **Send Response:** Transmit the HTTP response (either success or error) back to the client.\n*   **End:** The request processing is complete.\n\n**Interactions:**\n1.  Request flows from \"Receive Request\" to \"Process Request\".\n2.  \"Process Request\" leads to \"Error Occurred?\".\n3.  If \"Error Occurred?\" is yes, flow moves to \"Log Error\", \"Handle Error\", and \"Generate Error Response\".\n4.  If \"Error Occurred?\" is no, flow moves to \"Generate Success Response\".\n5.  Both \"Generate Error Response\" and \"Generate Success Response\" lead to \"Send Response\".\n6.  \"Send Response\" leads to \"End\".",
        "output": "flowchart TD\n    Start --> Receive_Request\n    Receive_Request --> Process_Request\n    Process_Request --> Error_Occurred\n    Error_Occurred{Error Occurred?}\n    Error_Occurred -- Yes --> Log_Error\n    Error_Occurred -- Yes --> Handle_Error\n    Error_Occurred -- Yes --> Generate_Error_Response\n    Error_Occurred -- No --> Generate_Success_Response\n    Log_Error --> Handle_Error\n    Handle_Error --> Generate_Error_Response\n    Generate_Error_Response --> Send_Response\n    Generate_Success_Response --> Send_Response\n    Send_Response --> End\n\n    subgraph Error Handling\n      Log_Error\n      Handle_Error\n      Generate_Error_Response\n    end\n\n    style Error_Occurred fill:#f9f,stroke:#333,stroke-width:2px\n    style Log_Error fill:#ccf,stroke:#333,stroke-width:1px\n    style Handle_Error fill:#ccf,stroke:#333,stroke-width:1px\n    style Generate_Error_Response fill:#ccf,stroke:#333,stroke-width:1px\n    style Generate_Success_Response fill:#ccf,stroke:#333,stroke-width:1px\n\n    classDef process fill:#fff,stroke:#333,stroke-width:1px\n    class Start,Receive_Request,Process_Request,Send_Response,End process"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram for HTTP request handling in a simplified RESTful service.",
        "planning": "*   **Start:** Represents the beginning of the request.\n\n*   **Receive HTTP Request:** The service receives the incoming request.\n\n*   **Parse Request:** Extracts information (method, URL, headers, body).\n\n*   **Route Request:** Determines the appropriate handler based on the URL and HTTP method.\n\n*   **Authenticate/Authorize (Optional):** Verifies user identity and permissions.\n\n*   **Process Request:** Handler executes business logic using the request data.\n\n*   **Data Access (Optional):** Interacts with a database or other data source.\n\n*   **Create Response:** Constructs an HTTP response (status code, headers, body).\n\n*   **Send HTTP Response:** Sends the response back to the client.\n\n*   **End:** Represents the completion of the request handling.",
        "output": "flowchart TD\n    Start[Start] --> ReceiveRequest[Receive HTTP Request]\n    ReceiveRequest --> ParseRequest[Parse Request]\n    ParseRequest --> RouteRequest[Route Request]\n    RouteRequest --> Authz{Authenticate/Authorize}\n    Authz -- Yes --> ProcessRequest[Process Request]\n    Authz -- No --> SendErrorResponse[Send Error Response]\n    RouteRequest --> ProcessRequest\n    ProcessRequest --> DataAccess{Data Access}\n    DataAccess -- Yes --> DataStore[Data Store]\n    DataAccess -- No --> CreateResponse[Create Response]\n    DataStore --> CreateResponse\n    CreateResponse --> SendResponse[Send HTTP Response]\n    SendErrorResponse --> SendResponse\n    SendResponse --> End[End]"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram showing the stages of model training in a basic machine learning workflow.",
        "planning": "*   **Start:** Beginning of the workflow.\n*   **Data Acquisition:** Gather relevant data. (Input to: Data Preprocessing)\n*   **Data Preprocessing:** Clean, transform, and prepare the data. (Input to: Feature Engineering, Split Data)\n*   **Feature Engineering:** Select or create relevant features. (Input to: Model Selection)\n*   **Split Data:** Divide data into training, validation, and test sets. (Input to: Model Training)\n*   **Model Selection:** Choose appropriate model type. (Input to: Model Training)\n*   **Model Training:** Train the selected model on training data. (Input to: Model Evaluation)\n*   **Model Evaluation:** Evaluate model performance on validation data. (Decision: Good Enough?)\n    *   **If \"No\":** Return to Model Training (potentially with hyperparameter tuning loop not explicitly shown).\n    *   **If \"Yes\":** Proceed to Model Testing\n*   **Model Testing:** Assess final model performance on test data. (Input to: Model Deployment)\n*   **Model Deployment:** Deploy the trained model for use. (Input to: End)\n*   **End:** Completion of the workflow.",
        "output": "flowchart TD\n    Start --> DataAcquisition\n    DataAcquisition --> DataPreprocessing\n    DataPreprocessing --> FeatureEngineering\n    DataPreprocessing --> SplitData\n    FeatureEngineering --> ModelSelection\n    SplitData --> ModelTraining\n    ModelSelection --> ModelTraining\n    ModelTraining --> ModelEvaluation\n    ModelEvaluation -- No --> ModelTraining\n    ModelEvaluation -- Yes --> ModelTesting\n    ModelTesting --> ModelDeployment\n    ModelDeployment --> End\n\n    style Start fill:#f9f,stroke:#333,stroke-width:4px\n    style End fill:#f9f,stroke:#333,stroke-width:4px\n\n    classDef process fill:#ccf,stroke:#333,stroke-width:2px\n    class DataAcquisition,DataPreprocessing,FeatureEngineering,SplitData,ModelSelection,ModelTraining,ModelEvaluation,ModelTesting,ModelDeployment process"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram outlining the user registration process in a social media application.",
        "planning": "*   **Start:** Beginning of the registration process.\n*   **Input User Details:** (Name, Email, Password, etc.) - User provides information.\n*   **Validate Input:** Check if the email format is valid, password meets complexity requirements, etc.\n    *   **Invalid Input:** Return to \"Input User Details\" with an error message.\n    *   **Valid Input:** Proceed to the next step.\n*   **Check Email Uniqueness:** Verify if the entered email already exists in the database.\n    *   **Email Exists:** Return to \"Input User Details\" with an error message.\n    *   **Email Unique:** Proceed to the next step.\n*   **Create User Account:** Store user details in the database.\n*   **Send Verification Email:** Automatically send an email to the provided address.\n*   **User Verifies Email:** User clicks a link in the email.\n*   **Verify Email Token:** Check if the token from the email link is valid.\n    *   **Invalid Token:** Display error and potentially resend verification email.\n    *   **Valid Token:** Proceed to the next step.\n*   **Activate Account:** Mark the user account as active.\n*   **Registration Complete:** Display a success message and redirect to the login page or application home.\n*   **End:** End of the registration process.",
        "output": "flowchart TD\n    Start --> InputUserDetails\n    InputUserDetails[Input User Details] --> ValidateInput\n    ValidateInput{Validate Input}\n    ValidateInput -- Invalid Input --> InputUserDetails\n    ValidateInput -- Valid Input --> CheckEmailUniqueness\n    CheckEmailUniqueness{Check Email Uniqueness}\n    CheckEmailUniqueness -- Email Exists --> InputUserDetails\n    CheckEmailUniqueness -- Email Unique --> CreateUserAccount\n    CreateUserAccount[Create User Account] --> SendVerificationEmail\n    SendVerificationEmail[Send Verification Email] --> UserVerifiesEmail\n    UserVerifiesEmail[User Verifies Email] --> VerifyEmailToken\n    VerifyEmailToken{Verify Email Token}\n    VerifyEmailToken -- Invalid Token --> ResendVerificationEmail[Display Error and Potentially Resend]\n    VerifyEmailToken -- Valid Token --> ActivateAccount\n    ActivateAccount[Activate Account] --> RegistrationComplete\n    RegistrationComplete[Registration Complete] --> End\n\n    style Start fill:#90EE90,stroke:#333,stroke-width:2px\n    style End fill:#F08080,stroke:#333,stroke-width:2px\n    style InputUserDetails fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style ValidateInput fill:#FFFFE0,stroke:#333,stroke-width:2px\n    style CheckEmailUniqueness fill:#FFFFE0,stroke:#333,stroke-width:2px\n    style CreateUserAccount fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style SendVerificationEmail fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style UserVerifiesEmail fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style VerifyEmailToken fill:#FFFFE0,stroke:#333,stroke-width:2px\n    style ActivateAccount fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style RegistrationComplete fill:#ADD8E6,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram that illustrates a simplified state machine for a mobile payment system.",
        "planning": "*   **States:**\n    *   Idle: Initial state, waiting for user input.\n    *   Authentication: Verifying user identity (e.g., PIN, biometrics).\n    *   Payment Selection: User chooses payment method (e.g., card, wallet balance).\n    *   Authorization: Contacting payment processor for approval.\n    *   Processing: Communicating with bank/payment network.\n    *   Success: Payment completed successfully.\n    *   Failure: Payment failed.\n\n*   **Transitions/Interactions:**\n    *   Idle -> Authentication: User initiates payment.\n    *   Authentication -> Payment Selection: Successful authentication.\n    *   Authentication -> Failure: Authentication failed (multiple attempts).\n    *   Payment Selection -> Authorization: User selects payment method.\n    *   Authorization -> Processing: Payment details sent for authorization.\n    *   Authorization -> Failure: Insufficient funds/invalid payment method.\n    *   Processing -> Success: Payment authorized and processed.\n    *   Processing -> Failure: Transaction declined by payment network.\n    *   Success -> Idle: System returns to idle state.\n    *   Failure -> Idle: System returns to idle state.",
        "output": "flowchart TD\n    Idle -- User initiates payment --> Authentication\n    Authentication -- Successful authentication --> Payment_Selection\n    Authentication -- Authentication failed --> Failure\n    Payment_Selection -- User selects payment method --> Authorization\n    Authorization -- Payment details sent --> Processing\n    Authorization -- Insufficient funds/Invalid payment method --> Failure\n    Processing -- Payment authorized --> Success\n    Processing -- Transaction declined --> Failure\n    Success -- Payment completed --> Idle\n    Failure -- System returns to idle state --> Idle\n\n    style Idle fill:#f9f,stroke:#333,stroke-width:2px\n    style Authentication fill:#ccf,stroke:#333,stroke-width:2px\n    style Payment_Selection fill:#ccf,stroke:#333,stroke-width:2px\n    style Authorization fill:#ccf,stroke:#333,stroke-width:2px\n    style Processing fill:#ccf,stroke:#333,stroke-width:2px\n    style Success fill:#9f9,stroke:#333,stroke-width:2px\n    style Failure fill:#f66,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram outlining the steps of packet analysis in a cybersecurity monitoring tool.",
        "planning": "*   **Start:** Beginning of the packet analysis process.\n*   **Packet Capture:** Capturing network traffic using tools like tcpdump or Wireshark. (Input: Network traffic; Output: Captured Packets)\n*   **Packet Filtering:** Applying filters to reduce the volume of packets for analysis. (Input: Captured Packets; Output: Filtered Packets)\n*   **Packet Decoding/Parsing:** Breaking down packet structure (headers, payload). (Input: Filtered Packets; Output: Decoded Packet Data)\n*   **Protocol Analysis:** Identifying the protocol and its characteristics (HTTP, DNS, etc.). (Input: Decoded Packet Data; Output: Protocol Information)\n*   **Anomaly Detection:** Identifying unusual patterns or deviations from normal behavior. (Input: Protocol Information; Output: Anomaly Flag)\n*   **Content Inspection:** Examining the packet payload for malicious content (malware signatures, suspicious URLs). (Input: Decoded Packet Data; Output: Malware/Threat Detection)\n*   **Alert Generation:** Triggering alerts based on detected anomalies or threats. (Input: Anomaly Flag/Malware Detection; Output: Security Alert)\n*   **Logging/Reporting:** Recording analysis results and generating reports. (Input: Protocol Information, Anomaly Flag, Malware Detection; Output: Logs/Reports)\n*   **End:** Completion of the packet analysis process.",
        "output": "flowchart TD\n    Start --> A[Packet Capture] \n    A --> B[Packet Filtering]\n    B --> C[Packet Decoding / Parsing]\n    C --> D[Protocol Analysis]\n    D --> E{Anomaly Detection}\n    E -- Yes --> F[Alert Generation]\n    E -- No --> G[Content Inspection]\n    G -- Malware Detected --> F\n    G -- No Malware --> H[Logging / Reporting]\n    F --> H\n    H --> End\n    \n    style Start fill:#90EE90,stroke:#333,stroke-width:2px\n    style End fill:#F08080,stroke:#333,stroke-width:2px\n    style A fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style B fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style C fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style D fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style E fill:#FFDAB9,stroke:#333,stroke-width:2px\n    style F fill:#FFFFE0,stroke:#333,stroke-width:2px\n    style G fill:#ADD8E6,stroke:#333,stroke-width:2px\n    style H fill:#ADD8E6,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "flowchart",
        "prompt": "Generate a flowchart diagram for the flow of operations in a simple blockchain transaction verification process.",
        "planning": "*   **Start:** Initiates the transaction process.\n*   **Create Transaction:** User creates a transaction request (e.g., sending cryptocurrency). Input: sender, receiver, amount, fee.\n*   **Sign Transaction:** Sender uses their private key to digitally sign the transaction.\n*   **Broadcast Transaction:** Transaction is sent to the blockchain network (nodes/peers).\n*   **Validate Transaction:** Nodes verify the transaction's signature, sender's balance, and transaction format.\n*   **Add to Mempool:** Validated transaction is added to the mempool (a waiting area for unconfirmed transactions).\n*   **Select Transactions:** Miners/Validators select transactions from the mempool.\n*   **Create Block:** Selected transactions are grouped into a new block, along with a hash of the previous block and other metadata.\n*   **Mine/Validate Block:** Miners/Validators compete to solve a cryptographic puzzle (Proof-of-Work) or validate based on other consensus mechanisms (Proof-of-Stake).\n*   **Broadcast Block:** Newly mined/validated block is broadcast to the network.\n*   **Verify Block:** Other nodes verify the validity of the block (transaction validity, hash validity, consensus rules).\n*   **Add Block to Blockchain:** Verified block is added to the blockchain, becoming part of the permanent, immutable record.\n*   **Transaction Confirmed:** The transaction is considered confirmed after a certain number of blocks have been added on top of the block containing the transaction.\n*   **End:** Transaction process complete.",
        "output": "flowchart TD\n    A[Start] --> B{Create Transaction\n    Sender, Receiver,\n    Amount, Fee}\n    B --> C{Sign Transaction\n    with Private Key}\n    C --> D[Broadcast Transaction\n    to Network]\n    D --> E{Validate Transaction\n    Signature, Balance,\n    Format}\n    E --> F[Add to Mempool\n    Unconfirmed Transactions]\n    F --> G{Select Transactions\n    Miners/Validators}\n    G --> H[Create Block\n    Hash of Prev Block,\n    Metadata]\n    H --> I{Mine/Validate Block\n    PoW or PoS}\n    I --> J[Broadcast Block\n    to Network]\n    J --> K{Verify Block\n    Transaction Validity,\n    Hash Validity,\n    Consensus Rules}\n    K --> L[Add Block to Blockchain\n    Permanent Record]\n    L --> M[Transaction Confirmed\n    Blocks Added]\n    M --> N[End]"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram illustrating the development sprint for a simple E-commerce website, detailing phases like planning, design, development, testing, and deployment.",
        "planning": "**Components:**\n\n*   **Tasks:**\n    *   Planning\n    *   Design\n    *   Development\n    *   Testing\n    *   Deployment\n\n*   **Timeline:**\n    *   Start Date (Sprint Start)\n    *   End Date (Sprint End)\n    *   Duration of each task (e.g., in days)\n\n*   **Dependencies:**\n    *   Design depends on Planning.\n    *   Development depends on Design.\n    *   Testing depends on Development.\n    *   Deployment depends on Testing.\n\n*   **Resources (Optional):**\n    *   Assigned team members to each task (e.g., Designer, Developer, Tester)\n\n**Interactions:**\n\n*   Tasks are sequentially linked via dependencies. One task must largely finish before the next can meaningfully begin.\n*   Timeline dictates start/end and overlap (if any) between tasks.\n*   Resources work on assigned tasks within the defined timelines.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    \n    section Sprint Planning\n    Planning    :p1, 2024-07-01, 7d\n    \n    section Design Phase\n    Design      :d1, after p1, 7d\n    \n    section Development Stage\n    Development :dev1, after d1, 14d\n    \n    section Testing and QA\n    Testing     :t1, after dev1, 7d\n    \n    section Deployment\n    Deployment  :deploy1, after t1, 3d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram showing the timeline for implementing a RAG-based recommendation system, including data collection, model training, evaluation, and integration.",
        "planning": "**Components:**\n\n*   **Data Collection:** Gathering and preparing data for the RAG system.\n    *   *Interaction:* Feeds directly into Data Preprocessing.\n*   **Data Preprocessing:** Cleaning, transforming, and indexing the collected data.\n    *   *Interaction:* Prepares the data for the Retriever and Knowledge Base.\n*   **Retriever Training/Selection:** Training or choosing a retriever model (e.g., embedding model).\n    *   *Interaction:* Requires preprocessed data and feeds into the RAG pipeline.\n*   **Knowledge Base Creation:** Building the vector store/index for the retrieved data.\n    *   *Interaction:* Uses preprocessed data; accessed by the Retriever.\n*   **Generator Training/Fine-tuning:** Training or fine-tuning the generator model (LLM).\n    *   *Interaction:* Requires training data (can be separate from retriever data or augmented).\n*   **RAG Pipeline Integration:** Combining the retriever and generator into a single pipeline.\n    *   *Interaction:* Connects the Retriever, Knowledge Base, and Generator.\n*   **Evaluation:** Assessing the performance of the RAG system.\n    *   *Interaction:* Provides feedback for model tuning/iteration on all components.\n*   **Deployment:** Deploying the RAG system for real-world use.\n    *   *Interaction:* The final step after successful evaluation.",
        "output": "gantt\n  dateFormat  YYYY-MM-DD\n  axisFormat  YYYY-MM-DD\n  section Data\n    Data Collection       :dc, 2024-01-01, 14d\n    Data Preprocessing    :dp, after dc, 14d\n  section Retriever\n    Retriever Training    :rt, after dp, 14d\n    Knowledge Base Creation :kb, after dp, 14d\n  section Generator\n    Generator Training    :gt, 2024-01-15, 21d\n  section Integration\n    RAG Integration       :ri, after rt, 14d\n  section Evaluation\n    Evaluation            :ev, after ri, 14d\n  section Deployment\n    Deployment            :de, after ev, 7d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for a chat application's project timeline covering front-end development, back-end services, integration, and quality assurance.",
        "planning": "**Gantt Diagram Plan for Chat Application Development**\n\n**Components:**\n\n*   **Project Initiation & Planning:** Define scope, requirements, resources, and timeline.\n*   **Front-End Development:** UI design, component development, user interaction logic.\n*   **Back-End Services:** Database setup, API development (authentication, messaging, user management), server deployment.\n*   **Integration:** Connecting front-end with back-end APIs, data flow implementation.\n*   **Quality Assurance (QA):** Testing functionality, performance, security, usability; bug fixing.\n*   **Deployment:** Releasing the application to production environment.\n\n**Interactions & Dependencies:**\n\n1.  **Project Initiation & Planning** precedes all other tasks.\n2.  **Front-End Development** and **Back-End Services** can run concurrently after planning, but back-end needs to be sufficiently developed for front-end to connect to APIs.\n3.  **Integration** starts after significant progress in both Front-End and Back-End. It depends on finalized APIs from Back-End and functional components from Front-End.\n4.  **Quality Assurance (QA)** runs throughout the project, with increased intensity after Integration. QA provides feedback to both Front-End and Back-End for bug fixes.\n5.  **Deployment** occurs after successful QA and completion of all other tasks.\n\n**Key Elements to Show on Gantt Chart:**\n\n*   Task Name\n*   Start Date\n*   End Date\n*   Duration\n*   Dependencies (using arrows to indicate which task must complete before another starts)\n*   Milestones (e.g., \"API Completion\", \"Beta Release\")",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes    weekends\n\n    section Project\n    Planning              :proj_plan, 2024-07-01, 7d\n\n    section Development\n    Front-End             :frontend, after proj_plan, 21d\n    Back-End              :backend, after proj_plan, 28d\n\n    section Integration & QA\n    API Completion        :milestone, api_complete, after backend, 0d\n    Integration           :integration, after api_complete, 14d\n    Quality Assurance     :qa, after integration, 21d\n    Beta Release          :milestone, beta_release, after qa, 0d\n\n    section Deployment\n    Deployment            :deployment, after beta_release, 7d\n\n\n    section Legend\n    Planning           :done, l1, 2024-10-01, 1d\n    Development         :active, l2, 2024-10-01, 1d\n    Integration & QA    :crit, l3, 2024-10-01, 1d\n    Deployment         :l4, 2024-10-01, 1d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for the stages involved in establishing a TCP connection state machine, indicating initial handshake, data transmission, and connection termination phases.",
        "planning": "*   **Components:** Client, Server.\n*   **Initial Handshake (3-way handshake):**\n    *   Client sends SYN (Synchronization) to Server. (Client active, Server listening)\n    *   Server responds with SYN-ACK (Synchronization-Acknowledgment) to Client. (Server acknowledges and prepares)\n    *   Client sends ACK (Acknowledgment) to Server. (Client confirms and connection established)\n*   **Data Transmission:**\n    *   Client sends DATA to Server.\n    *   Server sends ACK for DATA to Client.\n    *   (Repeated bi-directionally).\n*   **Connection Termination (4-way handshake):**\n    *   Client sends FIN (Finish) to Server. (Client initiates close)\n    *   Server sends ACK for FIN to Client. (Server acknowledges close request)\n    *   Server sends FIN to Client. (Server also initiates close)\n    *   Client sends ACK for FIN to Server. (Client confirms complete close, connection terminated)",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    axisFormat  YYYY-MM-DD\n    \n    section Initial Handshake\n    Client SYN    :client_syn, 2024-01-01, 1d\n    Server SYN-ACK :after client_syn, 2024-01-02, 1d\n    Client ACK    :after 2024-01-02, 2024-01-03, 1d\n    \n    section Data Transmission\n    Client DATA   :client_data, after 2024-01-03, 2d\n    Server ACK DATA:after client_data, 2024-01-05, 1d\n    Server DATA   :server_data, after 2024-01-05, 2d\n    Client ACK DATA:after server_data, 2024-01-07, 1d\n    \n    section Connection Termination\n    Client FIN    :client_fin, after 2024-01-07, 1d\n    Server ACK FIN :after client_fin, 2024-01-08, 1d\n    Server FIN    :server_fin, after 2024-01-08, 1d\n    Client ACK FIN :after server_fin, 2024-01-09, 1d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram outlining the tasks in an RSA cryptography process, from key generation to encryption and decryption phases.",
        "planning": "**I. Key Generation:**\n\n*   **Prime Number Generation:** Select two large prime numbers, p and q. (No direct interactions at this stage).\n*   **Calculate n (Modulus):** Multiply p and q to get n. (Input: p, q; Output: n).\n*   **Calculate \u03c6(n) (Totient):** Calculate Euler's totient, \u03c6(n) = (p-1)(q-1). (Input: p, q; Output: \u03c6(n)).\n*   **Choose e (Public Exponent):** Select an integer e such that 1 < e < \u03c6(n) and gcd(e, \u03c6(n)) = 1. (Input: \u03c6(n); Output: e).\n*   **Calculate d (Private Exponent):** Compute the modular multiplicative inverse of e modulo \u03c6(n), i.e., d \u2261 e^(-1) (mod \u03c6(n)). (Input: e, \u03c6(n); Output: d).\n*   **Public Key Publication:** Publish (n, e) as the public key. (Output: Public Key).\n*   **Private Key Storage:** Securely store (n, d) as the private key. (Output: Private Key).\n\n**II. Encryption:**\n\n*   **Obtain Public Key:** Retrieve the recipient's public key (n, e). (Input: Public Key (n,e)).\n*   **Message Preparation:** Prepare the message to be encrypted (e.g., convert to numerical representation). (No direct interactions at this stage).\n*   **Encryption Process:** Compute ciphertext c = m^e mod n, where m is the message. (Input: Message, Public Key (n, e); Output: Ciphertext).\n*   **Ciphertext Transmission:** Send the ciphertext to the recipient. (Output: Ciphertext).\n\n**III. Decryption:**\n\n*   **Obtain Private Key:** Retrieve the private key (n, d). (Input: Private Key (n,d)).\n*   **Ciphertext Reception:** Receive the ciphertext c. (Input: Ciphertext).\n*   **Decryption Process:** Compute the original message m = c^d mod n. (Input: Ciphertext, Private Key (n, d); Output: Message).\n*   **Message Recovery:** Recover the original message from the decrypted numerical representation. (No direct interactions at this stage).",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes weekends\n\n    section Key Generation\n    Prime Gen   :kg1, 2024-01-01, 5d\n    Calculate N :after kg1, 3d\n    Calculate Totient :after Calculate N, 3d\n    Choose E    :after Calculate Totient, 3d\n    Calculate D :after Choose E, 5d\n    Public Key  :after Calculate D, 1d\n    Private Key :after Public Key, 1d\n\n    section Encryption\n    Obtain Public   :ob1, after Private Key, 2d\n    Message Prep    :after ob1, 1d\n    Encryption Proc :after Message Prep, 5d\n    Transmit Cipher :after Encryption Proc, 1d\n\n    section Decryption\n    Obtain Private  :dec1, after Transmit Cipher, 2d\n    Receive Cipher  :after dec1, 1d\n    Decryption Proc :after Receive Cipher, 5d\n    Message Recov   :after Decryption Proc, 1d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram illustrating the sequential steps of the OAuth authentication protocol, covering user authorization, token issuance, and validation.",
        "planning": "**Components:**\n\n*   **User:** End-user attempting to access protected resources.\n*   **Client Application:** Application requesting access on behalf of the user (e.g., a mobile app).\n*   **Authorization Server:** Issues access tokens after user authorization.\n*   **Resource Server:** Hosts the protected resources.\n\n**Sequential Steps & Interactions:**\n\n1.  **Authorization Request:** Client Application requests authorization from the Authorization Server (through the User).\n2.  **User Authorization:** User authenticates with and grants permission to the Client Application at the Authorization Server.\n3.  **Authorization Code Issuance:** Authorization Server issues an authorization code to the Client Application.\n4.  **Access Token Request:** Client Application exchanges the authorization code for an access token from the Authorization Server.\n5.  **Access Token Issuance:** Authorization Server issues an access token and (optionally) a refresh token to the Client Application.\n6.  **Resource Request:** Client Application requests the protected resource from the Resource Server, presenting the access token.\n7.  **Token Validation:** Resource Server validates the access token with the Authorization Server (or locally if configured).\n8.  **Resource Grant:** Resource Server grants access to the protected resource if the token is valid.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    axisFormat  YYYY-MM-DD\n    \n    section OAuth Authentication\n    Auth Request            :req, 2024-01-01, 1d\n    User Auth               :auth, after req, 2d\n    Code Issuance           :code, after auth, 1d\n    Token Request           :tok_req, after code, 1d\n    Token Issuance          :tok_iss, after tok_req, 2d\n    Resource Request        :res_req, after tok_iss, 1d\n    Token Validation        :val, after res_req, 2d\n    Resource Grant          :grant, after val, 1d\n\n    section Components\n    User                    :user, 2024-01-01, 1d\n    Client App              :client, 2024-01-01, 1d\n    Auth Server             :auth_serv, 2024-01-01, 1d\n    Resource Server         :res_serv, 2024-01-01, 1d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram showcasing the phases of blockchain transaction verification, including transaction broadcasting, mining, and block confirmation.",
        "planning": "**Gantt Diagram Plan: Blockchain Transaction Verification**\n\n1.  **Transaction Broadcasting:**\n    *   Initiation: User submits transaction.\n    *   Propagation: Transaction propagates through the network.\n    *   Interaction: User initiates, network nodes receive and relay.\n\n2.  **Mining:**\n    *   Transaction Selection: Miners select transactions.\n    *   Block Creation: Miners create a candidate block.\n    *   Proof-of-Work/Stake: Miners solve the cryptographic puzzle/stake coins.\n    *   Interaction: Miners compete to validate transactions and create blocks. Depends on broadcasted transactions.\n\n3.  **Block Confirmation:**\n    *   Block Validation: Other nodes validate the new block.\n    *   Block Addition: Block added to the blockchain.\n    *   Confirmation Count: Transaction gains confirmations as more blocks are added.\n    *   Interaction: Nodes verify block validity, strengthening the blockchain.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    axisFormat  %Y-%m-%d\n    \n    section Transaction Broadcasting\n    Initiation          :2024-01-01, 1d\n    Propagation         :after Initiation, 2d\n    \n    section Mining\n    Transaction Selection :after Propagation, 1d\n    Block Creation        :after Transaction Selection, 2d\n    Proof-of-Work       :after Block Creation, 3d\n    \n    section Block Confirmation\n    Block Validation      :after Proof-of-Work, 2d\n    Block Addition        :after Block Validation, 1d\n    Confirmation Count    :after Block Addition, 4d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for the development timeline of an online learning platform, detailing module creation, user interface design, backend integration, and testing.",
        "planning": "**Components:**\n\n*   **Module Creation:**\n    *   Interaction: Provides content for the platform, relies on UI design for display guidelines.\n\n*   **User Interface (UI) Design:**\n    *   Interaction: Defines user experience, informs module creation display, interacts with backend for data presentation.\n\n*   **Backend Integration:**\n    *   Interaction: Connects UI to data, enables user authentication, supports module delivery.\n\n*   **Testing:**\n    *   Interaction: Validates all components, provides feedback to module creation, UI design, and backend integration for bug fixes.\n\n**Interactions:**\n\n*   UI Design should precede or run concurrently with Module Creation.\n*   Backend Integration can start after initial UI design is ready.\n*   Testing should occur after substantial progress in Module Creation, UI Design, and Backend Integration.\n*   All components might need iterative adjustments based on Testing feedback.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes weekends\n\n    section Planning\n    UI Design           :uiDesign, 2024-01-01, 30d\n\n    section Development\n    Module Creation     :moduleCreation, 2024-01-01, 40d\n    Backend Integration :backend, after uiDesign, 35d\n\n    section Testing\n    Initial Testing     :testing1, after moduleCreation, 15d\n    Bug Fixes UI        :fixUI, after testing1, 5d\n    Bug Fixes Backend   :fixBackend, after testing1, 5d\n    Final Testing       :testing2, after fixUI, 10d\n\n    section Deployment\n    Platform Deployment :deploy, after testing2, 5d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for the deployment plan of a cloud-based document editor, including stages such as infrastructure setup, software installation, user training, and maintenance.",
        "planning": "**Gantt Diagram Components & Interactions:**\n\n*   **Tasks:** Infrastructure Setup, Software Installation, User Training, Maintenance.\n*   **Start & End Dates:** Each task has a defined start and end date based on dependencies and estimated duration.\n*   **Duration:** Time allocated to each task (e.g., days, weeks).\n*   **Dependencies:** Define the order of tasks (e.g., Software Installation depends on Infrastructure Setup).\n*   **Milestones:** Significant progress points (e.g., \"Infrastructure Ready,\" \"Software Installed,\" \"Training Complete\").\n*   **Resources:** (Optional) Assign resources to each task (e.g., DevOps team, training team).\n\n**Interactions:**\n\n*   Infrastructure Setup completes *before* Software Installation can begin.\n*   Software Installation completes *before* User Training can start.\n*   Maintenance is *ongoing* and starts after Software Installation.\n*   Milestones act as checkpoints, showing progress and indicating task completion.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    \n    section Project Stages\n    Infrastructure Setup   :infra   2024-01-01  14d\n    Software Installation  :soft   after infra  7d\n    User Training          :train  after soft   10d\n    Maintenance            :active maint   after soft   30d\n\n    section Milestones\n    Infra Ready            :milestone  m1  2024-01-15  0d\n    Software Installed     :milestone  m2  2024-01-22  0d\n    Training Complete      :milestone  m3  2024-02-01  0d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram representing the phases in designing a simple microservices architecture, including service design, implementation, testing, and deployment.",
        "planning": "*   **Service Design:**\n    *   Tasks: Identify services, define APIs, data models, communication patterns.\n    *   Dependencies: None (first step).\n    *   Output: Service contracts/specifications.\n*   **Implementation:**\n    *   Tasks: Code services, build Docker images.\n    *   Dependencies: Service Design (API definitions).\n    *   Output: Deployable service artifacts (Docker images).\n*   **Testing:**\n    *   Tasks: Unit tests, integration tests, end-to-end tests.\n    *   Dependencies: Implementation (completed service builds).\n    *   Output: Test results, bug reports.\n*   **Deployment:**\n    *   Tasks: Provision infrastructure, deploy services to environment.\n    *   Dependencies: Implementation (Docker images), Testing (passed tests).\n    *   Output: Running microservices architecture.\n*   **Interaction:** Sequential flow with potential iterations. Testing may reveal need to revisit Implementation or Design.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    \n    section Service_Design\n    Identify_services : SD1, 2024-01-01, 7d\n    Define_APIs       : SD2, after SD1, 7d\n    Data_models       : SD3, after SD2, 7d\n    Communication_patterns : SD4, after SD3, 7d\n    \n    section Implementation\n    Code_services     : IMP1, after SD4, 14d\n    Build_Docker_images : IMP2, after IMP1, 7d\n    \n    section Testing\n    Unit_tests        : UT, after IMP2, 7d\n    Integration_tests : IT, after UT, 7d\n    End_to_end_tests  : E2E, after IT, 7d\n    \n    section Deployment\n    Provision_infrastructure : PI, after E2E, 7d\n    Deploy_services_to_environment : DP, after PI, 7d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram illustrating the development process of a photo-sharing mobile application, covering interface design, backend services, API integration, and launch.",
        "planning": "**Components:**\n\n*   **Interface Design:**\n    *   Tasks: Wireframing, Mockup Design, UI Development, User Testing.\n    *   Interaction: Feeds into UI Development, user testing informs redesign.\n\n*   **Backend Services:**\n    *   Tasks: Database Design, Server Setup, API Development, Authentication Implementation, Storage Integration.\n    *   Interaction: Supports API integration, interacts with database, user data storage.\n\n*   **API Integration:**\n    *   Tasks: API Design, Development, Testing, Documentation.\n    *   Interaction: Connects frontend (Interface) to backend, provides data exchange, relies on backend services.\n\n*   **Launch:**\n    *   Tasks: Beta Testing, Bug Fixing, App Store Submission, Marketing, Deployment.\n    *   Interaction: Relies on all prior components, feedback loops to bug fixing.\n\n**Interactions:**\n\n*   Interface design informs API requirements (what data is needed).\n*   Backend services provide the foundation for API functionality.\n*   API integration allows the interface to interact with the backend data.\n*   User Testing on the Interface Design may require adjustments to the Backend Services or API.\n*   Launch is the culmination of all previous components being completed.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes    weekends\n\n    section Interface Design\n        Wireframing        :id1, 2024-01-01, 10d\n        Mockup Design      :id2, after id1, 15d\n        UI Development     :id3, after id2, 20d\n        User Testing       :id4, after id3, 10d\n\n    section Backend Services\n        Database Design      :id5, 2024-01-01, 15d\n        Server Setup         :id6, after id5, 10d\n        API Development      :id7, after id6, 20d\n        Authentication     :id8, after id7, 10d\n        Storage Integration  :id9, after id8, 15d\n\n    section API Integration\n        API Design           :id10, 2024-01-15, 10d\n        Development          :id11, after id10, 20d\n        Testing              :id12, after id11, 10d\n        Documentation        :id13, after id12, 15d\n\n    section Launch\n        Beta Testing         :id14, 2024-04-01, 15d\n        Bug Fixing           :id15, after id14, 10d\n        App Store Submission :id16, after id15, 5d\n        Marketing            :id17, 2024-03-15, 30d\n        Deployment           :id18, after id16, 5d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for a weather forecasting application project, including data acquisition, model training, deployment, and monitoring phases.",
        "planning": "**Gantt Diagram Components and Interactions Plan**\n\n**1. Data Acquisition:**\n\n*   **Activities:** Data Source Identification, Data Collection Setup, Data Storage Implementation, Data Validation.\n*   **Input:** Project Requirements (specifying data needs).\n*   **Output:** Clean, stored weather data.\n*   **Interaction:** Feeds into Model Training.\n\n**2. Model Training:**\n\n*   **Activities:** Algorithm Selection, Feature Engineering, Model Training, Model Evaluation, Hyperparameter Tuning.\n*   **Input:** Clean weather data from Data Acquisition.\n*   **Output:** Trained weather forecasting model.\n*   **Interaction:** Receives data from Data Acquisition, feeds into Deployment.\n\n**3. Deployment:**\n\n*   **Activities:** Infrastructure Setup, Model Packaging, API Development, Testing, Deployment to Production.\n*   **Input:** Trained weather forecasting model from Model Training.\n*   **Output:** Live, operational weather forecasting application.\n*   **Interaction:** Receives model from Model Training, feeds data to Monitoring, interacts with end-users.\n\n**4. Monitoring:**\n\n*   **Activities:** Performance Monitoring, Error Tracking, Log Analysis, Alerting, Retraining Trigger.\n*   **Input:** Data from the deployed weather forecasting application.\n*   **Output:** Performance metrics, error reports, alerts.\n*   **Interaction:** Receives data from Deployment, may trigger Model Retraining (loop back to Model Training).",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes    weekends\n\n    section Data Acquisition\n    Data Source Identification   : da1, 2024-01-01, 10d\n    Data Collection Setup       : da2, after da1, 15d\n    Data Storage Implementation : da3, after da2, 12d\n    Data Validation             : da4, after da3, 8d\n\n    section Model Training\n    Algorithm Selection       : mt1, after da4, 7d\n    Feature Engineering       : mt2, after mt1, 14d\n    Model Training            : mt3, after mt2, 21d\n    Model Evaluation          : mt4, after mt3, 10d\n    Hyperparameter Tuning     : mt5, after mt4, 14d\n\n    section Deployment\n    Infrastructure Setup    : de1, after mt5, 10d\n    Model Packaging         : de2, after de1, 7d\n    API Development         : de3, after de2, 14d\n    Testing                 : de4, after de3, 7d\n    Deployment to Production: de5, after de4, 3d\n\n    section Monitoring\n    Performance Monitoring : mo1, after de5, 30d\n    Error Tracking         : mo2, after de5, 30d\n    Log Analysis           : mo3, after de5, 30d\n    Alerting               : mo4, after de5, 30d\n    Retraining Trigger     : mo5, after de5, 30d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for the development of a recommendation engine for a streaming service, outlining tasks such as data preprocessing, algorithm development, user testing, and refinement.",
        "planning": "*   **Tasks:** Define specific tasks (Data Collection, Data Preprocessing, Algorithm Selection, Algorithm Development, User Interface Design, User Testing, Model Training, Model Evaluation, Refinement, Deployment).\n\n*   **Start and End Dates:** Each task has a defined start and end date, determining its duration.\n\n*   **Dependencies:** Some tasks depend on the completion of others (e.g., Algorithm Development depends on Data Preprocessing). Show these dependencies with arrows.\n\n*   **Resources:** Indicate who is responsible for each task (e.g., Data Scientist, Engineer, UI/UX Designer).\n\n*   **Milestones:** Mark significant points in the project (e.g., \"Algorithm Prototype Complete,\" \"User Testing Started,\" \"Deployment Ready\").\n\n*   **Progress:** Indicate the percentage completion of each task (e.g., using shading or color-coding).\n\n*   **Timeline:** A horizontal axis representing the project's duration (e.g., weeks or months).\n\n**Interactions:**\n\n*   Tasks are linked by dependencies, where the end of one task triggers the start of another.\n*   Resources are allocated to specific tasks for their duration.\n*   Progress on tasks impacts the overall project timeline.\n*   Milestones represent key achievements that can affect subsequent tasks.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    %%excludes   weekends\n\n    section Data\n    Data Collection      :data_coll, 2024-01-01, 7d\n    Data Preprocessing   :data_prep, after data_coll, 10d\n\n    section Algorithm\n    Algorithm Selection  :algo_select, after data_prep, 5d\n    Algorithm Development:algo_dev, after algo_select, 15d\n    Model Training       :model_train, after algo_dev, 14d\n    Model Evaluation     :model_eval, after model_train, 7d\n\n    section User Interface\n    User Interface Design:ui_design, after data_prep, 12d\n    User Testing         :user_test, after ui_design, 10d\n\n    section Refinement & Deployment\n    Refinement           :refine, after model_eval, 7d\n    Deployment           :deploy, after refine, 5d\n\n    section Milestones\n    Algorithm Prototype Complete:milestone, algo_proto, 2024-02-06, 0d\n    User Testing Started       :milestone, user_test_start, 2024-02-22, 0d\n    Deployment Ready           :milestone, deploy_ready, 2024-03-15, 0d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for the project schedule of a food delivery app, including phases like market research, app design, development, testing, and rollout.",
        "planning": "**Gantt Chart Components & Interactions Plan:**\n\n1.  **Tasks/Activities:**\n    *   Market Research: Define target audience, competitor analysis.\n    *   App Design: UI/UX design, wireframing.\n    *   Development: Backend, Frontend, API integration.\n    *   Testing: Unit, Integration, User Acceptance Testing (UAT).\n    *   Rollout: Beta testing, initial launch, marketing, scaling.\n\n2.  **Timeline:**\n    *   Horizontal axis representing time (days, weeks, months).\n    *   Start and end dates for each task, displayed as bars.\n\n3.  **Dependencies:**\n    *   Relationships between tasks. (e.g., App Design must precede Development)\n    *   Use arrows to show dependencies.\n\n4.  **Resources:**\n    *   Assigned teams or individuals to each task (optional, but helpful).\n\n5.  **Milestones:**\n    *   Significant achievements, like \"Design Complete\" or \"Beta Launch.\"\n\n6.  **Overlapping Activities:**\n    *   Show tasks that can occur concurrently (e.g., parts of backend and frontend development)\n\n7. **Progress Tracking:**\n   *   Indicate the percentage of each task that has been completed.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    axisFormat  %Y-%m-%d\n    \n    section Market Research\n    Define Target Audience :mr1, 2024-01-01, 14d\n    Competitor Analysis    :mr2, after mr1, 14d\n    \n    section App Design\n    UI UX Design          :ad1, after mr2, 21d\n    Wireframing             :ad2, after ad1, 14d\n    \n    section Development\n    Backend Development     :dev1, after ad2, 28d\n    Frontend Development    :dev2, after ad2, 28d\n    API Integration         :dev3, after dev1, 21d\n    \n    section Testing\n    Unit Testing            :test1, after dev3, 14d\n    Integration Testing     :test2, after test1, 14d\n    User Acceptance Testing :test3, after test2, 14d\n    \n    section Rollout\n    Beta Testing            :roll1, after test3, 21d\n    Initial Launch          :roll2, after roll1, 14d\n    Marketing               :roll3, after roll2, 21d\n    Scaling                 :roll4, after roll3, 28d\n    \n    section Milestones\n    Design Complete         :milestone, design_complete, 2024-02-23, 0d\n    Beta Launch             :milestone, beta_launch, 2024-06-14, 0d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram depicting the stages of developing an academic course management system, covering requirements analysis, design, coding, and deployment.",
        "planning": "**Components:**\n\n*   **Requirements Analysis:**\n    *   Activities: Gathering requirements, documenting needs, defining scope.\n    *   Output: Requirements document.\n*   **Design:**\n    *   Activities: System architecture, database design, UI/UX design.\n    *   Input: Requirements document.\n    *   Output: Design specifications.\n*   **Coding:**\n    *   Activities: Front-end development, back-end development, API integration.\n    *   Input: Design specifications.\n    *   Output: Functional system code.\n*   **Deployment:**\n    *   Activities: Testing, server setup, data migration, user training.\n    *   Input: Functional system code.\n    *   Output: Live, functional course management system.\n\n**Interactions:**\n\n*   Requirements Analysis feeds into Design.\n*   Design feeds into Coding.\n*   Coding feeds into Deployment.\n*   Testing in Deployment might reveal bugs requiring revisiting Coding or Design.\n*   User feedback after Deployment may necessitate future Requirements Analysis and iterative improvements.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes weekends\n\n    section Requirements Analysis\n    Gather Requirements :req1, 2024-01-01, 7d\n    Document Needs    :req2, after req1, 5d\n    Define Scope        :req3, after req2, 5d\n\n    section Design\n    System Architecture  :des1, after req3, 10d\n    Database Design      :des2, after des1, 7d\n    UI-UX Design         :des3, after des2, 7d\n\n    section Coding\n    Front-end Dev        :code1, after des3, 14d\n    Back-end Dev         :code2, after code1, 14d\n    API Integration      :code3, after code2, 7d\n\n    section Deployment\n    Testing              :test, after code3, 7d\n    Server Setup         :server, after test, 3d\n    Data Migration       :migrate, after server, 3d\n    User Training        :train, after migrate, 5d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for the creation of an IoT dashboard, showing tasks like sensor integration, data visualization development, system testing, and deployment.",
        "planning": "**Tasks:**\n\n*   **Sensor Integration:** Connecting sensors, configuring data streams, testing data accuracy. Interacts with Data Visualization Development (provides data).\n*   **Data Visualization Development:** Designing dashboard, creating charts/graphs, implementing user interface. Interacts with Sensor Integration (requires data), System Testing (requires testing).\n*   **System Testing:** Testing entire system (sensors, data flow, visualization), identifying bugs, performance testing. Interacts with Sensor Integration and Data Visualization Development (requires testing these components), Deployment (needs to be completed before deployment).\n*   **Deployment:** Deploying dashboard to production environment, user training, final checks. Requires System Testing to be completed.\n\n**Interactions:**\n\n*   Sensor Integration feeds data to Data Visualization Development.\n*   System Testing relies on both Sensor Integration and Data Visualization Development to test.\n*   Deployment is dependent on successful System Testing.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    \n    section Sensor\n    Sensor_Integration : SI, 2024-01-01, 10d\n    \n    section Data_Viz\n    Data_Visualization : DV, after SI, 15d\n    \n    section Testing\n    System_Testing : ST, after SI, 7d\n    System_Testing : after DV, 7d\n\n    section Deployment\n    Deployment : DP, after ST, 5d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for the project timeline of a network packet tracer simulation tool, detailing protocol design, simulation modeling, user interface development, and testing.",
        "planning": "**Components:**\n\n*   **Protocol Design:** Defining network protocols to be simulated (e.g., TCP, UDP, HTTP).\n*   **Simulation Modeling:** Creating models to represent network devices and data flow based on protocol definitions.\n*   **User Interface (UI) Development:** Building the graphical interface for users to interact with the simulation.\n*   **Testing:** Validating the simulation's accuracy and the UI's usability.\n\n**Interactions (Dependencies):**\n\n*   Protocol Design -> Simulation Modeling: Simulation modeling *depends* on the protocols defined.\n*   Simulation Modeling -> UI Development: UI development *depends* on the backend simulation model.\n*   Protocol Design, Simulation Modeling, UI Development -> Testing: Testing *depends* on the completion of all previous components.\n*   Testing might lead to revisions in Protocol design, Simulation modeling, or UI development, creating feedback loops.",
        "output": "gantt\n  dateFormat  YYYY-MM-DD\n  \n  section Project Start\n  Project Start          :start, 2024-08-05, 0d\n\n  section Protocol Design\n  Define TCP Protocol   :tcp, after start, 10d\n  Define UDP Protocol   :udp, after start, 8d\n  Define HTTP Protocol  :http, after start, 12d\n  Protocol Design Complete :pd_complete, after tcp,udp,http, 0d\n\n  section Simulation Modeling\n  Model TCP Simulation  :model_tcp, after pd_complete, 15d\n  Model UDP Simulation  :model_udp, after pd_complete, 13d\n  Model HTTP Simulation :model_http, after pd_complete, 17d\n  Simulation Model Complete :sm_complete, after model_tcp,model_udp,model_http, 0d\n\n  section UI Development\n  Design UI Elements    :ui_design, after sm_complete, 12d\n  Implement UI Logic   :ui_logic, after ui_design, 15d\n  UI Development Complete :ui_complete, after ui_logic, 0d\n\n  section Testing\n  Simulation Accuracy Testing  :sim_test, after ui_complete, 20d\n  UI Usability Testing        :ui_test, after ui_complete, 15d\n  Final Testing Complete   :test_complete, after sim_test,ui_test, 0d\n\n  section Project End\n  Project Completion       :complete, after test_complete, 0d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram showing the development phases of a cybersecurity threat detection system, including threat analysis, system design, implementation, and validation.",
        "planning": "**Gantt Diagram Components & Interactions Plan**\n\n**Phases:**\n\n*   **Threat Analysis:** (First Phase)\n    *   **Tasks:** Data Collection, Threat Modeling, Risk Assessment.\n    *   **Output:** Threat Landscape Report (input to System Design).\n*   **System Design:** (Second Phase, dependent on Threat Analysis)\n    *   **Tasks:** Architecture Design, Component Selection, Rule Definition.\n    *   **Input:** Threat Landscape Report (from Threat Analysis).\n    *   **Output:** System Design Specification (input to Implementation).\n*   **Implementation:** (Third Phase, dependent on System Design)\n    *   **Tasks:** Code Development, Integration, Configuration.\n    *   **Input:** System Design Specification (from System Design).\n    *   **Output:** Deployed Threat Detection System (input to Validation).\n*   **Validation:** (Fourth Phase, dependent on Implementation)\n    *   **Tasks:** Testing (Unit, Integration, Penetration), Performance Evaluation, Tuning.\n    *   **Input:** Deployed Threat Detection System (from Implementation).\n    *   **Output:** Validation Report (final output).\n\n**Interactions:**\n\n*   Sequential dependencies between phases: Threat Analysis -> System Design -> Implementation -> Validation. Output of each phase becomes input for the next.\n*   Possible feedback loops: Validation phase might reveal issues requiring adjustments in earlier phases (e.g., System Design or Implementation). Indicate iterative refinement.\n* Overlapping: Consider whether certain parts of phases can happen in parallel.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes    weekends\n\n    section Threat Analysis\n    Data Collection  :dc, 2024-01-01, 10d\n    Threat Modeling  :tm, after dc, 10d\n    Risk Assessment  :ra, after tm, 10d\n\n    section System Design\n    Architecture Design :ad, after ra, 15d\n    Component Selection :cs, after ad, 10d\n    Rule Definition     :rd, after cs, 10d\n\n    section Implementation\n    Code Development  :cd, after rd, 20d\n    Integration       :intg, after cd, 15d\n    Configuration     :conf, after intg, 10d\n\n    section Validation\n    Unit Testing        :ut, after conf, 10d\n    Integration Testing :it, after ut, 10d\n    Penetration Testing :pt, after it, 10d\n    Performance Eval    :pe, after pt, 10d\n    Tuning              :tune, after pe, 10d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram for a virtual reality gaming project timeline, outlining concept development, asset creation, system programming, and beta testing.",
        "planning": "**Components:**\n\n*   **Concept Development:**\n    *   **Tasks:** Idea generation, market research, prototype design, documentation.\n    *   **Interaction:** Feeds directly into Asset Creation and System Programming.\n\n*   **Asset Creation:**\n    *   **Tasks:** 3D modeling, texturing, audio design, animation.\n    *   **Interaction:** Requires specifications from Concept Development; assets are integrated into System Programming.\n\n*   **System Programming:**\n    *   **Tasks:** Core mechanics, VR integration, UI/UX design, networking (if multiplayer).\n    *   **Interaction:** Requires input from Concept Development and receives assets from Asset Creation; critical for Beta Testing.\n\n*   **Beta Testing:**\n    *   **Tasks:** Internal testing, external testing, bug reporting, performance optimization.\n    *   **Interaction:** Receives the integrated system from System Programming; provides feedback to System Programming for fixes and improvements.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    \n    section Concept\n    Idea        :id1, 2024-01-01, 30d\n    Market      :id2, after id1, 20d\n    Prototype   :id3, after id2, 25d\n    ConceptDoc  :id4, after id3, 15d\n    \n    section Assets\n    Model       :as1, after id4, 30d\n    Texture     :as2, after as1, 25d\n    Audio       :as3, after as2, 20d\n    Animate     :as4, after as3, 15d\n    \n    section Program\n    Core        :pr1, after id4, 40d\n    VR          :pr2, after pr1, 30d\n    UI          :pr3, after pr2, 20d\n    Network     :pr4, after pr3, 25d\n\n    section Beta\n    Internal    :be1, after pr4, 20d\n    External    :be2, after be1, 30d\n    BugReport   :be3, after be2, 15d\n    Optimize    :be4, after be3, 25d"
    },
    {
        "diagram_type": "gantt",
        "prompt": "Generate a Gantt diagram representing the phases in developing a simple data visualization tool, covering requirements gathering, design, coding, and user feedback integration.",
        "planning": "*   **Requirements Gathering:** Defines project scope.  Feeds into Design.\n*   **Design:** Creates the tool's blueprint. Receives input from Requirements Gathering, provides input to Coding.\n*   **Coding:**  Implements the design. Receives input from Design, provides input to User Feedback Integration.\n*   **User Feedback Integration:** Incorporates user feedback into the tool. Receives input from Coding; might loop back to Design and/or Coding if substantial changes are needed, could affect Requirements if scope changes.",
        "output": "gantt\n    dateFormat  YYYY-MM-DD\n    excludes weekends\n\n    section Phases\n    Requirements Gathering : req, 2024-01-08, 14d\n    Design               : design, after req, 21d\n    Coding               : coding, after design, 35d\n    User Feedback Integration : feedback, after coding, 14d"
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Generate a gitgraph diagram showing the development process for a new feature branch in an E-commerce web application, starting from the main branch and merging back after testing.",
        "planning": "*   **Main Branch:** Represents the stable, production-ready code. Acts as the starting point.\n*   **Feature Branch:** Created from `main` to isolate new feature development. Diverges from `main`.\n*   **Commits on Feature Branch:** Represent incremental changes and development efforts within the feature. They build upon each other.\n*   **Testing:** (Implied) Happens on the feature branch before merging.\n*   **Merge Feature Branch into Main:** Integrates completed and tested feature back into the main codebase.\n*   **Resulting Main Branch:** Reflects the updated codebase with the new feature.",
        "output": "gitGraph\n    commit id: \"Initial Commit on Main\"\n    branch feature_branch\n    checkout feature_branch\n    commit id: \"Feature Development 1\"\n    commit id: \"Feature Development 2\"\n    commit id: \"Feature Complete & Tested\"\n    checkout main\n    merge feature_branch id: \"Merge Feature into Main\"\n    commit id: \"Post-Merge Commit on Main\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Create a gitgraph illustrating a bug-fix branch in a cloud storage system, where a hotfix is developed and merged into the stable release branch.",
        "planning": "*   **Main/Stable Branch:** Represents the production-ready code. Acts as the baseline.\n*   **Development Branch (Optional):** Represents ongoing feature development (optional for bugfix).\n*   **Bug/Hotfix Branch:** Created from the Main branch to address a specific bug. Isolated fix development.\n*   **Commit(s) on Bug/Hotfix Branch:** Represents the code changes to resolve the bug.\n*   **Merge Bug/Hotfix into Main:** Integrating the fix into the stable release. Usually a fast-forward merge or a merge commit.",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch hotfix\n    checkout hotfix\n    commit id: \"Fix Bug in Storage\"\n    checkout main\n    merge hotfix id: \"Merge Hotfix\" tag: \"v1.0.1\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Design a gitgraph diagram that displays the branching strategy for a chat application, including feature branches, bug fixes, and release branches.",
        "planning": "*   **Main Branch (main/master):**\n    *   Represents the production-ready code.\n    *   Source of truth for releases.\n\n*   **Develop Branch:**\n    *   Integration branch for new features.\n    *   Features merged here before release.\n    *   Regularly merged into main.\n\n*   **Feature Branches (feature/X):**\n    *   Branches off `develop`.\n    *   For individual feature development.\n    *   Merged back into `develop` upon completion.\n\n*   **Bugfix Branches (bugfix/Y):**\n    *   Branches off `develop` or `main` (depending on urgency).\n    *   For fixing bugs.\n    *   Merged back into `develop` or `main` (and `develop` if branched from main).\n\n*   **Release Branches (release/Z):**\n    *   Branches off `develop`.\n    *   Prepares for a new release.\n    *   Bug fixes applied here.\n    *   Merged into `main` (tagged with release version) and `develop`.\n\n*   **Tags:**\n    *   On `main`, marking releases.\n\n*   **Interactions:**\n    *   `feature/X` -> `develop` (merge)\n    *   `bugfix/Y` -> `develop` or `main` (merge)\n    *   `release/Z` -> `main` and `develop` (merge)\n    *   `develop` -> `main` (merge, less frequent)",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch develop\n    checkout develop\n    commit id: \"Dev Commit 1\"\n    commit id: \"Dev Commit 2\"\n\n    branch featureA\n    checkout featureA\n    commit id: \"Feature A Commit 1\"\n    commit id: \"Feature A Commit 2\"\n    checkout develop\n    merge featureA id: \"Merge Feature A\"\n\n    branch bugfix1\n    checkout bugfix1\n    commit id: \"Bugfix 1 Commit\"\n    checkout develop\n    merge bugfix1 id: \"Merge Bugfix 1\"\n\n    checkout main\n    commit id: \"Main Commit 1\"\n    checkout develop\n    commit id: \"Dev Commit 3\"\n\n    branch release1\n    checkout release1\n    commit id: \"Release 1 Commit 1\"\n    commit id: \"Release 1 Commit 2\"\n    checkout main\n    merge release1 id: \"Merge Release 1\" tag: \"v1.0.0\"\n    checkout develop\n    merge release1 id: \"Merge Release 1 to Develop\"\n\n    commit id: \"Dev Commit 4\"\n\n    branch featureB\n    checkout featureB\n    commit id: \"Feature B Commit 1\"\n    checkout develop\n    merge featureB id: \"Merge Feature B\"\n\n    checkout main\n    commit id: \"Main Commit 2\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Provide a gitgraph diagram demonstrating the integration of a feature toggle in a data analytics application, including separate branches for development and production.",
        "planning": "*   **Main/Production Branch:** Represents the stable, production-ready code.\n*   **Development Branch:** Where active development and feature toggling implementation occurs.\n*   **Feature Branch (with Toggle):** Represents a branch where a new data analytics feature is developed along with its feature toggle.\n*   **Feature Toggle Implementation:** The code within the feature branch that controls whether the new feature is active or inactive.\n*   **Merge to Development:** Merging the feature branch into the development branch. The feature is deployed with the toggle set to 'off'.\n*   **Toggle Configuration:** Represents the configuration that enables/disables the feature toggle (e.g., environment variable, database setting).\n*   **Testing (on Development):** Tests conducted on the development branch to verify toggle functionality and feature stability.\n*   **Merge to Main/Production (with Toggle):** Merging from the development branch to the main/production branch. The feature remains inactive by default.\n*   **Toggle Activation (in Production):** Updating the toggle configuration to activate the feature for a subset or all users in production.\n*   **Monitoring (in Production):** Observing the feature's performance and stability after activation in the production environment.",
        "output": "gitGraph\n    commit id: \"Initial commit\"\n    branch develop\n    checkout develop\n    commit id: \"Dev commit 1\"\n    branch featureToggle\n    checkout featureToggle\n    commit id: \"Feature code + toggle\"\n    commit id: \"More feature code\"\n    checkout develop\n    merge featureToggle id: \"Merge Feature - OFF\"\n    commit id: \"Dev commit 2\"\n    checkout main\n    merge develop id: \"Merge Dev - OFF\"\n    commit id: \"Prod commit 1\"\n    %% Configuration change TOGGLE ON %%\n    %% Monitoring in Production %%\n    branch hotfix\n    checkout hotfix\n    commit id: \"Hotfix 1\"\n    checkout main\n    merge hotfix id: \"Merge Hotfix\"\n    commit id: \"Prod commit 2\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Generate a gitgraph visualizing the commit history for integrating OAuth authentication in a financial services platform, showing both development and merge branches.",
        "planning": "*   **Main Branch (e.g., `main`, `master`):** Represents the production-ready code. Starts with initial project setup.\n\n*   **Development Branch (e.g., `develop`):** Where ongoing feature development happens. Branches off `main`.\n\n*   **Feature Branch (`feature/oauth`):** Dedicated to OAuth implementation. Branches off `develop`. Contains commits related to:\n    *   Adding OAuth libraries/dependencies.\n    *   Implementing OAuth flow (initiate, authorize, callback).\n    *   Integrating OAuth with existing user authentication.\n    *   Testing the OAuth integration.\n\n*   **Merge from `feature/oauth` to `develop`:**  Shows the integration of the feature branch into the development branch. Resolves any conflicts.\n\n*   **Merge from `develop` to `main`:**  Promotes the integrated OAuth feature to the main branch for release.  May represent a formal release process.\n\n*   **Commits:**  Individual commits on each branch representing specific changes. Messages should be descriptive (e.g., \"Add Google OAuth support,\" \"Fix OAuth redirect URI\").\n\n*   **Initial Commit:** Represents the initial commit of the git repository, branching out into the `main` branch.\n\n*   **(Optional) Hotfix Branch (if necessary):** If any issues are found after merging, it can branch out to the `main` branch, fix the issue, and merge back to both `main` and `develop`.",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch develop\n    checkout develop\n    commit id: \"Base develop commit\"\n    branch feature_oauth\n    checkout feature_oauth\n    commit id: \"Add OAuth libraries\"\n    commit id: \"Implement OAuth flow\"\n    commit id: \"Integrate with user auth\"\n    commit id: \"Test OAuth integration\"\n    checkout develop\n    merge feature_oauth id: \"Merge OAuth feature\"\n    commit id: \"Develop commit after merge\"\n    checkout main\n    commit id: \"Main branch commit\"\n    merge develop id: \"Merge to main\"\n    commit id: \"Main commit post OAuth\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Draw a gitgraph depicting version control for a mobile banking app, including separate branches for bug fixes, refactoring, and new feature additions.",
        "planning": "*   **Main Branch (e.g., `main`, `master`):** Represents the production-ready code. All features and fixes eventually merge here.\n\n*   **Feature Branch (e.g., `feature/new-transfer`):** Created from `main` for adding a new feature (e.g., money transfer). Isolated development until ready. Merges back into `main`.\n\n*   **Bugfix Branch (e.g., `bugfix/login-error`):** Created from `main` to fix a bug (e.g., login error). Targeted fix, merges back into `main`.\n\n*   **Refactor Branch (e.g., `refactor/database-layer`):** Created from `main` for code improvements without new functionality (e.g., database refactoring). Improves code quality, merges back into `main`.\n\n*   **Commits:** Individual changesets on each branch. Show a few commits on each branch to represent development progress.\n\n*   **Branching:** Lines showing where branches diverge from `main`.\n\n*   **Merging:** Lines showing where feature, bugfix, and refactor branches are merged back into `main`.\n\n*   **`HEAD` pointer:** Indicate the currently active branch (likely `main` in a simplified scenario).",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch feature_new_transfer\n    checkout feature_new_transfer\n    commit id: \"Add Transfer UI\"\n    commit id: \"Implement Transfer Logic\"\n    checkout main\n    branch bugfix_login_error\n    checkout bugfix_login_error\n    commit id: \"Fix Login Validation\"\n    checkout main\n    branch refactor_database_layer\n    checkout refactor_database_layer\n    commit id: \"Refactor DB Schema\"\n    checkout main\n    commit id: \"More Mainline Changes\"\n    merge feature_new_transfer id: \"Merge Transfer Feature\"\n    merge bugfix_login_error id: \"Merge Login Fix\"\n    merge refactor_database_layer id: \"Merge DB Refactor\"\n    commit id: \"Final Commit\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Illustrate a gitgraph showing the continuous integration process for a RAG-based system where feature branches are merged into the master branch after automated tests.",
        "planning": "*   **Feature Branch(es):** Represent development efforts on specific features.\n*   **Master Branch:** Represents the stable, production-ready code.\n*   **Developer Work:** Depicts code changes made on feature branches.\n*   **Push to Remote:** Shows feature branches being pushed to a remote repository (e.g., GitHub).\n*   **Pull Request (PR):** A request to merge a feature branch into the master branch.\n*   **Automated Tests:** Represents a CI system executing tests (unit, integration, RAG-specific evaluation).\n*   **Test Results:** Indicates the outcome of the automated tests (pass/fail).\n*   **Merge to Master:** If tests pass, the PR is merged into the master branch.\n*   **CI System:** Acts as the orchestrator, triggered by pushes and PRs.\n*   **Deployment (Optional):** Illustrates optional automated deployment after merge to master.",
        "output": "gitGraph\n   commit id: \"Initial commit\"\n   branch feature1\n   checkout feature1\n   commit id: \"Dev work on feature1\"\n   commit id: \"More dev on feature1\"\n   checkout main\n   branch feature2\n   checkout feature2\n   commit id: \"Dev work on feature2\"\n   commit id: \"More dev on feature2\"\n   checkout feature1\n   commit id: \"Finalize feature1\"\n   checkout main\n   commit id: \"Master update\"\n   checkout feature2\n   commit id: \"Finalize feature2\"\n   checkout main\n   merge feature1 id: \"Merge feature1: Tests Passed\" tag: \"Tests Passed\"\n   commit id: \"Master update after feature1\"\n   merge feature2 id: \"Merge feature2: Tests Passed\" tag: \"Tests Passed\"\n   commit id: \"Master update after feature2\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Construct a gitgraph diagram outlining the API development process in a healthcare record management system, displaying feature branches and merge commits.",
        "planning": "*   **Main Branch (e.g., `main` or `develop`):** Represents the stable, integrated codebase. All feature branches eventually merge here.\n\n*   **Feature Branches (e.g., `feature/authentication`, `feature/patient-api`, `feature/billing`):**\n    *   Branch off from the main branch.\n    *   Represent isolated development of specific API features.\n    *   Contain commits related to the feature's implementation.\n\n*   **Merge Commits:**\n    *   Represent the integration of a feature branch back into the main branch.\n    *   Connect the feature branch and the main branch.\n    *   May include a merge message describing the feature added.\n\n*   **Individual Commits:**\n    *   Represent individual changes within a branch.\n    *   Show the progression of development within a feature branch.\n    *   May include commit messages indicating the nature of the change.\n\n*   **API Endpoint Commit:**\n    *   Specific Commit focusing API related change for a feature.\n    *   Should be included in each API feature branch.\n\n**Interactions:**\n\n1.  Feature branches branch off from the main branch.\n2.  Developers commit changes to their feature branches.\n3.  Feature branches are merged back into the main branch via merge commits.",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch featureAuthentication\n    branch featurePatientAPI\n    branch featureBilling\n\n    checkout featureAuthentication\n    commit id: \"Auth1\" tag: \"API Endpoint\"\n    commit id: \"Auth2\"\n\n    checkout featurePatientAPI\n    commit id: \"Patient1\" tag: \"API Endpoint\"\n    commit id: \"Patient2\"\n\n    checkout featureBilling\n    commit id: \"Bill1\" tag: \"API Endpoint\"\n    commit id: \"Bill2\"\n\n    checkout main\n    commit id: \"Main1\"\n\n    merge featureAuthentication id: \"MergeAuth\"\n    commit id: \"Main2\"\n\n    merge featurePatientAPI id: \"MergePatient\"\n    commit id: \"Main3\"\n\n    merge featureBilling id: \"MergeBilling\"\n    commit id: \"Main4\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Develop a gitgraph that represents the branching and merging paths for microservices deployed in an IoT platform, highlighting interdependent updates.",
        "planning": "**Microservices:**\n\n*   **Core Services:** Identify 2-3 essential microservices (e.g., `DataIngestion`, `DeviceManagement`, `Analytics`).\n*   **Interdependencies:** Show dependencies (e.g., `Analytics` relies on `DataIngestion`'s output).\n*   **Feature Branches:** Illustrate feature branches created for each service (e.g., `DataIngestion/new-sensor-support`, `Analytics/realtime-dashboard`).\n\n**Branches:**\n\n*   **Main Branch (main/master):** Represents the production-ready code.\n*   **Develop Branch:** Integration branch for new features.\n*   **Release Branches:** Used for preparing a release (e.g., `release/1.0`).\n*   **Hotfix Branches:** Used for urgent fixes in production.\n\n**Commits:**\n\n*   **Feature Development:** Show commits on feature branches.\n*   **Merge to Develop:** Demonstrate merging feature branches into the `develop` branch.\n*   **Merge to Release:** Show merging `develop` into a `release` branch.\n*   **Merge to Main:** Show merging `release` into `main` after testing.\n*   **Hotfix Application:** Illustrate creating a hotfix branch from `main`, applying the fix, and merging back into `main` and `develop`.\n\n**Merge Interactions:**\n\n*   **Regular Merges:** Standard merging of feature branches into `develop`.\n*   **Interdependent Updates:** Highlight merges where multiple services are updated together (e.g., changes in both `DataIngestion` and `Analytics` needed for a new feature).\n*   **Merge Conflicts (Optional):** Indicate potential merge conflicts if changes in different services affect the same code.",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch develop\n    commit id: \"Dev Init\"\n\n    branch DataIngestion\n    checkout DataIngestion\n    commit id: \"DI Feature1\"\n    commit id: \"DI Feature2\"\n\n    checkout develop\n    merge DataIngestion id: \"Merge DI to Dev\"\n\n    branch DeviceManagement\n    checkout DeviceManagement\n    commit id: \"DM Feature1\"\n    commit id: \"DM Feature2\"\n\n    checkout develop\n    merge DeviceManagement id: \"Merge DM to Dev\"\n\n    branch Analytics\n    checkout Analytics\n    commit id: \"Analytics Feature1\"\n    commit id: \"Analytics Feature2\"\n\n    checkout develop\n    merge Analytics id: \"Merge Analytics to Dev\"\n\n    branch release_1_0\n    checkout release_1_0\n    commit id: \"Release Prep\"\n    checkout main\n    merge release_1_0 id: \"Merge to Main Release\"\n    checkout develop\n    merge release_1_0 id: \"Merge to Develop Release\"\n\n    branch hotfix_security\n    checkout hotfix_security\n    commit id: \"Security Fix\"\n    checkout main\n    merge hotfix_security id: \"Merge Hotfix Main\"\n    checkout develop\n    merge hotfix_security id: \"Merge Hotfix Dev\"\n\n    commit id: \"Develop Update\"\n    checkout DataIngestion\n    commit id: \"DI Update1\"\n\n    checkout Analytics\n    commit id: \"Analytics Update1\"\n\n    checkout develop\n    merge DataIngestion id: \"Interdep DI\"\n    merge Analytics id: \"Interdep Analytics\"\n\n    commit id: \"Final Dev\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Create a gitgraph diagram that displays the release candidate branches in an open-source project, with clear merges into the main branch.",
        "planning": "*   **main/master branch:** The central branch representing the stable, released codebase.\n*   **Release Candidate (RC) branches (e.g., rc/1.0, rc/1.1):** Branches created from `main` to prepare for a specific release. Represent pre-release versions.\n*   **Commits on RC branches:** Bug fixes, documentation updates, and other changes specific to that release.\n*   **Merge commits from RC to main:** Represents the integration of the release candidate into the main branch after testing and approval.\n*   **Tags:** Denote specific release points on main (e.g., `v1.0`, `v1.1`). Placed on merge commits to main.\n*   **Branching direction:** RC branches originate from `main`.\n*   **Merging direction:** RC branches merge *into* `main`.",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch rc10\n    checkout rc10\n    commit id: \"RC10 Bug Fix 1\"\n    commit id: \"RC10 Bug Fix 2\"\n    checkout main\n    commit id: \"Main Commit 1\"\n    merge rc10 tag: \"v1.0\"\n    branch rc11\n    checkout rc11\n    commit id: \"RC11 Bug Fix 1\"\n    commit id: \"RC11 Bug Fix 2\"\n    checkout main\n    commit id: \"Main Commit 2\"\n    merge rc11 tag: \"v1.1\"\n    commit id: \"Main Commit 3\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Generate a gitgraph representing how hotfixes are applied to a cloud-based Customer Relationship Management (CRM) application and then merged into the production branch.",
        "planning": "*   **Production Branch:** The main, deployed CRM application. Acts as the stable base.\n*   **Hotfix Branch(es):** Created from `production` to address critical bugs. Multiple branches possible if multiple bugs arise concurrently.\n*   **Developer:** Responsible for creating and working on hotfix branches.\n*   **Commits on Hotfix:** Code changes fixing the bug, committed to the hotfix branch.\n*   **Merge to Production:** Hotfix branch is merged back into `production` after testing. Represents deploying the fix.\n*   **Tags:** Optional. Tag the `production` branch after hotfix merges, marking release versions.",
        "output": "gitGraph\n   commit id: \"Initial Production Release\"\n   branch hotfix1\n   branch hotfix2\n   checkout hotfix1\n   commit id: \"Fix critical bug 1\"\n   checkout production\n   merge hotfix1 id: \"Merge hotfix 1 to production\" tag: \"v1.0.1\"\n   checkout hotfix2\n   commit id: \"Fix critical bug 2\"\n   checkout production\n   merge hotfix2 id: \"Merge hotfix 2 to production\" tag: \"v1.0.2\"\n   commit id: \"Further development on production\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Provide a gitgraph diagram visualizing version control for managing documentation updates in a research project, showing feature branches and final merges.",
        "planning": "*   **Main Branch (e.g., `main` or `master`):** Represents the stable, released documentation.\n\n*   **Feature Branches (e.g., `feature/add-intro`, `feature/revise-methods`, `feature/update-results`):** Dedicated branches for specific documentation updates.\n\n*   **Commits:** Individual changes to the documentation within each branch (e.g., \"Added introduction\", \"Revised methods section\", \"Updated figures\").\n\n*   **Branch Creation:** Show feature branches branching off from the `main` branch.\n\n*   **Commit Progression:** Illustrate commits happening on each feature branch independently.\n\n*   **Pull Requests/Merge Requests:** Implied by the merges back into `main`.\n\n*   **Merges:** Indicate when feature branches are merged back into the `main` branch after review and approval, using merge commits. Show clear direction of the merge (feature branch into main).\n\n*   **Branch Naming:** Using clear branch names.",
        "output": "gitGraph\n   commit id: \"Initial Doc\"\n   branch featureAddIntro\n   checkout featureAddIntro\n   commit id: \"Add Intro Draft\"\n   commit id: \"Revise Intro\"\n   checkout main\n   branch featureReviseMethods\n   checkout featureReviseMethods\n   commit id: \"Update Methods 1\"\n   commit id: \"Update Methods 2\"\n   checkout main\n   branch featureUpdateResults\n   checkout featureUpdateResults\n   commit id: \"Results V1\"\n   commit id: \"Finalize Results\"\n   checkout main\n   merge featureAddIntro id:\"MergeIntro\"\n   commit id: \"Post-Intro Edits\"\n   merge featureReviseMethods id:\"MergeMethods\"\n   commit id: \"Final Doc Edits\"\n   merge featureUpdateResults id:\"MergeResults\"\n   commit id: \"Version 1.0 Release\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Design a gitgraph illustrating the commit history for adding a new blockchain feature in a transaction ledger system, including development, testing, and merging.",
        "planning": "*   **Main Branch (e.g., `main` or `master`):** Represents the stable, production-ready codebase.\n*   **Feature Branch (e.g., `feature/new-blockchain-feature`):**  Branch created for developing the new feature. Diverges from `main`.\n*   **Development Commits:** Commits on the feature branch showcasing incremental progress on the new feature.\n*   **Testing Branch (e.g., `test/new-blockchain-feature`):** Branch for testing the new feature. Diverges from `feature`.\n*   **Testing Commits:** Commits on the testing branch, including bug fixes or improvements based on test results, merging from feature branch is required to keep it updated.\n*   **Merge from Feature to Test:** Feature branch is merged into the testing branch for evaluation.\n*   **Merge from Test to Feature:** Bugfixes that occurred in the testing branch are merged back to the feature branch\n*   **Pull Request/Merge Request:** A request to merge the feature branch into the `main` branch.\n*   **Code Review:** Not explicitly a commit, but implied before the merge to `main`.\n*   **Merge to Main:** The feature branch is merged into the `main` branch after successful testing and review.\n*   **(Optional) Hotfix Branch:** Branch created from `main` to address critical bugs found after merging, if needed.",
        "output": "```mermaid\ngitGraph\n   commit id: \"Initial commit\"\n   branch feature_new_blockchain_feature\n   checkout feature_new_blockchain_feature\n   commit id: \"Dev1: Implement basic feature structure\"\n   commit id: \"Dev2: Add transaction validation\"\n   commit id: \"Dev3: Integrate with ledger\"\n   branch test_new_blockchain_feature\n   checkout test_new_blockchain_feature\n   commit id: \"Test1: Initial testing setup\"\n   checkout feature_new_blockchain_feature\n   commit id: \"Dev4: Feature complete\"\n   checkout test_new_blockchain_feature\n   merge feature_new_blockchain_feature id: \"MergeFeatureToTest\"\n   commit id: \"Test2: Bug found - invalid transaction\"\n   commit id: \"Test3: Fix validation issues\"\n   checkout feature_new_blockchain_feature\n   merge test_new_blockchain_feature id: \"MergeTestToFeature\"\n   commit id: \"Dev5: Integrate more tests\"\n   checkout main\n   commit id: \"Main1: Before feature integration\"\n   checkout feature_new_blockchain_feature\n   commit id: \"Dev6: Final commit\"\n   checkout main\n   merge feature_new_blockchain_feature id: \"MergeToMain\"\n   commit id: \"Main2: After feature integration\"\n```"
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Generate a gitgraph showing an iterative development process for a weather forecasting app, where multiple feature branches converge into a main release.",
        "planning": "*   **Main Branch (main/release):** The central branch representing the stable, releasable version of the application.\n\n*   **Feature Branches (e.g., feature/UI, feature/API, feature/location):** Separate branches for developing individual features (UI, API integration, location services). Diverge from `main`.\n\n*   **Develop Branch(develop):** A branch for incorporating changes from feature branches before release. Feature branches merge here.\n\n*   **Commits:** Individual changesets within each branch.\n\n*   **Merge Requests/Pull Requests:** Represented by arrows indicating the merging of feature branches into `develop` and `develop` into `main`.\n\n*   **Release Tags (e.g., v1.0):** Indicate stable releases on the `main` branch.\n\n*   **Branching:** Feature branches diverge from `develop`.\n\n*   **Merging:** Feature branches merge into `develop`. `develop` merges into `main` after testing.\n\n*   **Direction of Flow:** Show the flow of code changes from feature branches upwards towards `main`.",
        "output": "gitGraph\n   commit id: \"Initial commit\"\n   branch develop\n   checkout develop\n   commit id: \"Dev Commit 1\"\n   commit id: \"Dev Commit 2\"\n\n   branch featureUI\n   checkout featureUI\n   commit id: \"UI Commit 1\"\n   commit id: \"UI Commit 2\"\n   checkout develop\n   merge featureUI id: \"Merge UI to Develop\"\n\n   branch featureAPI\n   checkout featureAPI\n   commit id: \"API Commit 1\"\n   commit id: \"API Commit 2\"\n   checkout develop\n   merge featureAPI id: \"Merge API to Develop\"\n\n   branch featureLocation\n   checkout featureLocation\n   commit id: \"Location Commit 1\"\n   commit id: \"Location Commit 2\"\n   checkout develop\n   merge featureLocation id: \"Merge Location to Develop\"\n\n   checkout main\n   commit id: \"Main Commit 1\"\n   merge develop id: \"Merge Develop to Main\" tag: \"v1.0\"\n   commit id: \"Main Commit 2\"\n\n   branch featureAnalytics\n   checkout featureAnalytics\n   commit id: \"Analytics Commit 1\"\n   commit id: \"Analytics Commit 2\"\n   checkout develop\n   merge featureAnalytics id: \"Merge Analytics to Develop\"\n\n   checkout main\n   merge develop id: \"Merge Develop to Main v2\" tag: \"v1.1\"\n   commit id: \"Main Commit 3\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Produce a gitgraph diagram that represents the integration of submodules in a university course management system, with separate branches for module development.",
        "planning": "*   **Main Repository (Course Management System):** Contains the core application and references to submodules.\n*   **Submodules (e.g., \"Assignments,\" \"Grading,\" \"Authentication\"):** Separate repositories, each representing a module.\n*   **Module Development Branches:** Within each submodule repository, branches for feature development or bug fixes (e.g., \"feature/new-assignment-type,\" \"bugfix/grading-calculation\").\n*   **Integration Branch (e.g., \"develop\" in Main Repo):** Central branch in the main repository where submodule updates are integrated.\n*   **Submodule Updates:** Commits in submodule development branches.\n*   **Git Submodule Pointer Updates:** Commits in the main repository that update the pointer to a specific commit in a submodule repository, effectively integrating changes.\n*   **Main Repo Branches:** For main application development (e.g., 'main','develop').\n*   **Merging:** Merging from submodule feature branches to respective submodule 'main' or 'develop' branches. Pushing the updated submodules. Updating the submodule pointers in the main repository and commiting them in main repo's corresponding branch.",
        "output": "gitGraph TB:\n    commit id: \"CMS Initial Commit\"\n    branch Assignments\n    branch Grading\n    branch Authentication\n\n    checkout Assignments\n    commit id: \"A1\" tag: \"Assignments Submodule Initial Commit\"\n    branch feature_new_type\n    commit id: \"A2\" id: \"A-feat-1\"\n    checkout Assignments\n    merge feature_new_type id: \"A3\"\n\n    checkout Grading\n    commit id: \"G1\" tag: \"Grading Submodule Initial Commit\"\n    branch bugfix_calculation\n    commit id: \"G2\" id: \"G-fix-1\"\n    checkout Grading\n    merge bugfix_calculation id: \"G3\"\n\n    checkout Authentication\n    commit id: \"AU1\" tag: \"Authentication Submodule Initial Commit\"\n    commit id: \"AU2\"\n\n    checkout main\n    commit id: \"M1\" tag: \"Update Assignments Pointer to A3\"\n    commit id: \"M2\" tag: \"Update Grading Pointer to G3\"\n    commit id: \"M3\" tag: \"No change in Authentication\"\n\n    branch develop\n    commit id: \"D1\" tag: \"Dev: Assignments A3\"\n    commit id: \"D2\" tag: \"Dev: Grading G3\"\n    commit id: \"D3\" tag: \"Dev: Authentication AU2\"\n\n    checkout Assignments\n    commit id: \"A4\"\n    checkout main\n    commit id: \"M4\" tag: \"Update Assignments Pointer to A4\"\n\n    checkout develop\n    commit id: \"D4\" tag: \"Dev: Assignments A4\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Create a gitgraph depicting the branching strategy during a major UI revamp in a social media application, including experimental and stable branches.",
        "planning": "*   **Main/Master/Production Branch:** Represents the stable, released application.\n\n*   **Develop Branch:** Integration branch for ongoing feature development and bug fixes.\n\n*   **Feature Branches (e.g., `feature/new-ui-revamp`):** Branch off `develop`, where the UI revamp work happens.\n\n*   **Experimental Branches (e.g., `experimental/new-ui-api`, `experimental/new-ui-layout`):** Branch off `feature/new-ui-revamp` for testing different approaches to specific UI components or backend APIs before integrating it to the whole UI revamp feature branch. These branches allow for isolating risk.\n\n*   **Interaction:**\n    *   Feature branches branch from and eventually merge back into the `develop` branch.\n    *   Experimental branches branch from `feature` branches and eventually merge back into it.\n    *   `Develop` branch eventually merges into `main` (typically via release branches in a more comprehensive strategy).\n\n*   **Merges:** Highlight key merges: feature branch into develop, and experimental branches into feature.\n\n*   **Tags (Optional):** Tag releases on the main branch.",
        "output": "gitGraph\n   commit id: \"Initial Commit\"\n   branch develop\n   checkout develop\n   commit id: \"Dev Commit 1\"\n   commit id: \"Dev Commit 2\"\n   branch feature_new_ui_revamp\n   checkout feature_new_ui_revamp\n   commit id: \"UI Revamp Start\"\n   branch experimental_new_ui_api\n   checkout experimental_new_ui_api\n   commit id: \"API Experiment 1\"\n   commit id: \"API Experiment 2\"\n   checkout feature_new_ui_revamp\n   merge experimental_new_ui_api id: \"Merge API Exp\"\n   branch experimental_new_ui_layout\n   checkout experimental_new_ui_layout\n   commit id: \"Layout Experiment 1\"\n   commit id: \"Layout Experiment 2\"\n   checkout feature_new_ui_revamp\n   merge experimental_new_ui_layout id: \"Merge Layout Exp\"\n   commit id: \"UI Revamp Complete\"\n   checkout develop\n   merge feature_new_ui_revamp id: \"Merge UI Revamp\"\n   commit id: \"Dev Commit 3\"\n   checkout main\n   commit id: \"Main Commit 1\"\n   merge develop id: \"Merge Develop\"\n   commit id: \"Main Commit 2\" tag: \"Release v1.0\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Generate a gitgraph diagram to show the version control process when adding a new microservice to an enterprise resource planning software, with feature branches merging into production.",
        "planning": "*   **Main Branch (Production/Main):** Represents the stable, deployed version of the ERP software. All features eventually merge here.\n*   **Develop Branch:** Branch where integration of new features occurs before going into production.\n*   **Feature Branch (e.g., `feature/new-microservice`):**  Dedicated branch for developing the new microservice. Created from Develop.\n*   **Developer Work:** Commits on the Feature Branch represent the development of the microservice.\n*   **Pull Request/Merge Request:** Mechanism to review and integrate Feature Branch changes into Develop.\n*   **Merge (Feature Branch to Develop):**  Integrates the completed microservice code into the Develop branch.\n*   **Testing/QA:** (Implied) Testing occurs on Develop after the merge.\n*   **Release Branch (Optional):** A branch created from Develop to prepare for a production release. Includes final bug fixes.\n*   **Merge (Develop/Release Branch to Production):**  Merges the tested and approved code from Develop (or Release Branch) into the Production branch. This deploys the new microservice.",
        "output": "gitGraph\n    commit id: \"Initial Commit\"\n    branch develop\n    checkout develop\n    commit id: \"Develop Commit 1\"\n    branch feature_new_microservice\n    checkout feature_new_microservice\n    commit id: \"Dev micro 1\"\n    commit id: \"Dev micro 2\"\n    commit id: \"Dev micro 3\"\n    checkout develop\n    merge feature_new_microservice id: \"Merge micro into develop\"\n    commit id: \"Develop Commit 2\"\n    checkout main\n    merge develop id: \"Merge develop into main\"\n    commit id: \"Prod commit 1\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Show a gitgraph representing experimental branching for performance optimization in a gaming platform, with clear differentiation between experimental and stable branches.",
        "planning": "*   **Main/Stable Branch:** Represents the production-ready code. All releases come from here.\n*   **Experimental Branch (e.g., `opt-branch-1`, `opt-branch-2`):** Created from Main to test specific performance optimizations. Multiple branches for different optimization strategies.\n*   **Commit(s) on Main:** Initial state of the Main/Stable branch, including base game code.\n*   **Commit(s) on Experimental Branches:** Code changes implementing performance optimizations (e.g., optimized rendering, AI improvements). These commits exist only on experimental branches.\n*   **Merge from Main to Experimental:** Regular merges to keep the experimental branch up-to-date with Main (addresses potential conflicts).\n*   **Merge from Experimental to Main:** Only if the performance optimizations in the experimental branch prove successful (significant improvement and no regressions). Should represent testing and validation before merge.\n*   **Tags (optional):** To mark releases on Main/Stable branch. Could also mark successful experimental branch merges.\n*   **Directional Arrows:** Arrows show the flow of changes. Branching is represented by an arrow diverging from a parent commit. Merging is represented by an arrow converging into a destination commit.",
        "output": "gitGraph\n   commit id: \"Initial Commit\"\n   branch opt_branch_1\n   branch opt_branch_2\n   checkout opt_branch_1\n   commit id: \"Opt1: Rendering\"\n   commit id: \"Opt1: AI\"\n   checkout main\n   commit id: \"Main: Feature1\"\n   checkout opt_branch_1\n   merge main id: \"Merge Main to Opt1\"\n   checkout opt_branch_2\n   commit id: \"Opt2: Physics\"\n   checkout main\n   merge opt_branch_1 id: \"Merge Opt1 to Main\" tag: \"Release v1.0\"\n   commit id: \"Main: Feature2\"\n   checkout opt_branch_2\n   merge main id: \"Merge Main to Opt2\"\n   checkout main\n   commit id: \"Main: BugFix\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Construct a gitgraph illustrating multiple simultaneous feature branches and their eventual merge into a data visualization tool's main codebase.",
        "planning": "*   **Main Branch (e.g., `main` or `master`):** The central branch representing the stable, released version of the tool. Acts as the integration point.\n\n*   **Feature Branches (e.g., `feature/charts`, `feature/maps`, `feature/interactions`):** Separate branches for developing individual features. Created from `main`, developed in parallel, and eventually merged back.\n\n*   **Commits:** Represent individual changes or steps within each branch. Shows the progression of work.\n\n*   **Branching Points:** Points where feature branches diverge from the `main` branch. Visual representation of the creation of a new feature branch.\n\n*   **Merging Points:** Points where feature branches are merged back into the `main` branch. Shows the integration of features.\n\n*   **Merge Commits:** Commits that represent the merging of code from a feature branch into the `main` branch.\n\n*   **Order and Timeline:** Show the chronological sequence of commits, branching, and merging. Visualizes the parallel development.",
        "output": "gitGraph\n   commit id: \"Initial Commit\"\n   branch featureCharts\n   branch featureMaps\n   branch featureInteractions\n\n   checkout featureCharts\n   commit id: \"Charts Feature - Initial\"\n   commit id: \"Charts Feature - Updates\"\n\n   checkout featureMaps\n   commit id: \"Maps Feature - Initial\"\n   commit id: \"Maps Feature - Updates\"\n\n   checkout featureInteractions\n   commit id: \"Interactions - Initial\"\n   commit id: \"Interactions - Updates\"\n\n   checkout main\n   commit id: \"Main - Minor Update\"\n\n   checkout featureCharts\n   commit id: \"Charts Feature - Final Touches\"\n\n   checkout main\n   merge featureCharts id: \"Merge Charts\"\n   commit id: \"Main - Post Charts Merge\"\n\n   checkout featureMaps\n   commit id: \"Maps Feature - Bug Fixes\"\n\n   checkout main\n   merge featureMaps id: \"Merge Maps\"\n   commit id: \"Main - Post Maps Merge\"\n\n   checkout featureInteractions\n   commit id: \"Interactions - Final Review\"\n\n   checkout main\n   merge featureInteractions id: \"Merge Interactions\"\n   commit id: \"Main - Final Release\""
    },
    {
        "diagram_type": "gitgraph",
        "prompt": "Design a gitgraph diagram mapping out the commit history and branching structure for developing a new plugin in a content management system (CMS).",
        "planning": "*   **Main Branch (e.g., `main` or `develop`):** Represents the stable codebase. New features eventually merge here.\n*   **Feature Branch (`feature/new-plugin`):** Branch dedicated to developing the new plugin. Created from the main branch.\n*   **Initial Commit (on main):** Starting point of the project or last stable release.\n*   **Plugin Base Commit (on `feature/new-plugin`):** First commit on the feature branch, setting up the basic plugin structure.\n*   **Development Commits (on `feature/new-plugin`):** Several commits representing the iterative development of the plugin (e.g., \"Implement core functionality,\" \"Add settings panel,\" \"Implement API integration\").\n*   **Review/Testing Branch (`review/new-plugin`):** Branch branched from `feature/new-plugin`. Commits related to code review or automated testing.\n*   **Merge Commit (back to `feature/new-plugin`):** Incorporates changes or fixes from the review branch.\n*   **Pull Request/Merge (from `feature/new-plugin` to `main`):** Merging of plugin code into the main branch after successful review and testing.\n*   **Potential Hotfix Branch (if needed, branched from `main`):** Branch created to fix any potential bugs in the released version of the plugin.\n*   **Hotfix Commit (on hotfix branch):** Commit fixing the bug.\n*   **Merge Hotfix Commit (back to `main`):** Incorporates bug fixes into the main branch.\n*   **Merge Hotfix Commit (back to `develop`):** Incorporates bug fixes into the develop branch.",
        "output": "```mermaid\ngitGraph\n   commit id: \"Initial Commit main\"\n   branch feature_new_plugin\n   checkout feature_new_plugin\n   commit id: \"Plugin Base\"\n   commit id: \"Implement core\"\n   commit id: \"Add settings\"\n   commit id: \"API integration\"\n   branch review_new_plugin\n   checkout review_new_plugin\n   commit id: \"Review Commit\"\n   checkout feature_new_plugin\n   merge review_new_plugin id: \"Merge Review\"\n   checkout main\n   merge feature_new_plugin id: \"Merge Plugin\"\n   branch hotfix\n   checkout hotfix\n   commit id: \"Hotfix Commit\"\n   checkout main\n   merge hotfix id: \"Merge Hotfix Main\"\n```"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Create a kanban board that visualizes the task flow for developing an E-commerce shopping cart application.",
        "planning": "**Columns (Stages):**\n\n*   **Backlog:** New feature requests, bug reports, and ideas.\n*   **To Do:** Tasks prioritized and ready for development.\n*   **In Development:** Tasks currently being worked on by developers.\n*   **Code Review:** Completed code awaiting review by peers.\n*   **Testing:** Tasks being tested for functionality and quality assurance.\n*   **Staging:** Tasks deployed to a staging environment for final validation.\n*   **Done:** Tasks successfully deployed to production.\n\n**Cards (Tasks):**\n\n*   Represent individual tasks or user stories (e.g., \"Implement Product Search,\" \"Fix Bug on Checkout\").\n*   Include brief descriptions, priority, and assignee.\n\n**Swimlanes (Optional):**\n\n*   Categorize tasks by feature or component (e.g., \"Product Catalog,\" \"Payment Gateway,\" \"User Accounts\"). Can be omitted for simplicity if not crucial.\n\n**Interactions (Card Movement):**\n\n*   Cards move from left to right as work progresses through each stage.\n*   Movement indicates status and identifies bottlenecks.\n*   Limited work in progress (WIP) within each column can be visually enforced to improve flow.",
        "output": "kanban\n  Backlog\n    feature1[Implement Product Search]@{ priority: 'High' }\n    bug1[Fix Bug on Checkout]@{ priority: 'Very High' }\n    feature2[Implement User Authentication]@{ priority: 'High' }\n  [To Do]\n    task1[Design Database Schema]@{ priority: 'High' }\n    task2[Set up Development Environment]@{ priority: 'High' }\n  [In Development]\n    task3[Develop Product Listing API]@{ assigned: 'Dev1', priority: 'High' }\n    task4[Implement Shopping Cart Logic]@{ assigned: 'Dev2', priority: 'High' }\n  [Code Review]\n    codeReview1[Review Product Listing API Code]@{ assigned: 'Reviewer1', priority: 'High' }\n    codeReview2[Review Shopping Cart Logic Code]@{ assigned: 'Reviewer2', priority: 'High' }\n  Testing\n    test1[Test Product Listing API]@{ priority: 'High' }\n    test2[Test Shopping Cart Functionality]@{ priority: 'High' }\n  Staging\n    staging1[Deploy to Staging Environment]@{ priority: 'High' }\n  Done\n    done1[Database Schema Implemented]\n    done2[Development Environment Setup]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Generate a kanban board for planning the phases of a chat application development project.",
        "planning": "**Kanban Board Components & Interactions:**\n\n*   **Columns (Stages):**\n    *   **Backlog:** New features, bug fixes, ideas. (Input: User feedback, market research, planning meetings)\n    *   **To Do:** Items prioritized for the current sprint/iteration. (Input: Items from Backlog moved based on priority.)\n    *   **In Progress:** Tasks currently being worked on. (Input: Items from 'To Do' column.)\n    *   **Code Review:** Completed code awaiting review. (Input: Items from 'In Progress' column.)\n    *   **Testing/QA:** Tasks undergoing testing. (Input: Items from 'Code Review' column.)\n    *   **Done:** Completed and deployed features. (Input: Items from 'Testing/QA' column.)\n\n*   **Cards (Tasks):**\n    *   Represent individual features, bug fixes, or tasks.\n    *   Include: Title, description, assignee, priority, estimated effort.\n    *   Move across columns based on progress.\n\n*   **Swimlanes (Optional):**\n    *   Categorize tasks by type (e.g., Frontend, Backend, Design, Database).\n    *   Improve visibility and organization.\n\n*   **Interactions:**\n    *   **Movement:** Cards move from left to right as work progresses.\n    *   **Pull System:** Team members \"pull\" tasks from the \"To Do\" column when they are ready to work on them.\n    *   **Feedback Loops:** Issues found in Testing/QA send cards back to earlier stages (e.g., In Progress or Code Review).\n    *   **Prioritization:** The Product Owner/Manager prioritizes tasks in the Backlog and \"To Do\" columns.\n    *   **WIP Limits (Work in Progress):** Limits the number of cards in each column to avoid bottlenecks.",
        "output": "kanban\n  Backlog\n    feat1[Implement User Authentication] @{ priority: 'High' }\n    feat2[Design Chat Interface]\n    bug1[Fix Message Delivery Issue] @{ priority: 'Very High' }\n    feat3[Add File Sharing Feature]\n  [To Do]\n    feat4[Implement Real-time Updates] @{ priority: 'High' }\n    ui1[Design User Profile Page]\n  [In Progress]\n    be1[Develop Chat API]\n    db1[Optimize Database Queries]\n  [Code Review]\n    be2[Implement Message Encryption]\n  [Testing/QA]\n    test1[Test User Authentication]\n    test2[Test Chat API]\n  Done\n    feat5[Implement Basic Chat Functionality]\n    ui2[Design Login Page]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Design a kanban board to show the steps in creating a simple online learning platform.",
        "planning": "**Columns (Stages):**\n\n*   **Backlog:** Initial ideas, feature requests, user stories.\n*   **To Do:** Tasks prioritized and ready for work.\n*   **In Progress:** Tasks currently being worked on.\n*   **Review:** Completed tasks awaiting testing and feedback.\n*   **Testing/QA:** Tasks undergoing quality assurance.\n*   **Done:** Completed and deployed features.\n\n**Cards (Tasks):**\n\n*   Represent individual tasks (e.g., \"Design User Interface,\" \"Develop Course Enrollment Module\").\n*   Include a brief description, assignee, and priority.\n\n**Swimlanes (Optional, for different workstreams):**\n\n*   Could separate tasks by function (e.g., \"Frontend Development,\" \"Backend Development,\" \"Content Creation\").\n\n**Interactions:**\n\n*   Cards move from left to right as progress is made.\n*   Movement indicates completion of a stage and readiness for the next.\n*   Feedback loops: Cards may move back to previous stages if issues are found during review or testing.\n*   Prioritization: The \"To Do\" column should reflect the most important tasks to be worked on next.",
        "output": "kanban\n  Backlog[Backlog]\n    idea1[Initial Platform Ideas]\n    featReq1[Feature Requests]\n    userStory1[User Stories]\n  To_Do[To Do]\n    task1[Design UI]@{ assigned: 'User', priority: 'High' }\n    task2[Develop Enrollment Module]@{ assigned: 'Dev1', priority: 'High' }\n  In_Progress[In Progress]\n    task3[Implement User Authentication]@{ assigned: 'Dev2', priority: 'High' }\n    task4[Build Course Listing Page]@{ assigned: 'Dev1', priority: 'High' }\n  Review[Review]\n    task5[Review UI Design]@{ assigned: 'Designer', priority: 'High' }\n    task6[Code Review Enrollment Module]@{ assigned: 'Reviewer', priority: 'High' }\n  Testing_QA[Testing/QA]\n    task7[Test User Authentication]@{ assigned: 'QA1', priority: 'High' }\n    task8[Test Course Listing]@{ assigned: 'QA2', priority: 'High' }\n  Done[Done]\n    task9[Deploy User Authentication]@{ assigned: 'Ops', priority: 'High' }\n    task10[Deploy Course Listing]@{ assigned: 'Ops', priority: 'High' }"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Produce a kanban board for managing tasks in implementing a RAG-based retrieval system.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** Initial list of all tasks.\n*   **To Do:** Tasks prioritized and ready to be worked on.\n*   **In Progress:** Tasks currently being worked on.\n*   **Code Review:** Tasks awaiting code review.\n*   **Testing:** Tasks undergoing testing.\n*   **Done:** Completed tasks.\n\n**Key Tasks (Cards) & Interactions:**\n\n*   **Data Ingestion & Preprocessing:**\n    *   Interaction: Feeds data into the Vector Database.\n*   **Vector Database Setup:**\n    *   Interaction: Stores embeddings, retrieved by the Retrieval component.\n*   **Embedding Model Integration:**\n    *   Interaction: Creates embeddings for data and queries.\n*   **Retrieval Component Development:**\n    *   Interaction: Queries the Vector Database based on user input.\n    *   Interaction: Sends Retrieved Context to the LLM.\n*   **LLM Integration:**\n    *   Interaction: Receives Retrieved Context, generates a response.\n*   **Prompt Engineering:**\n    *   Interaction: Improves the LLM's response quality.\n*   **Evaluation & Testing:**\n    *   Interaction: Tests the entire RAG pipeline, provides feedback for improvement of Data Ingestion, Embedding, Retrieval, and LLM prompting.\n*   **Deployment:**\n    *   Interaction: Makes the RAG system accessible to users.\n\n**Card Attributes (on each task):**\n\n*   Task Description\n*   Assignee\n*   Priority\n*   Dependencies (Blocked By)\n*   Due Date",
        "output": "```mermaid\nkanban\n  Backlog\n    data_ingestion[Data Ingestion & Preprocessing]\n    vector_db[Vector Database Setup]\n    embedding_model[Embedding Model Integration]\n    retrieval_comp[Retrieval Component Development]\n    llm_integration[LLM Integration]\n    prompt_eng[Prompt Engineering]\n    eval_testing[Evaluation & Testing]\n    deployment[Deployment]\n  To Do\n    data_ingestion\n    vector_db\n    embedding_model\n  \"In Progress\"\n    retrieval_comp\n  \"Code Review\"\n    llm_integration\n  Testing\n    prompt_eng\n  Done\n    eval_testing\n    deployment\n```"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Construct a kanban board that outlines the stages of setting up a basic cybersecurity monitoring system.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** Initial list of all tasks.\n*   **To Do:** Tasks ready to be worked on.\n*   **In Progress:** Tasks currently being worked on.\n*   **Testing/Review:** Tasks completed and being tested/reviewed.\n*   **Done:** Completed tasks.\n\n**Cards/Tasks (example):**\n\n**Backlog:**\n*   Define Monitoring Goals\n*   Identify Critical Assets\n*   Select Monitoring Tools\n*   Configure Initial Rules\n*   Set up SIEM\n*   Establish Alerting Mechanism\n*   Document Procedures\n*   Train Personnel\n\n**To Do:**\n*   (Move tasks from Backlog as resources become available)\n\n**In Progress:**\n*   (Current task being worked on)\n\n**Testing/Review:**\n*   (Task awaiting review)\n\n**Done:**\n*   (Completed task)\n\n**Interactions/Dependencies:**\n\n*   **Define Monitoring Goals** must be completed before **Identify Critical Assets** and **Select Monitoring Tools**.\n*   **Select Monitoring Tools** must be completed before **Set up SIEM** and **Configure Initial Rules.**\n*   **Configure Initial Rules** and **Set up SIEM** can potentially be done concurrently but often SIEM must be set up first.\n*   **Establish Alerting Mechanism** relies on **Set up SIEM** and **Configure Initial Rules**.\n*   **Document Procedures** and **Train Personnel** should be done after all technical configurations are mostly complete.\n\n**Key Components:**\n\n*   **Monitoring Goals:** Defines scope (e.g., compliance, threat detection).\n*   **Critical Assets:** Systems to protect (e.g., servers, databases).\n*   **Monitoring Tools:** Software for data collection (e.g., Suricata, Wazuh, OSSEC, auditd).\n*   **SIEM (Security Information and Event Management):** Centralized log analysis and alerting (e.g., Elastic Stack, Splunk).\n*   **Alerting Mechanism:** How security events are communicated (e.g., email, Slack).",
        "output": "kanban\n  Backlog\n    id1[Define Monitoring Goals]\n    id2[Identify Critical Assets]\n    id3[Select Monitoring Tools]\n    id4[Configure Initial Rules]\n    id5[Set up SIEM]\n    id6[Establish Alerting Mechanism]\n    id7[Document Procedures]\n    id8[Train Personnel]\n  To Do\n    id9[Move tasks from Backlog as resources become available]\n  \"In Progress\"\n    id10[Current task being worked on]\n  \"Testing/Review\"\n    id11[Task awaiting review]\n  Done\n    id12[Completed task]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Develop a kanban board for planning the project phases of a video conferencing tool, focusing on initial, in-progress, and completed tasks.",
        "planning": "**Kanban Board Components & Interactions:**\n\n*   **Columns (Swimlanes):**\n    *   *To Do (Initial):* Tasks waiting to be started.\n    *   *In Progress:* Tasks currently being worked on.\n    *   *Completed:* Finished tasks.\n*   **Cards (Tasks):** Represent individual project tasks (e.g., \"UI Design,\" \"Backend Development,\" \"Testing\").\n*   **Card Details:** Title, description, assignee, priority (optional).\n*   **Workflow:** Cards move from \"To Do\" -> \"In Progress\" -> \"Completed\" as work progresses.\n*   **Limit:** Maximum number of cards allowed in each \"In Progress\" column to prevent bottlenecks.\n*   **Interaction:** Team members pull tasks from \"To Do,\" work on them (\"In Progress\"), and move them to \"Completed\" upon completion.",
        "output": "kanban\n  Todo[To Do]\n    task1[UI Design]@{assigned: 'Team A', priority: 'High'}\n    task2[Backend Development]@{assigned: 'Team B', priority: 'High'}\n    task3[Database Setup]@{assigned: 'Team B'}\n    task4[API Design]@{assigned: 'Team A'}\n  InProgress[In Progress]\n    task5[Testing]@{assigned: 'Team C', priority: 'Medium'}\n    task6[Frontend Integration]@{assigned: 'Team A'}\n  Completed[Completed]\n    task7[Initial Planning]@{assigned: 'Project Manager'}\n    task8[Requirements Gathering]@{assigned: 'Project Manager', priority: 'High'}"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Create a kanban board to represent the steps of simulating a networking protocol in an academic project.",
        "planning": "**Kanban Board Components & Interactions for Networking Protocol Simulation:**\n\n**Columns (Stages):**\n\n*   **To Do:** Initial tasks, backlog.\n*   **Design & Planning:** Protocol design, simulation plan.\n*   **Implementation:** Code development, simulator setup.\n*   **Testing & Validation:** Simulation runs, data collection.\n*   **Analysis & Tuning:** Results analysis, parameter adjustments.\n*   **Documentation:** Report writing, presentation preparation.\n*   **Done:** Completed tasks.\n\n**Cards (Tasks):**\n\n*   Represent specific tasks (e.g., \"Implement TCP congestion control,\" \"Write simulation script for network topology X,\" \"Analyze throughput under varying load\").\n*   Include details: description, assignee, priority.\n\n**Interactions:**\n\n*   Cards move left-to-right as progress is made.\n*   Movement signifies task completion in a stage.\n*   Dependencies are reflected in card flow (e.g., implementation precedes testing).\n*   Bottlenecks are visualized by card accumulation in a column.\n*   Feedback loops can be shown: Analysis leads to tuning, which goes back to Implementation/Testing.",
        "output": "kanban\n  To_Do[To Do]\n    task1[Define Protocol Requirements]\n    task2[Research Existing Protocols]\n  Design_Planning[Design & Planning]\n    task3[Design Protocol Architecture]\n    task4[Plan Simulation Setup]\n  Implementation[Implementation]\n    task5[Implement Core Protocol Logic]\n    task6[Set Up Network Simulator]\n  Testing_Validation[Testing & Validation]\n    task7[Run Initial Simulations]\n    task8[Collect Simulation Data]\n  Analysis_Tuning[Analysis & Tuning]\n    task9[Analyze Simulation Results]\n    task10[Tune Protocol Parameters]\n  Documentation[Documentation]\n    task11[Write Simulation Report]\n    task12[Prepare Presentation]\n  Done[Done]\n    task13[Finalize Documentation]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Generate a kanban board that outlines the development stages of a web scraping tool.",
        "planning": "**Kanban Board Columns (Stages):**\n\n*   **To Do:** Initial ideas, feature requests, bug reports.\n*   **In Development:** Tasks actively being worked on.\n*   **Code Review:** Completed code awaiting review.\n*   **Testing:** Code undergoing unit/integration testing.\n*   **Staging:** Ready to deploy to staging environment.\n*   **Production:** Deployed to production and live.\n*   **Done:** Completed features, bug fixes, or tasks.\n\n**Cards (Tasks/Items):**\n\n*   Represent specific tasks like \"Implement URL crawler,\" \"Add data extraction module,\" \"Fix XPATH bug.\"\n*   Include title, description, assignee, priority.\n\n**Interactions:**\n\n*   Cards move from left to right across the board as they progress through the stages.\n*   Movement indicates completion of a stage and readiness for the next.\n*   Feedback loops exist (e.g., from Testing back to In Development if bugs are found).\n*   Code Review provides feedback potentially sending cards back to \"In Development\"",
        "output": "kanban\n  todo[To Do]\n    task1[Implement URL crawler]@{ assigned: dev1 priority: High }\n    task2[Add data extraction module]@{ assigned: dev2 priority: High }\n    task3[Implement robust error handling]@{ assigned: dev1 priority: Medium }\n    task4[Design user interface]@{ assigned: ux_team priority: High }\n  inDev[In Development]\n    task5[Refactor data storage]@{ assigned: dev2 priority: Medium }\n    task6[Implement rate limiting]@{ assigned: dev1 priority: High }\n  codeReview[Code Review]\n    task7[Review URL crawler implementation]@{ assigned: reviewer1 priority: High }\n  testing[Testing]\n    task8[Unit test data extraction]@{ assigned: qa_team priority: High }\n    task9[Integration test URL crawler]@{ assigned: qa_team priority: Medium }\n  staging[Staging]\n    task10[Deploy to staging environment]@{ assigned: ops_team priority: High }\n  production[Production]\n    task11[Monitor production performance]@{ assigned: ops_team priority: High }\n  done[Done]\n    task12[Fix XPATH bug]@{ assigned: dev2 priority: High }\n    task13[Implement basic crawling functionality]@{ assigned: dev1 priority: High }"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Design a kanban board for project management in building a database-backed inventory management system.",
        "planning": "**Columns:**\n\n*   **Backlog:** Initial list of all features, tasks, and bug fixes. Interacts with: \"To Do\".\n\n*   **To Do:** Prioritized tasks ready for development. Interacts with: \"Backlog\", \"In Progress\".\n\n*   **In Progress:** Tasks currently being worked on by developers. Interacts with: \"To Do\", \"Code Review\", \"Testing\".\n\n*   **Code Review:** Code is reviewed by team members. Interacts with: \"In Progress\", \"Testing\", \"Done\".\n\n*   **Testing:** Tasks undergoing testing for functionality and bugs. Interacts with: \"Code Review\", \"In Progress\", \"Done\", \"Backlog\" (if bugs found).\n\n*   **Done:** Completed and deployed tasks. Interacts with: \"Testing\".\n\n**Cards:**\n\n*   Represent individual tasks (e.g., \"Design Database Schema,\" \"Implement API Endpoint for Product Creation,\" \"Write Unit Tests for Inventory Update\").\n\n**Swimlanes (Optional):**\n\n*   Categorize tasks by component (e.g., \"Database,\" \"API,\" \"Frontend\").\n\n**Interactions:**\n\n*   Tasks move from left to right across the board, representing progress.\n*   Blocked tasks are clearly marked to visualize roadblocks.\n*   Feedback loops exist when tasks need to be revisited (e.g., from testing back to development).\n*   The team pulls tasks from \"To Do\" into \"In Progress,\" respecting work-in-progress (WIP) limits.",
        "output": "kanban\n  Backlog\n    task1[Design Database Schema]\n    task2[Implement API Endpoint for Product Creation]\n    task3[Write Unit Tests for Inventory Update]\n  [To Do]\n    task4[Set up Database Connection]\n    task5[Create User Authentication]\n  [In Progress]\n    task6[Develop Product Search Functionality]\n    task7[Implement Inventory Tracking]\n  [Code Review]\n    task8[Review Database Schema]\n    task9[Review API Endpoints]\n  Testing\n    task10[Test Product Creation]\n    task11[Test Inventory Update]\n  Done\n    task12[Deploy Initial Version]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Produce a kanban board for the milestones of implementing a RESTful API for a weather forecasting application.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** Initial list of API features and tasks.\n*   **To Do:** Tasks ready to be worked on.\n*   **In Progress:** Tasks currently being developed.\n*   **Testing:** Tasks undergoing quality assurance.\n*   **Review:** Tasks awaiting code review and approval.\n*   **Done:** Completed tasks, ready for deployment or deployment finished.\n\n**Kanban Board Cards (Example Tasks):**\n\n*   **Backlog Examples:** Define API endpoints, Design data models, Implement authentication, Implement rate limiting, Implement weather data retrieval.\n*   **In Progress Examples:** Developing endpoint for current conditions, Writing unit tests for data parsing.\n*   **Review Example:** Code review: Data validation logic.\n*   **Testing Example:** Testing endpoint response times.\n\n**Interactions/Workflow:**\n\n1.  Tasks move from Backlog to To Do when ready for development.\n2.  Developers pull tasks from To Do to In Progress.\n3.  Completed development moves tasks to Testing.\n4.  Successful testing moves tasks to Review.\n5.  Approved reviews move tasks to Done.\n6.  Blocked tasks might move back to a previous column.\n7. Status Updates on the card.",
        "output": "kanban\n  Backlog\n    task1[Define API endpoints]\n    task2[Design data models]\n    task3[Implement authentication]\n    task4[Implement rate limiting]\n    task5[Implement weather data retrieval]\n  [To Do]\n    task6[Set up project structure]\n    task7[Configure database connection]\n  [In Progress]\n    task8[Develop endpoint for current conditions]\n    task9[Writing unit tests for data parsing]\n  Testing\n    task10[Test endpoint response times]\n    task11[Test data validation]\n  Review\n    task12[Code review Data validation logic]\n  Done\n    task13[Initial project setup complete]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Construct a kanban board that represents the planning phases for developing an event management mobile app.",
        "planning": "**Kanban Board Columns (Planning Phases):**\n\n*   **Backlog:** Initial ideas, feature requests, and bug reports.\n*   **To Do:** Prioritized tasks for the current sprint or iteration.\n*   **In Progress:** Tasks currently being worked on.\n*   **Review:** Completed tasks awaiting review and approval.\n*   **Blocked:** Tasks that are currently unable to proceed.\n*   **Done:** Completed and approved tasks.\n\n**Kanban Board Cards (Tasks):**\n\n*   **User Story Card:** High level definition of a feature from the user's perspective.\n*   **Technical Task Card:** Specific technical tasks required for the implementation of the application.\n*   **Bug Card:** Cards that represents a bug need to be fixed.\n*   **Epic Card:** A high level user story.\n\n**Interactions:**\n\n1.  **Movement:** Cards move left to right as work progresses through the phases.\n2.  **Prioritization:** Tasks in the \"To Do\" column are prioritized.\n3.  **Collaboration:** Team members collaborate on tasks within each phase.\n4.  **Feedback Loop:** Tasks may move back to previous phases if issues are found during review.\n5.  **Blockers:** Tasks in the \"Blocked\" column require resolution before proceeding.",
        "output": "kanban\n  Backlog[Backlog]\n    feature1[User Story - Event Creation]\n    feature2[User Story - User Authentication]\n    bug1[Bug - Login issue on iOS]\n    task1[Technical Task - Set up database]\n    epic1[Epic - Social Media Integration]\n  Todo[To Do]\n    feature3[User Story - Push Notifications] @{ priority: 'High' }\n    task2[Technical Task - Design UI/UX] @{ priority: 'High' }\n  InProgress[In Progress]\n    feature4[User Story - Calendar Integration] @{ assigned: 'John Doe' }\n  Review[Review]\n    task3[Technical Task - Implement API] @{ assigned: 'Jane Smith' }\n  Blocked[Blocked]\n    feature5[User Story - Payment Integration] @{ ticket: PAY-123 }\n  Done[Done]\n    feature6[User Story - Event Search]\n    task4[Technical Task - Testing User Authentication]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Create a kanban board to visualize task progress in the development of a social media aggregator.",
        "planning": "*   **Columns (Stages):**\n    *   **Backlog:** Initial ideas and user stories. (Interaction: tasks originate here).\n    *   **To Do:** Tasks ready for development. (Interaction: tasks move from Backlog after prioritization).\n    *   **In Progress:** Tasks currently being worked on. (Interaction: tasks move from To Do when started).\n    *   **Code Review:** Tasks awaiting review. (Interaction: tasks move from In Progress after development).\n    *   **Testing:** Tasks undergoing testing. (Interaction: tasks move from Code Review after approval).\n    *   **Done:** Completed tasks. (Interaction: tasks move from Testing after passing tests).\n\n*   **Cards (Tasks):**\n    *   Represent individual development tasks (e.g., \"Implement Twitter API integration,\" \"Design user interface\").\n    *   Contain brief description, assignee, and priority (optional).\n    *   Interaction: Moved across columns to reflect progress.\n\n*   **Swimlanes (Optional):**\n    *   Categorize tasks by feature or component (e.g., \"Backend,\" \"Frontend,\" \"API\").\n    *   Interaction: Organizes cards visually within each column.\n\n*   **Limits (Optional):**\n    *   Work-in-progress (WIP) limits restrict the number of cards in each column.\n    *   Interaction: Prevents bottlenecks and encourages focus.",
        "output": "kanban\n  Backlog\n    task1[Implement Twitter API integration]\n    task2[Design user interface]\n    task3[Define data model]\n  To Do\n    task4[Set up project repository]\n    task5[Configure development environment]\n  [In Progress]\n    task6[Develop user authentication module]\n    task7[Build API endpoint for tweets]\n  [Code Review]\n    task8[Review authentication module code]\n    task9[Review API endpoint code]\n  Testing\n    task10[Test user authentication]\n    task11[Test API endpoint]\n  Done\n    task12[Deploy authentication module]\n    task13[Deploy API endpoint]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Generate a kanban board for scheduling the tasks involved in implementing a load balancer in a distributed system.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** Initial list of all tasks.\n*   **To Do:** Tasks ready to be worked on.\n*   **In Progress:** Tasks currently being worked on.\n*   **Code Review:** Tasks awaiting code review.\n*   **Testing:** Tasks being tested.\n*   **Blocked:** Tasks that are blocked and cannot proceed.\n*   **Done:** Completed tasks.\n\n**Cards (Tasks - examples):**\n\n*   **Backlog:**\n    *   Define Load Balancing Requirements (e.g., type, capacity, features).\n    *   Design Load Balancer Architecture (e.g., algorithm, health checks).\n    *   Choose Load Balancer Technology (e.g., Nginx, HAProxy, AWS ALB).\n    *   Provision Infrastructure (e.g., servers, network).\n    *   Configure Load Balancer.\n    *   Implement Health Checks.\n    *   Implement Session Persistence (if required).\n    *   Configure Logging and Monitoring.\n    *   Write Unit Tests.\n    *   Write Integration Tests.\n    *   Document Configuration.\n    *   Create Rollback Plan.\n    *   Security Hardening.\n*   **To Do, In Progress, Code Review, Testing, Blocked, Done:** Tasks move between these columns as they progress.\n\n**Interactions & Dependencies (Implicit in Kanban flow):**\n\n*   Tasks move sequentially through columns.\n*   Testing depends on code being written/configured.\n*   Configuration depends on infrastructure provisioning.\n*   Implementation of health checks depends on load balancer choice.\n*   Session persistence depends on requirement definition.\n*   Rollback plan is created after implementation and config.\n*   \"Blocked\" indicates a dependency preventing progress, requiring resolution (e.g., waiting on another team, resource unavailability).\n\n**Key Elements Focus:**\n\n*   Prioritize tasks based on dependencies.\n*   Visualize workflow and identify bottlenecks.\n*   Track progress of each task.\n*   Limit work in progress to maintain focus.\n*   Ensure smooth flow from requirement gathering to deployment.",
        "output": "kanban\n  Backlog\n    define_requirements[Define Load Balancing Requirements] \n    design_architecture[Design Load Balancer Architecture] \n    choose_technology[Choose Load Balancer Technology] \n    provision_infrastructure[Provision Infrastructure] \n    configure_lb[Configure Load Balancer] \n    implement_health_checks[Implement Health Checks] \n    implement_session_persistence[Implement Session Persistence] \n    configure_logging_monitoring[Configure Logging and Monitoring] \n    write_unit_tests[Write Unit Tests] \n    write_integration_tests[Write Integration Tests] \n    document_configuration[Document Configuration] \n    create_rollback_plan[Create Rollback Plan] \n    security_hardening[Security Hardening] \n  To_Do[To Do]\n  In_Progress[In Progress]\n  Code_Review[Code Review]\n  Testing\n  Blocked\n  Done"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Design a kanban board for a microservice-based e-commerce framework highlighting planning, development, and review stages.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** All feature requests, bug fixes, tech debt for all microservices.\n\n*   **Planning:** Tasks being refined, estimated, and prioritized for upcoming sprint/iteration. Interacts with Backlog (items pulled in) and Development (items pushed after planning).\n\n*   **Development:**\n    *   **In Progress:** Tasks actively being worked on by developers across different microservices.\n    *   **Code Review:** Completed code awaiting review.\n    *   **Testing:** Tasks undergoing automated or manual testing.\n    Interacts: Planning (items pulled in), Review (items pushed after successful tests and reviews).\n\n*   **Review:**\n    *   **UAT (User Acceptance Testing):** Tasks being validated by stakeholders.\n    *   **Awaiting Deployment:** Tasks approved and ready for deployment.\n    Interacts: Development (items pulled), Done (items pushed when accepted).\n\n*   **Done:** Completed and deployed tasks.\n\n**Card Details (on each task):**\n\n*   Microservice affected (e.g., \"Payment Service,\" \"Product Catalog\").\n*   Task Title (e.g., \"Implement Wishlist API\").\n*   Assignee.\n*   Priority.\n\n**Interactions:**\n\n*   Tasks move from left to right across columns.\n*   Bottlenecks are visualized by columns with many cards.\n*   Feedback loops: Review stage may send tasks back to Development or Planning.\n*   Dependencies between microservices should be indicated on cards (e.g., \"Requires Product API update\").",
        "output": "kanban\n  Backlog\n    task1[Add Recommendation Engine to Product Catalog] @{ assigned: 'Alice', priority: 'High' }\n    task2[Fix Payment Gateway Integration Error] @{ assigned: 'Bob', priority: 'Very High' }\n    task3[Implement User Profile Update Feature] @{ assigned: 'Charlie', priority: 'Medium' }\n  Planning\n    task4[Refine Recommendation Engine Requirements] @{ assigned: 'Alice', priority: 'High' }\n    task5[Estimate Payment Gateway Fix] @{ assigned: 'Bob', priority: 'Very High' }\n  Development\n    [In Progress]\n      task6[Developing Recommendation Engine Logic] @{ assigned: 'Alice', priority: 'High' }\n    [Code Review]\n      task7[Review Payment Gateway Fix] @{ assigned: 'David', priority: 'Very High' }\n    Testing\n      task8[Testing User Profile Update] @{ assigned: 'Eve', priority: 'Medium' }\n  Review\n    [UAT]\n      task9[UAT on Payment Gateway Fix] @{ assigned: 'Stakeholder', priority: 'Very High' }\n    [Awaiting Deployment]\n      task10[Recommendation Engine Ready for Deploy] @{ assigned: 'Release Team', priority: 'High' }\n  Done\n    task11[Deployed Initial User Profile Update] @{ assigned: 'Release Team', priority: 'Medium' }"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Create a kanban board for outlining steps in the development of a simplified file-sharing application.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** Initial list of features/tasks. Interacts with \"To Do\" by moving tasks into it.\n*   **To Do:** Tasks ready to be worked on. Interacts with \"In Progress\" by moving tasks when work starts.\n*   **In Progress:** Tasks currently being worked on. Interacts with \"Code Review\" upon completion of initial coding and interacts with \"Testing\" upon completion of integration,\n*   **Code Review:** Tasks undergoing code review. Interacts with \"Testing\" if passed, \"In Progress\" if changes are needed.\n*   **Testing:** Tasks being tested. Interacts with \"Done\" if passed, \"In Progress\" if issues found.\n*   **Done:** Completed tasks. Represents the final stage.\n\n**Kanban Board Cards:**\n\n*   Each card represents a specific task (e.g., \"Implement File Upload,\" \"User Authentication,\" \"Create Download Link\"). They flow through the columns.\n\n**Interactions Summary:**\n\n*   Cards move from left (Backlog) to right (Done) as work progresses.\n*   Feedback loops exist from \"Code Review\" and \"Testing\" back to \"In Progress\" for rework.\n*   The board visualizes workflow, bottlenecks, and progress.",
        "output": "kanban\n  Backlog\n    task1[Implement File Upload]\n    task2[User Authentication]\n    task3[Create Download Link]\n    task4[Implement File Deletion]\n    task5[Implement File Sharing]\n\n  [To Do]\n    task6[Design Database Schema]\n    task7[Setup Development Environment]\n\n  [In Progress]\n    task8[Develop File Storage System]\n\n  [Code Review]\n    task9[Review File Storage System Code]\n\n  Testing\n    task10[Test File Upload Functionality]\n    task11[Test Download Link Generation]\n\n  Done\n    task12[Configure Server]\n    task13[Deploy Initial Version]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Construct a kanban board to manage the tasks in designing a basic chatbot using natural language processing techniques.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** Initial list of all potential tasks.\n*   **To Do:** Tasks prioritized and ready to be worked on.\n*   **In Progress:** Tasks currently being worked on.\n*   **Testing/Review:** Tasks completed and awaiting testing or review.\n*   **Done:** Tasks completed and approved.\n\n**Kanban Cards (Example Tasks):**\n\n*   **Task 1: Data Collection and Preprocessing**\n*   **Task 2: Intent Recognition Model Training**\n*   **Task 3: Dialogue Management Design**\n*   **Task 4: Response Generation Implementation**\n*   **Task 5: Chatbot Interface Development**\n*   **Task 6: Testing and Evaluation**\n\n**Card Details (On each card):**\n\n*   Task Title\n*   Description\n*   Priority\n*   Assignee\n\n**Interactions:**\n\n1.  Tasks move from Backlog to To Do based on prioritization.\n2.  Team members pull tasks from To Do to In Progress.\n3.  Once a task is completed, it moves to Testing/Review.\n4.  After successful testing/review, the task moves to Done.\n5.  Feedback loops: Tasks might move back to previous columns (e.g., from Testing/Review back to In Progress) if issues are found.\n6.  Dependencies: Some tasks might be blocked until others are completed (indicated on the card). For example, \"Response Generation Implementation\" needs \"Dialogue Management Design\" to be completed first.",
        "output": "kanban\n  Backlog\n    task1[Data Collection and Preprocessing] @{ priority: 'High' }\n    task2[Intent Recognition Model Training] @{ priority: 'High' }\n    task3[Dialogue Management Design] @{ priority: 'High' }\n    task4[Response Generation Implementation] @{ priority: 'High' }\n    task5[Chatbot Interface Development] @{ priority: 'High' }\n    task6[Testing and Evaluation] @{ priority: 'High' }\n  [To Do]\n  [In Progress]\n  [Testing Review]\n  Done"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Develop a kanban board that outlines the stages of creating a front-end interface with a JavaScript framework.",
        "planning": "**Kanban Board Components & Interactions Plan:**\n\n**Columns (Stages):**\n\n*   **Backlog:** Initial feature requests/user stories. (Starting point; items enter here.)\n*   **To Do:** Refined tasks ready for development. (Pulled from Backlog when capacity is available.)\n*   **In Progress:** Tasks actively being worked on. (Only one or a limited number of tasks per developer.)\n*   **Code Review:** Completed code awaiting review. (Ensures code quality and consistency.)\n*   **Testing:** Code undergoing testing (unit, integration, UI). (Verifies functionality.)\n*   **Blocked:** Tasks currently unable to be completed (dependencies, bugs). (Highlights impediments.)\n*   **Done:** Completed and deployed tasks. (Marks successful completion.)\n\n**Cards (Tasks):**\n\n*   Represent individual front-end development tasks (e.g., \"Implement User Login Component,\" \"Style Navigation Bar\").\n*   Include details like task description, assigned developer, priority, and estimated effort.\n\n**Interactions:**\n\n*   **Pulling:** Team members \"pull\" tasks from the \"To Do\" column to \"In Progress\" when they have capacity.\n*   **Pushing:** Tasks are \"pushed\" to the next column as they progress through the workflow (e.g., \"In Progress\" to \"Code Review\").\n*   **Feedback Loops:** Tasks can move backward (e.g., \"Testing\" back to \"In Progress\" if bugs are found; \"Code Review\" back to \"In Progress\" for revisions).\n*   **Blocker Handling:** Tasks moved to \"Blocked\" column require active problem-solving to unblock and move back into the workflow.",
        "output": "kanban\n  Backlog[Backlog]\n    feature1[Implement User Login Component]\n    feature2[Style Navigation Bar]\n    feature3[Implement Password Reset Functionality]\n  [To Do]\n    task1[Refactor API Calls]\n    task2[Improve Accessibility]\n  [In Progress]\n    devTask1[Develop Profile Page]@{ assigned: 'dev1' }\n  [Code Review]\n    revTask1[Review Login Component]@{ assigned: 'reviewer1' }\n  Testing\n    testTask1[Test User Registration]@{ priority: 'High' }\n  Blocked\n    blockedTask1[Fix Bug in Payment Module]@{ priority: 'Very High' }\n  Done\n    doneTask1[Deploy Initial Framework]@{ assigned: 'teamLead' }\n    doneTask2[Set up Project Structure]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Generate a kanban board for planning the development phases of a recommendation system for a music streaming app.",
        "planning": "**Kanban Board Columns:**\n\n1.  **Backlog:** All potential tasks, features, and improvements related to the recommendation system.\n2.  **To Do:** Tasks prioritized and ready to be worked on.\n3.  **In Progress:** Tasks currently being worked on by team members.\n4.  **Code Review:** Completed code awaiting review.\n5.  **Testing:** Tasks undergoing testing and quality assurance.\n6.  **Staging:** Tasks deployed to a staging environment for final validation.\n7.  **Done:** Completed and deployed tasks.\n\n**Kanban Cards (Examples):**\n\n*   **Data Collection & Preparation:**\n    *   Card: \"Collect User Listening History Data\"\n    *   Card: \"Clean and Preprocess Music Metadata\"\n*   **Model Development:**\n    *   Card: \"Implement Collaborative Filtering Model\"\n    *   Card: \"Train Content-Based Filtering Model\"\n    *   Card: \"Evaluate Model Performance (Offline)\"\n*   **API Integration:**\n    *   Card: \"Develop Recommendation API Endpoint\"\n    *   Card: \"Integrate API with Music Player\"\n*   **A/B Testing:**\n    *   Card: \"Set up A/B Test for New Recommendation Algorithm\"\n    *   Card: \"Analyze A/B Test Results\"\n*   **Monitoring & Maintenance:**\n    *   Card: \"Monitor Recommendation System Performance\"\n    *   Card: \"Retrain Model with New Data\"\n\n**Interactions & Flow:**\n\n*   Cards move from left to right across the board as work progresses.\n*   The \"To Do\" column is populated from the \"Backlog\" based on priority.\n*   A card is moved to \"In Progress\" when a team member begins working on it.\n*   Completed code moves to \"Code Review\" for quality assurance.\n*   Approved code moves to \"Testing\" for functional validation.\n*   Successfully tested tasks move to \"Staging\" for final review.\n*   Validated features are moved to \"Done\" after deployment.\n*   Feedback from \"Testing\" or \"Staging\" can send a card back to \"In Progress\" or even \"To Do.\"\n*   Regular backlog grooming refines and prioritizes tasks in the \"Backlog.\"",
        "output": "kanban\n  Backlog[Backlog]\n    task1[Collect User Listening History Data]\n    task2[Clean and Preprocess Music Metadata]\n    task3[Implement Collaborative Filtering Model]\n    task4[Train Content-Based Filtering Model]\n    task5[Evaluate Model Performance Offline]\n    task6[Develop Recommendation API Endpoint]\n    task7[Integrate API with Music Player]\n    task8[Set up A/B Test for New Recommendation Algorithm]\n    task9[Analyze A/B Test Results]\n    task10[Monitor Recommendation System Performance]\n    task11[Retrain Model with New Data]\n\n  [To Do]\n    task12[Select Tasks from Backlog]\n\n  [In Progress]\n    task13[Working on Selected Tasks]\n\n  [Code Review]\n    task14[Review Completed Code]\n\n  Testing[Testing]\n    task15[Conduct Testing and QA]\n\n  Staging[Staging]\n    task16[Validate in Staging Environment]\n\n  Done[Done]\n    task17[Completed and Deployed]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Design a kanban board to depict task progress in building a cybersecurity intrusion detection system.",
        "planning": "**Kanban Board Columns:**\n\n*   **Backlog:** Tasks to be done (e.g., Research SIEM tools, Define detection rules).\n*   **To Do:** Prioritized tasks ready to be worked on.\n*   **In Progress:** Tasks currently being worked on (e.g., Writing Snort rules, configuring Suricata).\n*   **Testing/Review:** Tasks completed, undergoing testing and review.\n*   **Done:** Completed and deployed tasks (e.g., SIEM integration complete, baseline rules deployed).\n\n**Kanban Card Components (per task):**\n\n*   **Task Title:** Concise description (e.g., \"Implement Brute Force Detection Rule\").\n*   **Description:** More detailed explanation of the task.\n*   **Assignee:** Person responsible for the task.\n*   **Priority:** High, Medium, Low.\n*   **Dependencies:** Other tasks that must be completed first.\n\n**Interactions:**\n\n1.  Tasks move from *Backlog* to *To Do* based on priority and sprint planning.\n2.  Team members pick tasks from *To Do* and move them to *In Progress*.\n3.  Once completed, tasks move to *Testing/Review*.\n4.  After successful testing/review, tasks move to *Done*.\n5.  Dependencies block movement until predecessor tasks are in *Done*.\n6.  Feedback from testing may move tasks back to *In Progress* for fixes.",
        "output": "kanban\n  Backlog[Backlog]\n    task1[Research SIEM tools]\n    task2[Define detection rules]\n    task3[Plan SIEM Integration]\n  [To Do]\n    task4[Implement Brute Force Detection Rule]@{ priority: 'High' }\n    task5[Configure Suricata]@{ priority: 'Medium' }\n  [In Progress]\n    task6[Writing Snort rules]@{ assigned: 'Alice' }\n  [Testing/Review]\n    task7[SIEM integration complete]@{ assigned: 'Bob' }\n  Done\n    task8[Baseline rules deployed]\n    task9[System Hardening Complete]\n  Rejected\n    task10[Old SIEM Integration Method]"
    },
    {
        "diagram_type": "kanban",
        "prompt": "Create a kanban board representing the steps in performing a basic SWOT analysis for a tech startup.",
        "planning": "**Kanban Board Plan: SWOT Analysis for a Tech Startup**\n\n**Columns (Stages):**\n\n*   **To Do:** Initial stage for tasks.\n*   **Identifying Strengths:** Listing the startup's advantages.\n*   **Identifying Weaknesses:** Listing the startup's disadvantages.\n*   **Identifying Opportunities:** Listing external factors that could benefit the startup.\n*   **Identifying Threats:** Listing external factors that could harm the startup.\n*   **Analyzing SWOT:** Combining and interpreting the identified factors.\n*   **Action Planning:** Developing strategies based on SWOT analysis.\n*   **Review/Refine:** Review and refine strategies.\n*   **Done:** Completed tasks.\n\n**Cards (Tasks):**\n\n*   Each card represents a specific task within the SWOT analysis process.\n\n**Interactions:**\n\n1.  Cards move sequentially from \"To Do\" through each identification column (Strengths, Weaknesses, Opportunities, Threats).\n2.  Once all factors are identified, cards related to \"Analyzing SWOT\" are moved to the \"Analyzing SWOT\" column.\n3.  \"Action Planning\" cards are then moved to the \"Action Planning\" column based on the SWOT analysis.\n4.  \"Review/Refine\" cards are moved to the \"Review/Refine\" column to ensure strategy effectiveness.\n5.  Finally, cards are moved to \"Done\" upon completion.",
        "output": "kanban\n  todo[To Do]\n    task1[Define SWOT Analysis Scope]\n    task2[Gather Information about Startup]\n\n  identifying_strengths[Identifying Strengths]\n    strength_task1[List Core Competencies]\n    strength_task2[Identify Competitive Advantages]\n\n  identifying_weaknesses[Identifying Weaknesses]\n    weakness_task1[List Operational Inefficiencies]\n    weakness_task2[Identify Resource Constraints]\n\n  identifying_opportunities[Identifying Opportunities]\n    opportunity_task1[Research Market Trends]\n    opportunity_task2[Identify Potential Partnerships]\n\n  identifying_threats[Identifying Threats]\n    threat_task1[Analyze Competitive Landscape]\n    threat_task2[Assess Regulatory Changes]\n\n  analyzing_swot[Analyzing SWOT]\n    swot_task1[Combine Strengths Weaknesses Opportunities Threats]\n    swot_task2[Identify Key Strategic Insights]\n\n  action_planning[Action Planning]\n    action_task1[Develop Growth Strategies]\n    action_task2[Formulate Risk Mitigation Plans]\n\n  review_refine[Review/Refine]\n    review_task1[Evaluate Strategy Effectiveness]\n    review_task2[Refine Action Plans]\n\n  done[Done]\n    done_task1[Finalize SWOT Report]\n    done_task2[Implement Actionable Strategies]"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Create a mindmap diagram outlining the key steps and transitions in establishing a TCP connection.",
        "planning": "*   **Center Node:** TCP Connection Establishment (3-Way Handshake)\n*   **Node 1: Client (Initiator)**\n    *   **Action:** Sends SYN (synchronize) packet.\n    *   **Interaction:** Transmits SYN to the Server.\n    *   **State:** SYN-SENT\n*   **Node 2: Server (Receiver)**\n    *   **Action:** Receives SYN, sends SYN-ACK (synchronize-acknowledge) packet.\n    *   **Interaction:** Receives SYN from Client, transmits SYN-ACK back to the Client.\n    *   **State:** SYN-RECEIVED\n*   **Node 3: Client (Completes Handshake)**\n    *   **Action:** Receives SYN-ACK, sends ACK (acknowledgement) packet.\n    *   **Interaction:** Receives SYN-ACK from Server, transmits ACK back to Server.\n    *   **State:** ESTABLISHED\n*   **Node 4: Server (Connection Established)**\n    *   **Action:** Receives ACK.\n    *   **Interaction:** Receives ACK from Client.\n    *   **State:** ESTABLISHED\n*   **Arrows:**\n    *   Client -> Server: SYN\n    *   Server -> Client: SYN-ACK\n    *   Client -> Server: ACK",
        "output": "mindmap\n  root((TCP Connection Establishment))\n    ClientInitiator[Client Initiator]\n      Action1[Sends SYN packet]\n      Interaction1[Transmits SYN to Server]\n      State1[SYN-SENT]\n    ServerReceiver[Server Receiver]\n      Action2[Receives SYN sends SYN-ACK packet]\n      Interaction2[Receives SYN from Client transmits SYN-ACK back]\n      State2[SYN-RECEIVED]\n    ClientCompletes[Client Completes Handshake]\n      Action3[Receives SYN-ACK sends ACK packet]\n      Interaction3[Receives SYN-ACK transmits ACK back]\n      State3[ESTABLISHED]\n    ServerEstablished[Server Connection Established]\n      Action4[Receives ACK]\n      Interaction4[Receives ACK from Client]\n      State4[ESTABLISHED]"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Develop a mindmap diagram representing the flow of data packets during a TCP transmission.",
        "planning": "*   **Central Node:** \"TCP Transmission\"\n\n*   **Nodes Branching Out:**\n\n    *   **Application Layer:**\n        *   Data Generation:  Application creates data to send.  Flows into \"TCP Segment Creation\".\n    *   **TCP Layer (Source):**\n        *   TCP Segment Creation:  Divides data into segments, adds TCP header (source/dest port, sequence numbers, flags). Flows from \"Application Layer\", flows into \"IP Layer (Source)\".\n        *   Connection Establishment (3-way handshake): SYN, SYN-ACK, ACK.  Interactive flow with \"TCP Layer (Destination)\".\n        *   Data Transmission: Data segments sent. Flows into \"IP Layer (Source)\".\n        *   Acknowledgement (ACK) Handling: Receiving ACK segments. Flows from \"IP Layer (Destination)\".\n        *   Retransmission: Resending lost segments. Flows into \"IP Layer (Source)\". triggered by missing ACKs.\n        *   Flow Control:  Advertised window (receiver buffer size).  Affects rate of data sent to \"IP Layer (Source)\". Flows from \"TCP Layer (Destination)\".\n        *   Congestion Control: Adjusting sending rate based on network congestion. Affects rate of data sent to \"IP Layer (Source)\". Flows from \"IP Layer (Destination)\". (Implied feedback)\n        *   Connection Termination (4-way handshake): FIN, ACK, FIN, ACK. Interactive flow with \"TCP Layer (Destination)\".\n\n    *   **IP Layer (Source):**\n        *   IP Packet Creation: Adds IP header (source/dest IP). Flows from \"TCP Layer (Source)\", flows into \"Network Layer/Router\".\n        *   Routing: Determining the next hop. Flows from \"TCP Layer (Source)\", flows into \"Network Layer/Router\".\n\n    *   **Network Layer/Router:**\n        *   Packet Forwarding:  Routes packets towards destination.  Flows from \"IP Layer (Source)\", flows into \"IP Layer (Destination)\".\n\n    *   **IP Layer (Destination):**\n        *   IP Packet Reception: Receives IP packets. Flows from \"Network Layer/Router\", flows into \"TCP Layer (Destination)\".\n\n    *   **TCP Layer (Destination):**\n        *   TCP Segment Reception: Receives TCP segments. Flows from \"IP Layer (Destination)\".\n        *   Reassembly:  Orders segments based on sequence numbers. Flows from \"IP Layer (Destination)\", flows into \"Application Layer\".\n        *   Acknowledgement (ACK) Generation:  Sends ACKs for received segments. Flows into \"IP Layer (Destination)\".\n        *   Flow Control (Advertised Window): Informs the sender about receiver buffer capacity. Flows to \"TCP Layer (Source)\".\n\n    *   **Application Layer (Destination):**\n        *   Data Reception: Receives reassembled data.  Flows from \"TCP Layer (Destination)\".",
        "output": "mindmap\n  root((TCP Transmission))\n\n    ApplicationLayerSource[Application Layer Source]\n      DataGeneration[Data Generation: Application creates data]\n        :::label\n\n    TCPLayerSource[TCP Layer Source]\n      TCPSegmentCreation[TCP Segment Creation: Divides data into segments, adds TCP header]\n        :::label\n      ConnectionEstablishment[Connection Establishment: SYN, SYN-ACK, ACK]\n        :::label\n      DataTransmission[Data Transmission: Data segments sent]\n        :::label\n      AcknowledgementHandling[Acknowledgement Handling: Receiving ACK segments]\n        :::label\n      Retransmission[Retransmission: Resending lost segments]\n        :::label\n      FlowControlSource[Flow Control: Advertised window receiver buffer size]\n        :::label\n      CongestionControl[Congestion Control: Adjusting sending rate]\n        :::label\n      ConnectionTermination[Connection Termination: FIN, ACK, FIN, ACK]\n        :::label\n\n    IPLayerSource[IP Layer Source]\n      IPPacketCreationSource[IP Packet Creation: Adds IP header]\n        :::label\n      RoutingSource[Routing: Determining the next hop]\n        :::label\n\n    NetworkLayerRouter[Network Layer/Router]\n      PacketForwarding[Packet Forwarding: Routes packets towards destination]\n        :::label\n\n    IPLayerDestination[IP Layer Destination]\n      IPPacketReception[IP Packet Reception: Receives IP packets]\n        :::label\n\n    TCPLayerDestination[TCP Layer Destination]\n      TCPSegmentReception[TCP Segment Reception: Receives TCP segments]\n        :::label\n      Reassembly[Reassembly: Orders segments based on sequence numbers]\n        :::label\n      AcknowledgementGeneration[Acknowledgement Generation: Sends ACKs for received segments]\n        :::label\n      FlowControlDestination[Flow Control Advertised Window]\n        :::label\n\n    ApplicationLayerDestination[Application Layer Destination]\n      DataReception[Data Reception: Receives reassembled data]\n        :::label\n\n\n  ApplicationLayerSource --> TCPLayerSource\n  TCPLayerSource --> IPLayerSource\n  IPLayerSource --> NetworkLayerRouter\n  NetworkLayerRouter --> IPLayerDestination\n  IPLayerDestination --> TCPLayerDestination\n  TCPLayerDestination --> ApplicationLayerDestination\n\n  TCPSegmentCreation -- ApplicationLayerSource\n  DataTransmission -- TCPLayerSource\n  Retransmission -- TCPLayerSource\n  FlowControlSource -- TCPLayerSource\n  CongestionControl -- TCPLayerSource\n  ConnectionTermination -- TCPLayerSource\n\n  IPPacketCreationSource -- IPLayerSource\n  RoutingSource -- IPLayerSource\n\n  IPPacketReception -- IPLayerDestination\n\n  TCPSegmentReception -- TCPLayerDestination\n  Reassembly -- TCPLayerDestination\n  AcknowledgementGeneration -- TCPLayerDestination"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Generate a mindmap diagram illustrating the authentication process of OAuth in a web application.",
        "planning": "*   **Title:** OAuth Authentication Process in a Web Application\n\n*   **Central Node:** Web Application\n\n*   **Branches:**\n\n    *   **User:**\n        *   Authenticates with Web Application\n        *   Authorizes Access to Protected Resources\n    *   **Web Application (Client):**\n        *   Requests Authorization from Authorization Server\n        *   Receives Authorization Grant\n        *   Requests Access Token from Authorization Server\n        *   Receives Access Token\n        *   Requests Protected Resources from Resource Server using Access Token\n    *   **Authorization Server (e.g., Google, Facebook):**\n        *   Authenticates User\n        *   Requests User Consent\n        *   Issues Authorization Grant\n        *   Issues Access Token\n        *   Validates Access Token\n    *   **Resource Server (e.g., API):**\n        *   Hosts Protected Resources\n        *   Receives Request with Access Token\n        *   Validates Access Token with Authorization Server (or directly if JWT)\n        *   Provides Protected Resources if Access Token is Valid\n    *   **Authorization Grant (e.g., Authorization Code):**\n        *   Represents User's authorization\n        *   Exchanged for an Access Token\n\n*   **Interactions (Arrows/Lines):**\n\n    *   User -> Web Application: Login (Initial Authentication)\n    *   Web Application -> Authorization Server: Authorization Request\n    *   Authorization Server -> User: Authentication & Consent\n    *   Authorization Server -> Web Application: Authorization Grant\n    *   Web Application -> Authorization Server: Access Token Request\n    *   Authorization Server -> Web Application: Access Token\n    *   Web Application -> Resource Server: Protected Resource Request (with Access Token)\n    *   Resource Server -> Authorization Server: Access Token Validation (Optional)\n    *   Resource Server -> Web Application: Protected Resource Response",
        "output": "mindmap\n  root((Web Application))\n\n    User\n      Authenticates with Web Application\n      Authorizes Access to Protected Resources\n\n    Web_Application_Client[Web Application Client]\n      Requests Authorization from Auth Server\n      Receives Authorization Grant\n      Requests Access Token from Auth Server\n      Receives Access Token\n      Requests Protected Resources from Resource Server\n\n    Authorization_Server[Authorization Server]\n      Authenticates User\n      Requests User Consent\n      Issues Authorization Grant\n      Issues Access Token\n      Validates Access Token\n\n    Resource_Server[Resource Server]\n      Hosts Protected Resources\n      Receives Request with Access Token\n      Validates Access Token with Auth Server\n      Provides Protected Resources if Access Token is Valid\n\n    Authorization_Grant[Authorization Grant]\n      Represents User's authorization\n      Exchanged for an Access Token"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Design a mindmap diagram mapping out the main components and operations of RSA cryptography.",
        "planning": "*   **RSA Cryptography (Central Topic)**\n\n    *   **Key Generation:**\n        *   **Prime Number Generation (p, q):** Selecting two large prime numbers.\n        *   **Modulus Calculation (n):**  n = p * q.  Used in both encryption and decryption.\n        *   **Totient Calculation (\u03c6(n)):** \u03c6(n) = (p-1)(q-1). Used to calculate e and d.\n        *   **Public Key (e):** 1 < e < \u03c6(n), gcd(e, \u03c6(n)) = 1. Used for encryption.\n        *   **Private Key (d):** d \u2261 e^-1 (mod \u03c6(n)). Used for decryption.\n\n    *   **Encryption:**\n        *   **Plaintext (M):** The original message.\n        *   **Public Key (e, n):** Used to encrypt the plaintext.\n        *   **Ciphertext (C):** C = M^e mod n. The encrypted message.\n\n    *   **Decryption:**\n        *   **Ciphertext (C):** The encrypted message to be decrypted.\n        *   **Private Key (d, n):** Used to decrypt the ciphertext.\n        *   **Plaintext (M):** M = C^d mod n. The original message recovered.",
        "output": "mindmap\n  root((RSA Cryptography))\n    KeyGeneration\n      PrimeNumberGeneration[Prime Number Generation]:::longtext\n        p[p:::innertext]\n        q[q:::innertext]\n      ModulusCalculation[Modulus Calculation]:::longtext\n        n[n = p * q:::innertext]\n      TotientCalculation[Totient Calculation]:::longtext\n        phi[\u03c6(n) = (p-1)(q-1):::innertext]\n      PublicKey[Public Key]:::longtext\n        e[1 < e < \u03c6(n), gcd(e, \u03c6(n)) = 1:::innertext]\n      PrivateKey[Private Key]:::longtext\n        d[d \u2261 e^-1 (mod \u03c6(n)):::innertext]\n\n    Encryption\n      Plaintext[Plaintext]:::longtext\n        M[M:::innertext]\n      PublicKeyEncryption[Public Key]:::longtext\n        en[e, n:::innertext]\n      Ciphertext[Ciphertext]:::longtext\n        C[C = M^e mod n:::innertext]\n\n    Decryption\n      CiphertextDecryption[Ciphertext]:::longtext\n        C2[C:::innertext]\n      PrivateKeyDecryption[Private Key]:::longtext\n        dn[d, n:::innertext]\n      PlaintextDecryption[Plaintext]:::longtext\n        M2[M = C^d mod n:::innertext]\n\n\nclassDef longtext fill:#f9f,stroke:#333,stroke-width:2px\nclassDef innertext fill:#ccf,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Create a mindmap diagram highlighting the primary modules and interactions in a basic e-commerce application.",
        "planning": "**Central Node:** E-commerce Application\n\n**Main Modules (Branches):**\n\n*   **Product Catalog:** Stores product info; interacts with Search, Cart, and Order modules.\n*   **User Management:** Handles accounts, authentication; interacts with all modules requiring user info.\n*   **Shopping Cart:** Stores selected items; interacts with Product Catalog and Checkout modules.\n*   **Checkout:** Processes payment, shipping info; interacts with Cart, Payment Gateway, and Order modules.\n*   **Payment Gateway:** Securely processes payments; interacts with Checkout.\n*   **Order Management:** Tracks order status; interacts with User Management and potentially a Shipping module (if separate).\n*   **Search:** Enables product search; interacts with Product Catalog.\n\n**Interactions (Connections):**\n\n*   Arrows showing data flow/dependencies (e.g., Product Catalog provides product data to Cart).\n*   Clearly label arrow directions to signify the flow of information.",
        "output": "mindmap\n  root((E-commerce Application))\n    ProductCatalog[Product Catalog]\n      InteractsWith1(Search)\n      InteractsWith2(Cart)\n      InteractsWith3(Order Management)\n    UserManagement[User Management]\n      InteractsWithAll((All Modules))\n    ShoppingCart[Shopping Cart]\n      InteractsWith4(Product Catalog)\n      InteractsWith5(Checkout)\n    Checkout\n      ProcessesPayment[Processes Payment \\& Shipping Info]\n      InteractsWith6(Cart)\n      InteractsWith7(Payment Gateway)\n      InteractsWith8(Order Management)\n    PaymentGateway[Payment Gateway]\n      SecurelyProcessesPayments[Securely Processes Payments]\n      InteractsWith9(Checkout)\n    OrderManagement[Order Management]\n      TracksOrderStatus[Tracks Order Status]\n      InteractsWith10(User Management)"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Construct a mindmap diagram delineating the architecture of a simple chat app and its communication flow.",
        "planning": "**Central Topic:** Simple Chat App Architecture\n\n**Main Branches:**\n\n*   **Client (User Interface):**\n    *   Sub-branches: Input Field, Message Display, User List.\n    *   Interaction: Sends messages to Server, Receives messages from Server, Displays user list.\n\n*   **Server:**\n    *   Sub-branches: Connection Handler, Message Router, Database (optional).\n    *   Interaction: Manages client connections, Routes messages between clients, Stores message history (optional).\n\n*   **Communication Flow:**\n    *   Sub-branches: Send Message, Receive Message.\n    *   Interaction: Client sends message to Server; Server routes message to recipient Client(s); Recipient Client displays message.",
        "output": "mindmap\n  root((Simple Chat App Architecture))\n\n    Client[User Interface]\n      Input Field\n      Message Display\n      User List\n      Interaction::icon(fa fa-arrow-right)\n        Sends messages to Server\n        Receives messages from Server\n        Displays user list\n\n    Server\n      Connection Handler\n      Message Router\n      Database)Optional(\n      Interaction::icon(fa fa-arrow-right)\n        Manages client connections\n        Routes messages between clients\n        Stores message history)optional(\n\n    Communication Flow\n      Send Message\n      Receive Message\n      Interaction::icon(fa fa-arrow-right)\n        Client sends message to Server\n        Server routes message to recipient Client\n        Recipient Client displays message"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Design a mindmap diagram depicting the structure of a UDP packet and its key elements.",
        "planning": "*   **Central Topic:** UDP Packet Structure\n\n*   **Main Branches:**\n    *   **Header:**\n        *   Source Port Number: *Identifies sender's port.*\n        *   Destination Port Number: *Identifies receiver's port.*\n        *   Length: *Total length (header + data).*\n        *   Checksum: *Optional error detection.*\n    *   **Data (Payload):**\n        *   Application Data: *Actual data being transmitted.*\n        *   Variable Length: *Can be empty.*\n\n*   **Interactions/Relationships:**\n    *   Header fields provide addressing and control information *for* the Data.\n    *   Length field indicates the *size* of Header + Data.\n    *   Checksum (if used) *protects* Header and Data *against* errors.\n    *   Source and Destination Ports *enable* multiplexing and demultiplexing at sender and receiver.",
        "output": "mindmap\n  root((UDP Packet Structure))\n    Header\n      SourcePort[Source Port Number]\n        :::small\n        Identifies sender's port\n      DestinationPort[Destination Port Number]\n        :::small\n        Identifies receiver's port\n      Length\n        :::small\n        Total length header plus data\n      Checksum\n        :::small\n        Optional error detection\n    DataPayload[Data Payload]\n      ApplicationData[Application Data]\n        :::small\n        Actual data transmitted\n      VariableLength[Variable Length]\n        :::small\n        Can be empty\n\nclassDef small font-size:8pt;"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Generate a mindmap diagram that organizes the phases of a Kanban board used in project management.",
        "planning": "**Central Topic:** Kanban Board Phases\n\n**Main Branches:**\n\n*   **To Do:**\n    *   Description: Tasks waiting to be started.\n    *   Interaction: Feeds into \"In Progress\".\n*   **In Progress (Doing):**\n    *   Description: Tasks currently being worked on.\n    *   Interaction: Receives from \"To Do\", feeds into \"Review/Testing\" or \"Done\".\n*   **Review/Testing (Optional):**\n    *   Description: Tasks awaiting review and testing.\n    *   Interaction: Receives from \"In Progress,\" can send back to \"In Progress\" for rework, or forwards to \"Done.\"\n*   **Done:**\n    *   Description: Completed tasks.\n    *   Interaction: Receives from \"In Progress\" or \"Review/Testing\". Represents final stage.\n\n**Additional Considerations (Sub-branches or Connecting Elements):**\n\n*   **Blockers/Impediments:**\n    *   Description: Factors that prevent task movement.\n    *   Interaction: Can affect any phase (To Do, In Progress, Review/Testing).\n*   **Workflow Policies:**\n    *   Description: Rules governing task movement between phases (e.g., WIP limits).\n    *   Interaction: Impacts all phases.\n*   **Prioritization:**\n    *   Description: Methods to order tasks in the \"To Do\" column.\n    *   Interaction: Primarily affects \"To Do\" and influences task selection for \"In Progress\".",
        "output": "mindmap\n  root((Kanban Board Phases))\n    To Do\n      Description: Tasks waiting to be started\n      Interaction: Feeds into In Progress\n    In Progress Doing\n      Description: Tasks currently being worked on\n      Interaction: Receives from To Do feeds into Review-Testing or Done\n    Review-Testing Optional\n      Description: Tasks awaiting review and testing\n      Interaction: Receives from In Progress can send back to In Progress or forwards to Done\n    Done\n      Description: Completed tasks\n      Interaction: Receives from In Progress or Review-Testing Represents final stage\n    Blockers-Impediments\n      Description: Factors that prevent task movement\n      Interaction: Can affect any phase To Do In Progress Review-Testing\n    Workflow Policies\n      Description: Rules governing task movement between phases e.g. WIP limits\n      Interaction: Impacts all phases\n    Prioritization\n      Description: Methods to order tasks in the To Do column\n      Interaction: Primarily affects To Do and influences task selection for In Progress"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Create a mindmap diagram showcasing the conceptual flow of a square wave pulse generation in a signal processing context.",
        "planning": "**Central Topic:** Square Wave Pulse Generation\n\n**Main Branches:**\n\n1.  **Input/Trigger:**\n    *   *Description:* Source initiating square wave generation.\n    *   *Elements:* Clock Signal, External Trigger, Timer Event.\n    *   *Interaction:* Activates the process.\n\n2.  **Threshold/Comparison:**\n    *   *Description:* Determines high/low state transitions.\n    *   *Elements:* Comparator, Reference Voltage/Level.\n    *   *Interaction:* Compares input signal to threshold, switching output state.\n\n3.  **State Control/Logic:**\n    *   *Description:* Manages high/low output states.\n    *   *Elements:* Flip-Flop, Logic Gates (AND, NOT), Timer/Counter.\n    *   *Interaction:* Switches between high and low states based on comparison result and timing.\n\n4.  **Output Shaping:**\n    *   *Description:* Refines the square wave's characteristics.\n    *   *Elements:* Amplifier, Filter (low pass for smoothing), Schmitt Trigger (sharpen edges).\n    *   *Interaction:* Improves rise/fall times, amplitude, and reduces noise.\n\n5.  **Output:**\n    *   *Description:* The generated square wave pulse.\n    *   *Elements:* Square Waveform, Amplitude, Frequency, Duty Cycle.\n    *   *Interaction:* Final signal ready for use.\n\n**Interactions (between Branches):**\n\n*   Input triggers Threshold/Comparison.\n*   Threshold/Comparison signal feeds into State Control/Logic.\n*   State Control manages Output Shaping.\n*   Output Shaping generates the final Output.",
        "output": "mindmap\n  root((Square Wave Pulse Generation))\n\n    InputTrigger\n      Description: Source initiating wave generation\n      Elements\n        ClockSignal[Clock Signal]\n        ExternalTrigger[External Trigger]\n        TimerEvent[Timer Event]\n      Interaction: Activates the process\n\n    ThresholdComparison\n      Description: Determines high/low state transitions\n      Elements\n        Comparator[Comparator]\n        ReferenceVoltage[Reference Voltage]\n      Interaction: Compares input signal to threshold\n\n    StateControlLogic\n      Description: Manages high/low output states\n      Elements\n        FlipFlop[Flip-Flop]\n        LogicGates[Logic Gates]\n        TimerCounter[Timer/Counter]\n      Interaction: Switches between high and low states\n\n    OutputShaping\n      Description: Refines the wave's characteristics\n      Elements\n        Amplifier[Amplifier]\n        Filter[Filter]\n        SchmittTrigger[Schmitt Trigger]\n      Interaction: Improves rise/fall times\n\n    Output\n      Description: The generated wave pulse\n      Elements\n        SquareWaveform[Square Waveform]\n        Amplitude[Amplitude]\n        Frequency[Frequency]\n        DutyCycle[Duty Cycle]\n      Interaction: Final signal ready for use"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Develop a mindmap diagram mapping the core elements of a RAG (retrieval-augmented generation) based system.",
        "planning": "*   **Central Node:** RAG System\n\n*   **Branch 1: Retrieval**\n    *   **Node:** Data Source(s) (e.g., Documents, Knowledge Base, Web Pages)\n    *   **Node:** Indexing (Preparing data for efficient retrieval)\n        *   Connection to Data Source(s): Feeds data into indexing.\n    *   **Node:** Vector Database/Index (Stores embeddings of data)\n        *   Connection to Indexing: Stores the indexed data.\n    *   **Node:** Query Encoder (Transforms user query into vector embedding)\n    *   **Node:** Similarity Search (Finds relevant documents in Vector Database)\n        *   Connection to Query Encoder: Uses query embedding.\n        *   Connection to Vector Database/Index: Searches for similar embeddings.\n    *   Connection to RAG System: Provides retrieved context.\n\n*   **Branch 2: Generation**\n    *   **Node:** Prompt Engineering (Designing effective prompts)\n    *   **Node:** LLM (Large Language Model - Generates the answer)\n        *   Connection to Retrieval: Receives retrieved context and user query as input.\n        *   Connection to Prompt Engineering: Uses prompts to guide the LLM.\n    *   **Node:** Response (Generated Answer)\n    *   Connection to RAG System: Outputs the final answer.\n\n*   **Branch 3: User Input**\n    *   **Node:** User Query\n    *   Connection to Query Encoder and LLM: Provides initial input to the system.",
        "output": "mindmap\n  root((RAG System))\n\n    Retrieval\n      Data_Sources[Data Source(s)]\n      Indexing(Indexing)\n      Vector_DB[Vector Database/Index]\n      Query_Encoder(Query Encoder)\n      Similarity_Search[Similarity Search]\n\n      Indexing -- Feeds data into --> Data_Sources\n      Vector_DB -- Stores --> Indexing\n      Similarity_Search -- Uses --> Query_Encoder\n      Similarity_Search -- Searches --> Vector_DB\n\n    Generation\n      Prompt_Engineering[Prompt Engineering]\n      LLM((LLM))\n      Response(Response)\n\n      LLM -- Receives --> Retrieval\n      LLM -- Uses --> Prompt_Engineering\n\n    User_Input\n      User_Query[User Query]\n\n      User_Query -- Input to --> Query_Encoder\n      User_Query -- Input to --> LLM\n\n  linkStyle default stroke:#333, stroke-width:2px;"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Produce a mindmap diagram outlining the state transitions in fork-join processes within a parallel computing system.",
        "planning": "*   **Central Node: \"Fork-Join Process\"** - Represents the overall parallel execution model.\n\n*   **Nodes emanating from \"Fork-Join Process\":**\n    *   **Fork:** Creation of parallel tasks.\n        *   Interaction: Splits the main task into subtasks.\n    *   **Join:** Synchronization point; waits for subtasks to complete.\n        *   Interaction: Combines results from parallel tasks.\n\n*   **Nodes emanating from \"Fork\":**\n    *   **Task Creation:** Assignment of work to threads/processes.\n        *   Interaction: Initiates independent execution.\n    *   **Task Queue/Pool:** Holding area for tasks.\n        *   Interaction: Manages tasks waiting for execution.\n    *   **Task Execution:** Actual parallel processing.\n        *   Interaction: Executes tasks concurrently.\n\n*   **Nodes emanating from \"Join\":**\n    *   **Synchronization:** Waiting for all tasks to finish.\n        *   Interaction: Ensures all parallel work is completed.\n    *   **Result Aggregation:** Combining results from tasks.\n        *   Interaction: Merges partial results into a final output.\n    *   **Continuation:** Resuming execution of the main process.\n        *   Interaction: Proceeds with the computation after parallel phase.\n\n*   **Optional Nodes (depending on detail level):**\n    *   **Thread/Process Management:** (Under Fork/Task Execution)\n        *   Interaction: Handling thread/process creation and lifecycle.\n    *   **Error Handling:** (Under any node)\n        *   Interaction: Managing exceptions and failures in parallel tasks.\n    *   **Communication:** (Between Tasks - if shared memory isn't used)\n        *   Interaction: Data exchange during Task Execution",
        "output": "mindmap\n  root((Fork-Join Process))\n    Fork\n      Task_Creation[Task Creation]\n        Interaction1[Splits main task into subtasks]\n      Task_Queue_Pool[Task Queue/Pool]\n        Interaction2[Manages tasks waiting]\n      Task_Execution[Task Execution]\n        Interaction3[Executes tasks concurrently]\n    Join\n      Synchronization\n        Interaction4[Waiting for all tasks to finish]\n      Result_Aggregation[Result Aggregation]\n        Interaction5[Merges partial results]\n      Continuation\n        Interaction6[Resuming main process]\n\n  style Fork fill:#f9f,stroke:#333,stroke-width:2px\n  style Join fill:#ccf,stroke:#333,stroke-width:2px\n  style Task_Creation fill:#ffc,stroke:#333,stroke-width:2px\n  style Task_Queue_Pool fill:#ffc,stroke:#333,stroke-width:2px\n  style Task_Execution fill:#ffc,stroke:#333,stroke-width:2px\n  style Synchronization fill:#cff,stroke:#333,stroke-width:2px\n  style Result_Aggregation fill:#cff,stroke:#333,stroke-width:2px\n  style Continuation fill:#cff,stroke:#333,stroke-width:2px"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Generate a mindmap diagram to display the SWOT analysis of OpenAI in a structured manner.",
        "planning": "*   **Central Node:** \"OpenAI SWOT Analysis\"\n\n*   **Main Branches (SWOT):**\n    *   **Strengths:** Points leading to competitive advantages.\n        *   Interaction: Feed into Opportunities.\n    *   **Weaknesses:** Points leading to vulnerabilities.\n        *   Interaction: Made worse by Threats.\n    *   **Opportunities:** External factors OpenAI can capitalize on.\n        *   Interaction: Leverage Strengths.\n        *   Interaction: Mitigate Weaknesses.\n    *   **Threats:** External factors that could harm OpenAI.\n        *   Interaction: Exacerbate Weaknesses.\n        *   Interaction: Minimize Impact with Strengths.\n\n*   **Sub-Branches (Examples, inside each SWOT branch):**\n    *   **Strengths:**\n        *   Advanced AI Models (e.g., GPT Series)\n        *   Strong Research Team\n        *   Large Datasets\n        *   Brand Reputation\n    *   **Weaknesses:**\n        *   High Operational Costs\n        *   Ethical Concerns (Bias, Misinformation)\n        *   Dependence on Large Datasets\n        *   Explainability Issues (Black Box problem)\n    *   **Opportunities:**\n        *   Expanding into New Industries\n        *   Partnerships and Collaborations\n        *   Further Research and Development\n        *   Growing AI Market\n    *   **Threats:**\n        *   Increased Competition\n        *   Regulatory Scrutiny\n        *   Economic Downturn\n        *   Rapid Technological Advancements (becoming obsolete)",
        "output": "mindmap\n  root((OpenAI SWOT Analysis))\n    Strengths\n      Advanced AI Models\n      Strong Research Team\n      Large Datasets\n      Brand Reputation\n    Weaknesses\n      High Operational Costs\n      Ethical Concerns\n      Dependence on Data\n      Explainability Issues\n    Opportunities\n      Expanding Industries\n      Partnerships\n      Further R&D\n      Growing AI Market\n    Threats\n      Increased Competition\n      Regulatory Scrutiny\n      Economic Downturn\n      Technological Change"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Generate a mindmap diagram to display the SWOT analysis of Google with clear categorization.",
        "planning": "*   **Central Topic:** Google (placed in the center of the mindmap)\n\n*   **Main Branches (Radiating from the center):**\n    *   Strengths\n    *   Weaknesses\n    *   Opportunities\n    *   Threats\n\n*   **Strengths (Branch):**\n    *   Brand Recognition: Globally recognized and trusted.\n    *   Innovation: Constant development of new products and services.\n    *   Market Share: Dominant in search, browser, mobile OS, etc.\n    *   Financial Resources: Massive revenue and cash reserves.\n    *   Data Analytics: Sophisticated data collection and analysis capabilities.\n\n*   **Weaknesses (Branch):**\n    *   Privacy Concerns: Public scrutiny and regulatory pressure.\n    *   Dependence on Advertising: Revenue heavily reliant on ads.\n    *   Innovation failures: Some products/services discontinued (e.g., Google Glass).\n    *   Monopolistic Practices: Antitrust investigations and legal challenges.\n\n*   **Opportunities (Branch):**\n    *   Emerging Markets: Expanding internet access in developing countries.\n    *   Artificial Intelligence (AI): Advancements in AI and machine learning.\n    *   Cloud Computing: Growing demand for cloud services (Google Cloud).\n    *   New Technologies: Investing in areas like self-driving cars (Waymo) and biotech.\n\n*   **Threats (Branch):**\n    *   Competition: Intense rivalry from companies like Microsoft, Apple, Amazon, Meta.\n    *   Changing Consumer Preferences: Shifting trends in online behavior.\n    *   Regulation: Government regulations regarding data privacy, antitrust, and taxation.\n    *   Cybersecurity: Increasing threats of cyberattacks and data breaches.",
        "output": "mindmap\n  root((Google))\n    Strengths\n      Brand_Recognition[Brand Recognition: Globally recognized and trusted]\n      Innovation[Innovation: Constant development of new products and services]\n      Market_Share[Market Share: Dominant in search browser mobile OS etc]\n      Financial_Resources[Financial Resources: Massive revenue and cash reserves]\n      Data_Analytics[Data Analytics: Sophisticated data collection and analysis capabilities]\n    Weaknesses\n      Privacy_Concerns[Privacy Concerns: Public scrutiny and regulatory pressure]\n      Dependence_on_Advertising[Dependence on Advertising: Revenue heavily reliant on ads]\n      Innovation_Failures[Innovation failures: Some products/services discontinued e.g. Google Glass]\n      Monopolistic_Practices[Monopolistic Practices: Antitrust investigations and legal challenges]\n    Opportunities\n      Emerging_Markets[Emerging Markets: Expanding internet access in developing countries]\n      AI[Artificial Intelligence AI: Advancements in AI and machine learning]\n      Cloud_Computing[Cloud Computing: Growing demand for cloud services Google Cloud]\n      New_Technologies[New Technologies: Investing in areas like self-driving cars Waymo and biotech]\n    Threats\n      Competition[Competition: Intense rivalry from companies like Microsoft Apple Amazon Meta]\n      Changing_Consumer_Preferences[Changing Consumer Preferences: Shifting trends in online behavior]\n      Regulation[Regulation: Government regulations regarding data privacy antitrust and taxation]\n      Cybersecurity[Cybersecurity: Increasing threats of cyberattacks and data breaches]"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Construct a mindmap diagram that captures the main components and message flow in a message queue system like RabbitMQ.",
        "planning": "*   **Central Topic:** RabbitMQ Message Queue System\n\n*   **Main Components (Branches):**\n    *   **Producers:**\n        *   Sends messages to Exchanges.\n        *   Specifies routing key.\n    *   **Exchanges:**\n        *   Receives messages from Producers.\n        *   Routes messages to Queues based on bindings and routing key.\n        *   Exchange Types (Direct, Topic, Fanout, Headers).\n    *   **Queues:**\n        *   Stores messages.\n        *   Receives messages from Exchanges.\n    *   **Consumers:**\n        *   Receives messages from Queues.\n        *   Processes messages.\n        *   Acknowledges messages.\n\n*   **Message Flow (Connections/Arrows):**\n    *   Producer -> Exchange: Message + Routing Key\n    *   Exchange -> Queue: Message (based on routing rules/bindings)\n    *   Queue -> Consumer: Message\n    *   Consumer -> Queue/RabbitMQ: Acknowledgment/Negative Acknowledgment\n\n*   **Key Concepts (Smaller Nodes branching from components):**\n    *   **Bindings:** Link between Exchange and Queue (Routing Key). Under Exchange.\n    *   **Routing Key:** Used by Producer and Exchange for routing. Under Producer and Exchange.\n    *   **Acknowledgments:** Confirmation of message processing. Under Consumer and Queue.",
        "output": "mindmap\n  root((RabbitMQ Message Queue System))\n\n    Producers\n      Sends messages to Exchanges\n      Specifies routing key\n      Routing Key\n\n    Exchanges\n      Receives messages from Producers\n      Routes messages to Queues\n      Exchange Types\n        Direct\n        Topic\n        Fanout\n        Headers\n      Bindings\n      Routing Key\n\n    Queues\n      Stores messages\n      Receives messages from Exchanges\n      Acknowledgments\n\n    Consumers\n      Receives messages from Queues\n      Processes messages\n      Acknowledges messages\n      Acknowledgments"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Design a mindmap diagram detailing the learning process and module structure of a typical online learning management system.",
        "planning": "**Central Topic:** Online Learning Management System (LMS) Learning Process & Module Structure\n\n**Main Branches:**\n\n1.  **Learning Process:**\n    *   **Enrollment:** (Student signs up) Leads to Course Access.\n    *   **Course Access:** (Access to content) Interacts with Content Modules and Assessment Modules.\n    *   **Content Consumption:** (Reading materials, videos, etc.) Provides knowledge for Assessments.\n    *   **Assessment/Evaluation:** (Quizzes, assignments) Provides Feedback, leads to Progress Tracking.\n    *   **Feedback:** (Instructor/System feedback) Improves understanding, influences future content consumption.\n    *   **Progress Tracking:** (Monitoring progress) Informs learner and instructor, motivates completion.\n    *   **Completion:** (Course finished) Leads to Certification/Rewards.\n\n2.  **Module Structure:**\n    *   **Content Modules:** (Lessons, readings, videos) Feeds into Assessments, accessed after enrollment.\n        *   *Sub-Modules:* Text, Video, Audio, Interactive Simulations.\n    *   **Communication Modules:** (Forums, chat, announcements) Enables Interaction, supports Learning Process.\n        *   *Sub-Modules:* Forums, Chat, Announcements.\n    *   **Assessment Modules:** (Quizzes, assignments, exams) Measures understanding, Provides Feedback.\n        *   *Sub-Modules:* Quizzes, Assignments, Exams.\n    *   **Resource Modules:** (Glossary, FAQs, external links) Supports content understanding, Accessed as needed.\n        *   *Sub-Modules:* Glossary, FAQs, External Links.\n    *   **Administration Module:** (User management, course settings) Manages entire LMS, impacts all modules.\n\n3.  **Users:**\n    *   **Student:** (Learner) Interacts with all Learning Process steps and Modules.\n    *   **Instructor:** (Teacher) Creates content, provides feedback, monitors progress. Interacts with all Modules.\n    *   **Administrator:** (System manager) Manages users, modules, system settings. Impacts all Modules.\n\n4.  **Technology/Infrastructure:**\n    *   **Database:** Stores all data (user info, content, progress). Supports all Modules.\n    *   **Server:** Hosts the LMS. Supports all Modules.\n    *   **Network:** Enables access for users. Supports all Modules.\n    *   **Security:** Protects data. Impacts all Modules.",
        "output": "mindmap\n  root((Online Learning Management System LMS))\n\n    LearningProcess\n      Enrollment\n        CourseAccess\n      CourseAccess\n        ContentConsumption\n        AssessmentEvaluation\n      ContentConsumption\n        AssessmentEvaluation\n      AssessmentEvaluation\n        Feedback\n        ProgressTracking\n      Feedback\n        ContentConsumption\n      ProgressTracking\n        Completion\n      Completion\n        CertificationRewards\n\n    ModuleStructure\n      ContentModules\n        Text\n        Video\n        Audio\n        InteractiveSimulations\n      CommunicationModules\n        Forums\n        Chat\n        Announcements\n      AssessmentModules\n        Quizzes\n        Assignments\n        Exams\n      ResourceModules\n        Glossary\n        FAQs\n        ExternalLinks\n      AdministrationModule\n\n    Users\n      Student\n      Instructor\n      Administrator\n\n    TechnologyInfrastructure\n      Database\n      Server\n      Network\n      Security"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Create a mindmap diagram mapping the various layers and interactions in a standard web application stack.",
        "planning": "**Central Node:** Web Application Stack\n\n**Branches:**\n\n*   **Client-Side (Presentation Layer):**\n    *   Browser: Renders UI, executes JavaScript.\n    *   HTML/CSS/JavaScript: Defines structure, style, and behavior.\n    *   Interactions: User interaction triggers JavaScript events, making requests to the server.\n\n*   **Server-Side (Application Layer):**\n    *   Web Server (e.g., Nginx, Apache): Handles HTTP requests, routes requests to the application server, serves static files.\n    *   Application Server (e.g., Node.js, Python (Flask/Django), Java (Spring)): Executes application logic, processes requests.\n    *   Server-Side Language: (e.g. Node.js, Python, Java): For writing logic.\n    *   Interactions: Receives requests from the web server, processes data, and interacts with the database. Sends responses back to the client.\n\n*   **Data Layer:**\n    *   Database (e.g., MySQL, PostgreSQL, MongoDB): Stores application data.\n    *   Database Queries (SQL/NoSQL): Used to retrieve and manipulate data.\n    *   Interactions: Application server interacts with the database to store, retrieve, update, and delete data.\n\n*   **Network Layer:**\n    *   HTTP/HTTPS: Protocol for communication between client and server.\n    *   TCP/IP: Foundation of network communication.\n    *   DNS: Resolves domain names to IP addresses.\n    *   Interactions: Enables the transport of requests and responses between all layers.",
        "output": "mindmap\n  root((Web Application Stack))\n\n    Client-Side[Presentation Layer]\n      Browser\n        Renders UI\n        Executes JavaScript\n      HTML_CSS_JavaScript[HTML/CSS/JavaScript]\n        Defines structure\n        Defines style\n        Defines behavior\n      ClientInteractions[Interactions]\n        User interaction triggers JavaScript events\n        Making requests to the server\n\n    Server-Side[Application Layer]\n      WebServer[Web Server]\n        Handles HTTP requests\n        Routes requests\n        Serves static files\n      AppServer[Application Server]\n        Executes application logic\n        Processes requests\n      ServerLanguage[Server-Side Language]\n        For writing logic\n      ServerInteractions[Interactions]\n        Receives requests\n        Processes data\n        Interacts with the database\n        Sends responses\n\n    DataLayer[Data Layer]\n      Database\n        Stores application data\n      DatabaseQueries[Database Queries]\n        Used to retrieve and manipulate data\n      DataInteractions[Interactions]\n        Store data\n        Retrieve data\n        Update data\n        Delete data\n\n    NetworkLayer[Network Layer]\n      HTTP_HTTPS[HTTP/HTTPS]\n        Protocol for communication\n      TCP_IP[TCP/IP]\n        Foundation of network communication\n      DNS\n        Resolves domain names\n      NetworkInteractions[Interactions]\n        Transport of requests\n        Transport of responses"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Generate a mindmap diagram that outlines the process flow and key integration points of a payment gateway in an e-commerce platform.",
        "planning": "**Central Topic:** Payment Gateway Integration in E-commerce\n\n**Main Branches:**\n\n1.  **Customer Interaction:**\n    *   Interaction: Customer initiates purchase and proceeds to checkout.\n    *   Components: Shopping Cart, Checkout Page, Order Summary.\n\n2.  **E-commerce Platform:**\n    *   Interaction: Receives order details from the customer. Communicates with payment gateway to initiate payment. Handles order fulfillment based on payment status.\n    *   Components: Website/App, Order Management System, Product Database, Customer Accounts.\n\n3.  **Payment Gateway:**\n    *   Interaction: Securely transmits payment data to the payment processor. Receives authorization/decline response. Sends notification to e-commerce platform.\n    *   Components: Secure Server, Encryption, API, Fraud Detection.\n\n4.  **Payment Processor/Acquirer:**\n    *   Interaction: Processes payment transaction. Communicates with issuing bank. Sends authorization/decline response to payment gateway.\n    *   Components: Payment Processing Network, Bank Connection.\n\n5.  **Issuing Bank:**\n    *   Interaction: Approves or declines the transaction based on available funds and cardholder details. Sends response to the Payment Processor.\n    *   Components: Cardholder Account, Fraud Monitoring.\n\n**Key Integration Points (Sub-Branches):**\n\n*   **Checkout Page -> E-commerce Platform:** Order details sent.\n*   **E-commerce Platform -> Payment Gateway:** Payment request initiation.\n*   **Payment Gateway -> Payment Processor:** Secure payment data transmission.\n*   **Payment Processor -> Issuing Bank:** Authorization request.\n*   **Issuing Bank -> Payment Processor:** Authorization response.\n*   **Payment Processor -> Payment Gateway:** Authorization response.\n*   **Payment Gateway -> E-commerce Platform:** Transaction status update.\n*   **E-commerce Platform -> Customer:** Order confirmation/failure.",
        "output": "mindmap\n  root((Payment Gateway Integration in E-commerce))\n\n    Customer_Interaction\n      Interaction: Customer initiates purchase\n      Components: Shopping Cart, Checkout Page, Order Summary\n\n    Ecommerce_Platform\n      Interaction: Receives order details, initiates payment, handles fulfillment\n      Components: Website/App, Order Management, Product DB, Customer Accounts\n\n    Payment_Gateway\n      Interaction: Transmits data, receives response, sends notification\n      Components: Secure Server, Encryption, API, Fraud Detection\n\n    Payment_Processor\n      Interaction: Processes transaction, communicates with bank\n      Components: Payment Network, Bank Connection\n\n    Issuing_Bank\n      Interaction: Approves/declines transaction\n      Components: Cardholder Account, Fraud Monitoring\n\n    Key_Integration_Points\n      Checkout_to_Ecom[Checkout -> E-commerce: Order Details]\n      Ecom_to_PG[E-commerce -> Payment Gateway: Payment Request]\n      PG_to_PP[Payment Gateway -> Payment Processor: Secure Data]\n      PP_to_Bank[Payment Processor -> Issuing Bank: Auth Request]\n      Bank_to_PP[Issuing Bank -> Payment Processor: Auth Response]\n      PP_to_PG_resp[Payment Processor -> Payment Gateway: Auth Response]\n      PG_to_Ecom_stat[Payment Gateway -> E-commerce: Status Update]\n      Ecom_to_Cust[E-commerce -> Customer: Confirmation]\n\n    Customer_Interaction --o Key_Integration_Points\n    Ecommerce_Platform --o Key_Integration_Points\n    Payment_Gateway --o Key_Integration_Points\n    Payment_Processor --o Key_Integration_Points\n    Issuing_Bank --o Key_Integration_Points"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Develop a mindmap diagram illustrating the key components and data flow of a social networking application.",
        "planning": "**Central Node: Social Networking Application**\n\n**Key Components (Branches):**\n\n*   **User Interface (UI):**\n    *   Interaction: Receives user input, displays data.\n    *   Sub-components: Feed, Profile, Search, Messaging.\n\n*   **Backend Server:**\n    *   Interaction: Processes requests, manages data.\n    *   Sub-components: API Gateway, Application Logic, Database.\n\n*   **Database:**\n    *   Interaction: Stores all application data.\n    *   Sub-components: User Data, Posts, Relationships, Media.\n\n*   **API (Application Programming Interface):**\n    *   Interaction: Enables communication between UI and Backend.\n    *   Sub-components: Authentication, Data Retrieval, Posting.\n\n*   **Cloud Storage:**\n    *   Interaction: Stores media files (images, videos).\n    *   Sub-components: Media files\n\n**Data Flow (Arrows connecting components):**\n\n*   User Input (UI -> Backend Server)\n*   Data Retrieval (Backend Server -> Database -> Backend Server -> UI)\n*   Post Creation (UI -> Backend Server -> Database)\n*   Relationship Management (UI -> Backend Server -> Database)\n*   Media Upload/Download (UI <-> Cloud Storage <-> Backend Server)\n\n**Interactions:**\n\n*   UI sends requests to the Backend Server via API.\n*   Backend Server queries/updates the Database.\n*   Database provides data to the Backend Server.\n*   Backend Server sends data to UI for display.\n*   Media files are uploaded to/downloaded from Cloud Storage, often managed by the Backend.",
        "output": "mindmap\n  root((Social Networking Application))\n\n    KeyComponents\n      UserInterface[User Interface]::icon(fa fa-desktop)\n        InteractionUI[Interaction: Receives input, displays data]\n        SubUI[Sub-components: Feed, Profile, Search, Messaging]\n\n      BackendServer[Backend Server]::icon(fa fa-server)\n        InteractionBackend[Interaction: Processes requests, manages data]\n        SubBackend[Sub-components: API Gateway, App Logic, Database]\n\n      Database[Database]::icon(fa fa-database)\n        InteractionDB[Interaction: Stores all application data]\n        SubDB[Sub-components: User Data, Posts, Relationships, Media]\n\n      API[API]::icon(fa fa-exchange-alt)\n        InteractionAPI[Interaction: Enables UI and Backend communication]\n        SubAPI[Sub-components: Authentication, Data Retrieval, Posting]\n\n      CloudStorage[Cloud Storage]::icon(fa fa-cloud)\n        InteractionCloud[Interaction: Stores media]\n        SubCloud[Sub-components: Media Files]\n\n    DataFlow\n      UserInput)UI -> Backend Server(\n      DataRetrieval)Backend -> Database -> Backend -> UI(\n      PostCreation)UI -> Backend -> Database(\n      RelationshipManagement)UI -> Backend -> Database(\n      MediaFlow)UI <-> Cloud Storage <-> Backend(\n\n    Interactions\n      UIBackend)UI sends requests to Backend via API(\n      BackendDB)Backend queries/updates Database(\n      DBBackend)Database provides data to Backend(\n      BackendUI)Backend sends data to UI(\n      MediaManagement)Media uploaded/downloaded, managed by Backend("
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Design a mindmap diagram showing the hierarchical organization and relationships within a computer file system.",
        "planning": "**Central Topic:** File System\n\n**Main Branches:**\n\n*   **Root Directory:** The base of the entire file system.\n\n*   **Directories (Folders):**\n    *   Contain files and other directories.\n    *   Hierarchical structure (parent-child relationships).\n\n*   **Files:**\n    *   Data storage units.\n    *   Different file types (e.g., text, images, executables).\n\n*   **Metadata:**\n    *   Information *about* files and directories (name, size, permissions, timestamps).\n    *   Associated with each file and directory.\n\n**Interactions/Relationships:**\n\n*   Directories *contain* files and other directories.\n*   The root directory is the *parent* of all top-level directories.\n*   Files are *stored in* directories.\n*   Metadata *describes* files and directories.\n*   Hierarchical path navigates through directories to access files (pathnames).",
        "output": "mindmap\n  root((File System))\n\n    Root_Directory[Root Directory]\n\n    Directories_Folders[Directories Folders]\n      Contain_files_dirs[Contain files and other directories]\n      Hierarchical_structure[Hierarchical structure parent-child relationships]\n\n    Files\n      Data_storage_units[Data storage units]\n      Different_file_types[Different file types e.g. text images executables]\n\n    Metadata\n      Information_about[Information about files and directories name size permissions timestamps]\n      Associated_with[Associated with each file and directory]\n\n    Interactions_Relationships[Interactions Relationships]\n      Directories_contain[Directories contain files and other directories]\n      Root_parent[The root directory is the parent of all top-level directories]\n      Files_stored_in[Files are stored in directories]\n      Metadata_describes[Metadata describes files and directories]\n      Hierarchical_path[Hierarchical path navigates through directories to access files pathnames]\n\n    Root_Directory --> Directories_Folders\n    Root_Directory --> Files\n    Root_Directory --> Metadata\n    Directories_Folders --> Interactions_Relationships\n    Files --> Interactions_Relationships\n    Metadata --> Interactions_Relationships"
    },
    {
        "diagram_type": "mindmap",
        "prompt": "Construct a mindmap diagram that outlines the major topics and subtopics covered in a typical computer science curriculum.",
        "planning": "*   **Central Topic:** Computer Science Curriculum\n\n*   **Main Branches (Major Topics):**\n    *   Programming\n        *   Subtopics: Data Structures, Algorithms, Object-Oriented Programming, Software Engineering, Specific Languages (e.g., Python, Java, C++)\n        *   Interactions: Algorithms utilize Data Structures; OOP is a programming paradigm; Software Engineering principles apply to all programming.\n    *   Computer Architecture & Organization\n        *   Subtopics: Digital Logic, CPU Design, Memory Management, Operating Systems\n        *   Interactions: OS manages memory; CPU executes instructions based on digital logic.\n    *   Mathematics & Theory\n        *   Subtopics: Discrete Mathematics, Calculus, Linear Algebra, Probability & Statistics, Theory of Computation (Automata, Computability, Complexity)\n        *   Interactions: Discrete Math provides foundation for algorithms; Linear Algebra used in graphics; Theory of Computation defines limits of what computers can do.\n    *   Databases\n        *   Subtopics: Relational Databases, NoSQL Databases, Database Design, Data Mining, Data Warehousing\n        *   Interactions: Database design principles influence the choice of database type.\n    *   Networking & Security\n        *   Subtopics: Network Protocols, Network Security, Cryptography, Distributed Systems\n        *   Interactions: Network protocols govern communication; cryptography secures data transmission.\n    *   Artificial Intelligence\n        *   Subtopics: Machine Learning, Deep Learning, Natural Language Processing, Computer Vision, Robotics\n        *   Interactions: ML algorithms rely on statistical principles.\n\n*   **Cross-Cutting Concerns (Interactions between branches):**\n    *   Algorithms are used across AI, databases, networking.\n    *   Data structures are fundamental to programming, databases, and AI.\n    *   Mathematical principles underpin many concepts in AI, networking, and graphics.\n    *   Security considerations are relevant to networking, databases, and operating systems.",
        "output": "mindmap\n  root((Computer Science Curriculum))\n\n    Programming\n      Data Structures\n      Algorithms\n      Object-Oriented Programming\n      Software Engineering\n      Specific Languages\n        Python\n        Java\n        C++\n\n    \"Computer Architecture & Organization\"\n      \"Digital Logic\"\n      \"CPU Design\"\n      \"Memory Management\"\n      \"Operating Systems\"\n\n    \"Mathematics & Theory\"\n      \"Discrete Mathematics\"\n      Calculus\n      \"Linear Algebra\"\n      \"Probability & Statistics\"\n      \"Theory of Computation\"\n        Automata\n        Computability\n        Complexity\n\n    Databases\n      \"Relational Databases\"\n      \"NoSQL Databases\"\n      \"Database Design\"\n      \"Data Mining\"\n      \"Data Warehousing\"\n\n    \"Networking & Security\"\n      \"Network Protocols\"\n      \"Network Security\"\n      Cryptography\n      \"Distributed Systems\"\n\n    \"Artificial Intelligence\"\n      \"Machine Learning\"\n      \"Deep Learning\"\n      \"Natural Language Processing\"\n      \"Computer Vision\"\n      Robotics"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for the structure of a TCP packet including header fields like sequence number, acknowledgment, flags, window size, and checksum.",
        "planning": "*   **TCP Packet:** The central element, encompassing the entire packet structure.\n\n*   **Header:** Contains control information.\n    *   **Source Port:** Identifies sending application.\n    *   **Destination Port:** Identifies receiving application.\n    *   **Sequence Number:** Tracks data byte order from sender to receiver.\n    *   **Acknowledgment Number:** Indicates the next expected sequence number.\n    *   **Data Offset:** (Header Length) Specifies the size of the TCP header.\n    *   **Flags:** (SYN, ACK, FIN, RST, URG, PSH) Control connection establishment, termination, and data handling.\n    *   **Window Size:** Advertises the receiver's available buffer space.\n    *   **Checksum:** Error detection for the header and data.\n    *   **Urgent Pointer:** (Optional) Points to urgent data.\n    *   **Options:** (Optional) Additional TCP features.\n    *   **Padding:** (Optional) Ensures header ends on a 32-bit boundary.\n\n*   **Data:** The application payload being transmitted.\n    *   Carries actual data from the sending application to the receiving application.\n    *   Follows the TCP header in the packet.",
        "output": "packet-beta\n0-15: \"Source Port\"\n16-31: \"Destination Port\"\n32-63: \"Sequence Number\"\n64-95: \"Acknowledgment Number\"\n96-99: \"Data Offset\"\n100-105: \"Reserved\"\n106: \"URG\"\n107: \"ACK\"\n108: \"PSH\"\n109: \"RST\"\n110: \"SYN\"\n111: \"FIN\"\n112-127: \"Window Size\"\n128-143: \"Checksum\"\n144-159: \"Urgent Pointer\"\n160-191: \"Options and Padding\"\n192-255: \"Data variable length\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a UDP packet showing source port, destination port, length, and payload.",
        "planning": "*   **UDP Packet:** The central entity representing the UDP packet.\n*   **Source Port:** Originating port number. Connection: \"contains\".\n*   **Destination Port:** Recipient port number. Connection: \"contains\".\n*   **Length:** Total length of the UDP packet (header + payload). Connection: \"contains\".\n*   **Payload:** Actual data being transmitted. Connection: \"contains\".",
        "output": "```mermaid\npacket-beta\n0-15: \"Source Port\"\n16-31: \"Destination Port\"\n32-47: \"Length\"\n48-last: \"Payload\"\n```"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for an ICMP packet detailing the type, code, checksum, and identifier fields.",
        "planning": "*   **ICMP Packet:** The main container.\n*   **Type:** Field indicating ICMP message type (e.g., Echo Request, Echo Reply). Inside the ICMP Packet.\n*   **Code:** Field providing further classification of the ICMP message. Inside the ICMP Packet. Depends on Type.\n*   **Checksum:** Field used for error detection. Inside the ICMP Packet. Calculated based on the entire ICMP message.\n*   **Identifier (ID):** Field used to match requests and replies (often used in ping). Inside the ICMP Packet. Relates to the Data (if Data exists, which may not be shown).",
        "output": "```mermaid\npacket-beta\n0-7: \"Type\"\n8-15: \"Code\"\n16-31: \"Checksum\"\n32-47: \"Identifier\"\n48-63: \"Sequence Number\"\n64-95: \"Data\"\n```"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram that illustrates the structure of an ARP packet used for IP-to-MAC address resolution.",
        "planning": "*   **Hardware Type (HTYPE):** Specifies the hardware protocol type (e.g., Ethernet).\n*   **Protocol Type (PTYPE):** Specifies the protocol being used (e.g., IPv4).\n*   **Hardware Address Length (HLEN):** Length of the hardware address in bytes.\n*   **Protocol Address Length (PLEN):** Length of the protocol address in bytes.\n*   **Operation Code (OPER):** Specifies the ARP packet type (e.g., ARP request or ARP reply).\n*   **Sender Hardware Address (SHA):** MAC address of the sender.\n*   **Sender Protocol Address (SPA):** IP address of the sender.\n*   **Target Hardware Address (THA):** MAC address of the target (filled with zeros in a request).\n*   **Target Protocol Address (TPA):** IP address of the target.\n\nInteraction:\n\nThe diagram should show the fields listed above organized sequentially. The relationships are inherent in the packet structure itself (one follows another). The \"Operation Code\" dictates whether it's a request or a reply, influencing the THA field.",
        "output": "packet-beta\n0-15: \"Hardware Type HTYPE\"\n16-31: \"Protocol Type PTYPE\"\n32-39: \"Hardware Address Length HLEN\"\n40-47: \"Protocol Address Length PLEN\"\n48-63: \"Operation Code OPER\"\n64-111: \"Sender Hardware Address SHA\"\n112-143: \"Sender Protocol Address SPA\"\n144-191: \"Target Hardware Address THA\"\n192-223: \"Target Protocol Address TPA\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a DNS query packet including header, question section, and query type fields.",
        "planning": "*   **DNS Query Packet:** Top-level container.\n\n*   **Header Section:** First part of the packet.\n    *   Interaction: Contains control information.\n\n*   **Question Section:** Second part of the packet.\n    *   Interaction: Defines what is being queried.\n    *   Components:\n        *   **Query Name:** Domain name being queried.\n        *   **Query Type:** Type of record being requested (e.g., A, AAAA, MX).",
        "output": "packet-beta\n0-15: \"Query Header Section\"\n16-47: \"Query Name\"\n48-63: \"Query Type\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a DHCP discover packet in an IPv4 network, highlighting fields like transaction ID and flags.",
        "planning": "*   **DHCP Client:** Initiates the DHCP Discovery process.\n*   **DHCP Discover Packet:** The packet itself, showing key fields.\n*   **Transaction ID (XID):** A unique identifier for the DHCP transaction.\n*   **Flags:** Indicates broadcast/unicast.\n*   **Client IP Address:** (Usually 0.0.0.0 in DHCP Discover).\n*   **Your IP Address:** (Usually 0.0.0.0 in DHCP Discover).\n*   **Server IP Address:** (Usually 0.0.0.0 in DHCP Discover).\n*   **Gateway IP Address:** (Usually 0.0.0.0 in DHCP Discover).\n*   **Client Hardware Address (CHAddr):** MAC address of the client.\n*   **Options:** Includes DHCP message type (Discover), requested IP address, hostname etc.\n*   **DHCP Server:** Receives the DHCP Discover packet.\n*   **Interaction flow:** DHCP Client -> DHCP Discover Packet -> DHCP Server\n*   **Packet details:** Highlight XID, Flags, CHAddr, Options (DHCP message type: Discover). Other address fields can be included.",
        "output": "packet-beta\n0-31:  \"Transaction ID XID\"\n32-47: \"Flags\"\n48-79: \"Client IP Address\"\n80-111: \"Your IP Address\"\n112-143: \"Server IP Address\"\n144-175: \"Gateway IP Address\"\n176-255: \"Client Hardware Address CHAddr\"\n256-511: \"Options DHCP message type Discover etc.\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for an HTTP request packet focusing on method, URI, version, and header fields.",
        "planning": "*   **HTTP Request Packet (Main Box):** Encloses all components.\n*   **Method:** (e.g., GET, POST) - Specifies the action. Points to HTTP Request Packet.\n*   **URI:** (e.g., /path/to/resource) - Identifies the resource. Points to HTTP Request Packet.\n*   **Version:** (e.g., HTTP/1.1) - Specifies the HTTP version. Points to HTTP Request Packet.\n*   **Header Fields:** A collection of key-value pairs providing metadata.\n    *   Sub-components:\n        *   **Header Key:** (e.g., Content-Type, Host). Points to Header Fields\n        *   **Header Value:** (e.g., application/json, example.com). Points to Header Fields.\n*   **Interaction:** Method, URI, Version, and Header Fields are all *contained within* the HTTP Request Packet. Header Key/Value are *contained within* Header Fields.",
        "output": "```mermaid\npacket-beta\n0-7: \"Method\" \n8-39: \"URI\" \n40-47: \"Version\" \n48-127: \"Header Fields\" \n128-255: \"Data\"\n```"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for an MQTT publish packet in an IoT application, showing topic, QoS, retain flag, and payload.",
        "planning": "*   **MQTT Publish Packet:** Central entity representing the MQTT Publish packet.\n\n*   **Topic:**  Shows the topic to which the message is being published. (One-way arrow from Topic to MQTT Publish Packet, labeled \"Topic Name\")\n\n*   **QoS (Quality of Service):**  Indicates the level of guarantee for message delivery. (One-way arrow from QoS to MQTT Publish Packet, labeled \"QoS Level\")\n\n*   **Retain Flag:**  Specifies whether the broker should retain the last message sent on the topic. (One-way arrow from Retain Flag to MQTT Publish Packet, labeled \"Retain\")\n\n*   **Payload:**  The actual data being transmitted. (One-way arrow from Payload to MQTT Publish Packet, labeled \"Data\")",
        "output": "```mermaid\npacket-beta\n  0-7: \"Fixed Header\" \n  8-23: \"Topic Length\" \n  24-39: \"Topic Name\" \n  40-41: \"QoS Level\" \n  42: \"Retain Flag\" \n  43-55: \"Padding\"\n  56-1023: \"Payload\"\n```"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a CoAP message packet in an IoT application, detailing method, message ID, token, and payload.",
        "planning": "*   **CoAP Packet:** The central entity representing the entire CoAP message.\n\n*   **Method (Code):** Specifies the request/response code (e.g., GET, POST, 2.05 Content). Interaction: Sets the type of operation.\n\n*   **Message ID (MID):** Unique identifier for the message. Interaction: Used for matching requests and responses, and duplicate detection.\n\n*   **Token:** Short, client-generated value. Interaction: Used to correlate requests with asynchronous responses, improving reliability.\n\n*   **Payload:** The actual data being transmitted. Interaction: Contains the content being requested or the data being sent.\n\n*   **Header:** Shows the overall Header that encapsulate Method, version, type and Token Length. Interaction: Contains metadata.",
        "output": "```mermaid\npacket-beta\n  0-1: \"Version\"\n  2-3: \"Type\"\n  4-7: \"Token Length\"\n  8-15: \"Method Code\"\n  16-31: \"Message ID\"\n  32-32+Token Length*8-1: \"Token\"\n  32+Token Length*8-32+Token Length*8+N: \"Payload\"\n```"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a Bluetooth Low Energy (BLE) advertisement packet with fields like advertising address, data length, and payload.",
        "planning": "*   **Preamble:** Start of the packet (Synchronization).\n*   **Access Address:** Used for packet identification.\n*   **PDU Header:** Contains information about the PDU payload.\n    *   *Length*: Indicates payload length.\n    *   *PDU Type*: Specifies the packet type (ADV_IND, etc.).\n*   **Advertising Address (AdvA):** Bluetooth address of the advertising device.\n*   **Payload (Advertising Data):** The actual data being advertised.\n    *   *AD Type*: Defines the type of data in the AD structure.\n    *   *AD Length*: Length of the AD structure.\n    *   *AD Data*: The actual advertising data (device name, services, etc.)\n*   **CRC:** Error detection code.\n\n**Interactions:**\n\n1.  Preamble and Access Address help the receiver synchronize and identify BLE packets.\n2.  PDU Header describes the type and length of the following payload.\n3.  Advertising Address identifies the source of the advertisement.\n4.  Payload contains the advertising data.\n5.  CRC verifies data integrity.",
        "output": "packet-beta\n0-7: \"Preamble\" \n8-39: \"Access Address\"\n40-45: \"PDU Header Length\"\n46-47: \"PDU Type\"\n48-87: \"Advertising Address AdvA\"\n88-103: \"Payload AD Type\"\n104-111: \"Payload AD Length\"\n112-151: \"Payload AD Data\"\n152-175: \"CRC\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a Zigbee communication packet in a home automation scenario, including network and application layer fields.",
        "planning": "*   **PHY Layer:**\n    *   Radio Frequency Transmission.\n    *   Data modulation/demodulation.\n\n*   **MAC Layer:**\n    *   MAC Header: Frame Control, Sequence Number, Addressing fields (Source/Destination MAC addresses).\n    *   Payload: Carries network layer data.\n    *   MAC Footer: Frame Check Sequence (FCS) for error detection.\n\n*   **Network Layer:**\n    *   Network Header: Frame Control, Source/Destination Network Addresses.\n    *   NWK Payload: Carries APS layer data.\n    *   Fragmentation: (If needed) fragmentation header.\n\n*   **APS Layer:**\n    *   APS Header: Endpoint information (Source/Destination endpoints), Profile ID, Cluster ID.\n    *   APS Payload: Application data.\n    *   Security Header: (If security is enabled) Includes security suite and key information.\n\n*   **Application Layer:**\n    *   Application Payload: Actual sensor data (e.g., temperature reading, switch state).\n    *   ZCL (Zigbee Cluster Library) Header: Command frame header indicating the type of command.\n\n*   **Interactions:**\n    *   Data flows from Application Layer down to PHY, with each layer adding its header/footer.\n    *   Packets are constructed by each layer by encapsulating data from the upper layer.\n    *   The PHY Layer then transmits the packet over the radio frequency.",
        "output": "packet-beta\n0-7: \"PHY Header\" %% Radio Frequency Info\n8-23: \"MAC Header\" %% Frame Control Seq Num Addr\n24-39: \"MAC Payload\" %% Network Layer Data\n40-55: \"Network Header\" %% Frame Control Src Dest Addr\n56-71: \"NWK Payload\" %% APS Layer Data\n72-87: \"APS Header\" %% Endpoints Profile Cluster ID\n88-103: \"APS Payload\" %% Application Data\n104-119: \"ZCL Header\" %% Command Frame Info\n120-135: \"Application Payload\" %% Sensor Data\n136-151: \"Security Header\" %% Security Suite Key Info\n152-167: \"MAC Footer\" %% Frame Check Sequence"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a Real-time Transport Protocol (RTP) packet used in VoIP applications, highlighting sequence number, timestamp, and payload type.",
        "planning": "*   **RTP Packet:** The central entity representing the overall RTP packet.\n*   **Sequence Number:** Shows its position in the stream.\n*   **Timestamp:** Captures the sampling instant of the first octet in the packet.\n*   **Payload Type:** Indicates the format of the encoded payload data (e.g., audio codec).\n*   **Interaction:** Arrows indicating Sequence Number, Timestamp, and Payload Type are contained *within* the RTP Packet.",
        "output": "packet-beta\n0-1:  Version\n2:    Padding\n3:    Extension\n4-7:  CSRC count\n8:    Marker\n9-15: Payload Type\n16-31: Sequence Number\n32-63: Timestamp\n64-95: SSRC\n96-127: CSRC list\n128-255: Payload"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a Kerberos authentication ticket packet, outlining principal, timestamp, and checksum fields.",
        "planning": "*   **Authentication Ticket:** The core packet being diagrammed.\n\n*   **Principal Name:** Identifies the user/service the ticket is for. Part of the ticket data.\n\n*   **Timestamp:** Issue or expiration time of the ticket. Part of the ticket data.\n\n*   **Checksum:** Ensures integrity of the ticket data. Part of the ticket data.\n\n*   **Interaction:** Show the principal name, timestamp, and checksum as components contained within the Authentication Ticket.",
        "output": "packet-beta\n0-63: \"Principal Name\"\n64-127: \"Timestamp\"\n128-191: \"Checksum\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a packet used in a custom chat application over TCP, showing header details and message payload.",
        "planning": "*   **Packet:** The central entity, encompassing both header and payload.\n\n*   **Header:** Contains metadata about the packet.\n    *   **Source ID:** Identifies the sender.\n    *   **Destination ID:** Identifies the recipient.\n    *   **Sequence Number:** Ensures packet order.\n    *   **Timestamp:** Time packet was sent.\n    *   **Message Type:** Indicates the type of message (e.g., text, image).\n    *   **Payload Length:** Size of the data in the packet (Payload).\n\n*   **Payload:** The actual message content.\n    *   **Message Data:** The core content of the message (e.g., text string, image data).",
        "output": "packet-beta\n0-15: \"Source ID\"\n16-31: \"Destination ID\"\n32-47: \"Sequence Number\"\n48-63: \"Timestamp\"\n64-71: \"Message Type\"\n72-79: \"Payload Length\"\n80-255: \"Message Data\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for an email packet following SMTP protocol, highlighting header fields such as sender, receiver, and data payload.",
        "planning": "*   **SMTP Client (MUA):**\n    *   Initiates connection to SMTP Server.\n    *   Sends MAIL FROM (sender address).\n    *   Sends RCPT TO (recipient address).\n    *   Sends DATA command.\n\n*   **SMTP Server (MTA):**\n    *   Receives connection from SMTP Client.\n    *   Receives and validates MAIL FROM.\n    *   Receives and validates RCPT TO.\n    *   Acknowledges DATA command.\n    *   Receives email content (header and body).\n    *   Processes and forwards the email.\n\n*   **Email Packet (Data):**\n    *   **Header:**\n        *   From: (Sender's email address).\n        *   To: (Recipient's email address).\n        *   Subject: (Email subject).\n        *   Date: (Date and time of email).\n        *   MIME-Version: (MIME version).\n        *   Content-Type: (Type of content, e.g., text/plain, text/html).\n    *   **Body/Payload:**\n        *   The actual message content.\n        *   Can be plain text or HTML.\n        *   May include attachments (encoded).\n\n*   **Interaction Flow:**\n    1.  Client connects to Server.\n    2.  Client sends MAIL FROM.\n    3.  Server acknowledges.\n    4.  Client sends RCPT TO.\n    5.  Server acknowledges.\n    6.  Client sends DATA.\n    7.  Server acknowledges.\n    8.  Client sends Header.\n    9.  Client sends Body.\n    10. Client terminates data transfer.\n    11. Server acknowledges the receipt and forwards to the next hop, if any.",
        "output": "```mermaid\npacket-beta\n  0-15: \"From Field\" \n  16-31: \"To Field\" \n  32-47: \"Subject Field\" \n  48-63: \"Date Field\" \n  64-79: \"MIME Version\" \n  80-95: \"Content Type\" \n  96-1023: \"Data Payload\" \n```"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a blockchain network transaction packet (e.g., Bitcoin network message) including version, command, payload size, and checksum.",
        "planning": "*   **Packet:** Main container holding all data.\n*   **Version:** Blockchain version information.\n*   **Command:** Type of message (e.g., transaction request).\n*   **Payload Size:** Size of the data in the payload.\n*   **Payload:** Actual transaction data or other message content.\n*   **Checksum:** Integrity check value calculated from packet data.\n\n**Interactions:**\n\n1.  Version -> Packet\n2.  Command -> Packet\n3.  Payload Size -> Packet\n4.  Payload -> Packet\n5.  Checksum -> Packet (calculated from other fields)",
        "output": "```mermaid\npacket-beta\n0-31:  \"Magic Number\"\n32-63: \"Version\"\n64-127: \"Command\"\n128-159: \"Payload Size\"\n160-Variable: \"Payload\"\nVariable-End: \"Checksum\"\n```"
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for an FTP command packet, showing command type and parameter fields.",
        "planning": "*   **FTP Command Packet:** The central entity representing the overall packet.\n*   **Command Type:** Field within the packet, specifying the FTP command (e.g., USER, PASS, LIST, RETR).\n*   **Parameter(s):** Field(s) containing arguments or data associated with the command (e.g., username, password, filename).\n*   **Interaction:** The FTP Command Packet *contains* both the Command Type and Parameter(s). The Command Type *determines* the interpretation and usage of the Parameter(s).",
        "output": "packet-beta\n0-7: \"Command Type\"\n8-63: \"Parameter\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for an E-commerce transaction packet, visualizing order details, payment information, and authentication fields.",
        "planning": "*   **Order Details:**\n    *   *Components*: Order ID, Product List, Quantity, Total Amount, Shipping Address, Billing Address.\n    *   *Interaction*: Initiates the transaction; provides the basis for the payment.\n\n*   **Payment Information:**\n    *   *Components*: Payment Method (Credit Card, PayPal, etc.), Card Number/Account Details, Expiry Date, CVV/Security Code, Billing Address (for verification).\n    *   *Interaction*: Authorizes the payment based on order details; interacts with authentication for security.\n\n*   **Authentication Fields:**\n    *   *Components*: User ID, Session Token, Timestamp, Digital Signature (optional).\n    *   *Interaction*: Verifies user identity; secures the transaction data during transmission.\n\n*   **Packet Structure:**\n    *   *Structure*: Header (Source, Destination, Packet Type), Order Details payload, Payment Information payload, Authentication Fields payload, Footer (Checksum, End Marker).\n    *   *Interaction*: Encapsulates all data into a single packet for transmission.",
        "output": "packet-beta\n0-15: \"Header: Source\"\n16-31: \"Header: Destination\"\n32-39: \"Header: Packet Type\"\n40-71: \"Order ID\"\n72-103: \"Product List\"\n104-119: \"Quantity\"\n120-135: \"Total Amount\"\n136-167: \"Shipping Address\"\n168-199: \"Billing Address\"\n200-215: \"Payment Method\"\n216-247: \"Card Account Details\"\n248-255: \"Expiry Date\"\n256-263: \"CVV Security Code\"\n264-295: \"Billing Address Payment\"\n296-327: \"User ID\"\n328-359: \"Session Token\"\n360-391: \"Timestamp\"\n392-423: \"Digital Signature\"\n424-431: \"Footer: Checksum\"\n432-439: \"Footer: End Marker\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a Retrieval Augmented Generation (RAG) application packet, showing request parameters, document references, and response payload.",
        "planning": "*   **User Request:** Initial query/prompt from the user.\n    *   *Interaction:* Starts the RAG process.\n\n*   **Query Encoder:** Encodes the user query into a vector embedding.\n    *   *Interaction:* Receives user request, outputs query embedding.\n\n*   **Document Index (Vector Database):** Stores document embeddings and facilitates similarity search.\n    *   *Interaction:* Receives query embedding, returns relevant document references (IDs).\n\n*   **Document Retrieval:** Retrieves actual document content based on document references.\n    *   *Interaction:* Receives document references, returns document content.\n\n*   **Prompt Construction:** Combines user query and retrieved documents into a prompt for the LLM.\n    *   *Interaction:* Receives user query and document content, creates combined prompt.\n\n*   **Large Language Model (LLM):** Generates a response based on the combined prompt.\n    *   *Interaction:* Receives combined prompt, generates a response.\n\n*   **Response Parser:** Formats and delivers the LLM's response to the user.\n    *   *Interaction:* Receives LLM response, outputs final response to the user.\n\n*   **Response Payload:** The final output delivered back to the user.\n    *   *Interaction:* End of RAG process. Contains the LLM generated answer.",
        "output": "packet-beta\n0-15: \"User Request ID\" \n16-31: \"Query Length\" \n32-63: \"Query Data\" \n64-79: \"Encoder Type\" \n80-95: \"Index ID\" \n96-111: \"Document Refs Count\" \n112-127: \"Document Ref 1\" \n128-143: \"Document Ref 2\" \n144-159: \"Document Ref N\" \n160-175: \"LLM Model ID\" \n176-191: \"Response Format\" \n192-223: \"Response Payload Length\" \n224-255: \"Response Data\""
    },
    {
        "diagram_type": "packet",
        "prompt": "Generate a Mermaid packet diagram for a chat bot application using WebSockets, including handshake packet and subsequent messaging packet fields.",
        "planning": "*   **Client (User):** Initiates WebSocket connection, sends/receives messages.\n*   **WebSocket Server:** Handles WebSocket connections, relays messages between clients and chatbot logic.\n*   **Chatbot Logic:** Processes user messages, generates responses.\n*   **Handshake Packet:** Includes HTTP headers for upgrade request and response (Upgrade, Connection, Sec-WebSocket-Key, Sec-WebSocket-Accept).\n*   **Messaging Packet (Client to Server):** Contains user message (e.g., text).\n*   **Messaging Packet (Server to Client):** Contains chatbot response (e.g., text).\n\nInteractions:\n\n1.  Client sends Handshake Packet to WebSocket Server.\n2.  WebSocket Server responds with Handshake Packet.\n3.  Client sends Messaging Packet (user message) to WebSocket Server.\n4.  WebSocket Server forwards message to Chatbot Logic.\n5.  Chatbot Logic processes message and sends response to WebSocket Server.\n6.  WebSocket Server sends Messaging Packet (chatbot response) to Client.",
        "output": "packet-beta\n  0-7: \"HTTP Method\" \n  8-31: \"Request URI\" \n  32-63: \"HTTP Version\" \n  64-95: \"Headers Upgrade\" \n  96-127: \"Connection\" \n  128-159: \"Sec-WebSocket-Key\" \n  160-191: \"Sec-WebSocket-Version\"\n\npacket-beta\n  0-7: \"HTTP Version\" \n  8-31: \"Status Code\" \n  32-63: \"Reason Phrase\" \n  64-95: \"Headers Upgrade\" \n  96-127: \"Connection\" \n  128-159: \"Sec-WebSocket-Accept\"\n\npacket-beta\n  0-7: \"FIN bit\" \n  8-11: \"RSV1-3 bits\" \n  12-15: \"Opcode\" \n  16: \"Mask bit\" \n  17-79: \"Payload Length\" \n  80-143: \"Masking Key\" \n  144-207: \"User Message\"\n\npacket-beta\n  0-7: \"FIN bit\" \n  8-11: \"RSV1-3 bits\" \n  12-15: \"Opcode\" \n  16-79: \"Payload Length\" \n  80-207: \"Chatbot Response\""
    },
    {
        "diagram_type": "pie",
        "prompt": "Generate a Mermaid pie diagram showing the percentage breakdown of TCP packet types (SYN, ACK, FIN, Data) in a simulated network.",
        "planning": "*   **Title:** Clear title describing the diagram's purpose (\"TCP Packet Type Distribution\").\n*   **Data Labels:** Include labels for each TCP packet type (SYN, ACK, FIN, Data).\n*   **Percentage Values:** Each label should correspond to a percentage value representing its proportion of the total packets. (Simulated values e.g., SYN: 5%, ACK: 45%, FIN: 10%, Data: 40%)\n*   **Pie Chart Segments:** Visual representation of each packet type's percentage as a segment of the pie chart. The size of the segment should directly correlate to the percentage.\n*   **Interaction:** No direct interaction between the components beyond the data labels determining the size of each segment within the pie chart. The percentages *define* the visual proportions.",
        "output": "pie\n    title TCP Packet Type Distribution\n    \"SYN\" : 5\n    \"ACK\" : 45\n    \"FIN\" : 10\n    \"Data\" : 40"
    },
    {
        "diagram_type": "pie",
        "prompt": "Provide a Mermaid pie chart illustrating the distribution of HTTP status codes (200, 301, 404, 500) observed in a web-based E-commerce application.",
        "planning": "*   **Title:** A clear title like \"HTTP Status Code Distribution in E-commerce Application\"\n*   **Labels:** Four segments labeled: \"200 OK\", \"301 Moved Permanently\", \"404 Not Found\", \"500 Internal Server Error\".\n*   **Data Values:** Numerical values or percentages representing the proportion of each status code observed. These values determine the size of each pie slice.\n*   **Interaction:** Values directly correlate to the size of each segment. Higher value = larger segment, and vice versa. The whole pie is representative of 100%.",
        "output": "pie\n    title HTTP Status Code Distribution in E-commerce Application\n    \"200 OK\" : 65\n    \"301 Moved Permanently\" : 5\n    \"404 Not Found\" : 20\n    \"500 Internal Server Error\" : 10"
    },
    {
        "diagram_type": "pie",
        "prompt": "Create a Mermaid pie chart representing the energy consumption distribution among server components (CPU, GPU, Memory) in a data center.",
        "planning": "*   **Components:** CPU, GPU, Memory.\n*   **Interaction:** All components draw energy from the data center's power supply (implicit, not shown in pie chart).\n*   **Data:** Represent energy consumption as percentage or wattage for each component (data source is monitoring system).\n*   **Pie Chart:** Slices represent the relative proportions of energy consumed by each component.",
        "output": "pie\n    \"CPU\" : 60\n    \"GPU\" : 30\n    \"Memory\" : 10"
    },
    {
        "diagram_type": "pie",
        "prompt": "Display a Mermaid pie diagram of the CPU scheduling algorithm usage in a time-sharing operating system with hypothetical percentages.",
        "planning": "*   **Sections:** Define sections representing different CPU scheduling algorithms used. Examples: Round Robin, Priority Scheduling, Shortest Job First (SJF).\n*   **Percentages:** Assign hypothetical percentage values to each scheduling algorithm, representing their usage frequency. The sum must equal 100%.\n*   **Interaction:** The diagram visually represents the proportion of time the CPU spends utilizing each algorithm. No direct interaction beyond proportional representation.",
        "output": "pie\n    title CPU Scheduling Algorithm Usage\n    \"Round Robin\" : 45\n    \"Priority Scheduling\" : 25\n    \"Shortest Job First\" : 15\n    \"Multilevel Queue Scheduling\" : 10\n    \"Other\" : 5"
    },
    {
        "diagram_type": "pie",
        "prompt": "Generate a Mermaid pie chart showing the percentage split of user interactions (clicks, scrolls, hovers, swipes) in a modern mobile chat application.",
        "planning": "*   **Chart Title:** Specifies the subject of the pie chart (e.g., \"User Interaction Distribution in Chat App\").\n*   **Data Labels:** Represent each type of user interaction (Clicks, Scrolls, Hovers, Swipes).\n*   **Data Values (Percentages):** Indicate the percentage of total interactions for each interaction type.\n*   **Pie Slices:** Visual representation of each interaction type's percentage, sized proportionally.\n*   **Legend (Optional):** Maps colors to interaction types for clarity.",
        "output": "pie\n    title User Interaction Distribution in Chat App\n    \"Clicks\" : 45\n    \"Scrolls\" : 30\n    \"Hovers\" : 15\n    \"Swipes\" : 10"
    },
    {
        "diagram_type": "pie",
        "prompt": "Produce a Mermaid pie diagram displaying the proportion of error types (client error, server error, network error) in a RESTful API service.",
        "planning": "*   **Title:** RESTful API Error Type Distribution\n*   **Sections (Pie Chart Slices):**\n    *   Client Error: Label with percentage/value.\n    *   Server Error: Label with percentage/value.\n    *   Network Error: Label with percentage/value.\n*   **Interaction:**\n    *   Each slice represents a proportion of total errors.\n    *   The size of each slice corresponds to its error proportion.\n*   **Legend (optional):**\n    *   Maps color to error type.",
        "output": "pie\n    title RESTful API Error Type Distribution\n    \"Client Error\" : 60\n    \"Server Error\" : 30\n    \"Network Error\" : 10"
    },
    {
        "diagram_type": "pie",
        "prompt": "Construct a Mermaid pie chart demonstrating the distribution of microservices in a banking application (authentication, transaction, notification, reporting).",
        "planning": "*   **Chart Type:** Pie Chart\n*   **Title:** Distribution of Microservices in Banking Application\n*   **Data Labels:**\n    *   Authentication: [Percentage or Value] - Handles user login/logout, session management.\n    *   Transaction: [Percentage or Value] - Processes financial transactions (deposits, withdrawals, transfers). Interacts with authentication for authorization.\n    *   Notification: [Percentage or Value] - Sends alerts and notifications to users. Triggered by transaction events.\n    *   Reporting: [Percentage or Value] - Generates reports on various banking activities. Accesses data from transaction and other microservices.\n*   **Value Representation:**  Percentages or absolute values, consistent across all slices.  (Values should sum to 100% or total microservice count).\n*   **Interactions Implication (Not Visualized in Pie Chart, but important):**\n    *   Authentication is a dependency for Transaction.\n    *   Transaction triggers Notification.\n    *   Reporting consumes data from Transaction and possibly Authentication/Notification.",
        "output": "pie\n    title Distribution of Microservices in Banking Application\n    \"Authentication\" : 25\n    \"Transaction\" : 35\n    \"Notification\" : 15\n    \"Reporting\" : 25"
    },
    {
        "diagram_type": "pie",
        "prompt": "Illustrate a Mermaid pie diagram showing the breakdown of file formats (JSON, XML, CSV, YAML) used in data exchanges for a data processing system.",
        "planning": "*   **Title:** \"File Format Breakdown in Data Exchanges\"\n*   **Sections/Segments:**\n    *   JSON\n    *   XML\n    *   CSV\n    *   YAML\n*   **Sizes/Percentages:** Represent the relative proportion of each file format's usage (e.g., JSON: 40%, XML: 30%, CSV: 20%, YAML: 10%).\n*   **Labels:** Each segment should be clearly labeled with its respective file format name.\n*   **Interaction:** The segments, as part of the pie chart, illustrate the distribution of file formats usage in the system's data exchanges. The size of each segment directly reflects its proportion.",
        "output": "pie\n    title File Format Breakdown in Data Exchanges\n    \"JSON\" : 40\n    \"XML\" : 30\n    \"CSV\" : 20\n    \"YAML\" : 10"
    },
    {
        "diagram_type": "pie",
        "prompt": "Create a Mermaid pie chart representing the percentage share of different cache levels (L1, L2, L3) in a CPU performance analysis.",
        "planning": "*   **Chart Title:** A clear title like \"CPU Cache Level Performance Share\" or \"Cache Level Contribution to Performance\".\n*   **Slices:** Three slices representing L1, L2, and L3 cache levels.\n*   **Labels:** Each slice must be labelled with the cache level (L1, L2, L3).\n*   **Percentages:** Each slice must display the percentage share of performance attributed to that cache level. These percentages should sum up to 100%.\n*   **Interaction (Implicit):** The size of each slice directly reflects the proportional contribution of that cache level to overall CPU performance. Larger slice = greater performance contribution. The percentages clarify this relationship.",
        "output": "pie\n    title CPU Cache Level Performance Share\n    \"L1 Cache\" : 55\n    \"L2 Cache\" : 30\n    \"L3 Cache\" : 15"
    },
    {
        "diagram_type": "pie",
        "prompt": "Generate a Mermaid pie diagram showing the application usage distribution among mobile app categories (social, utility, entertainment, productivity) from an app store survey.",
        "planning": "*   **Title:** A descriptive title for the diagram, e.g., \"App Store Survey: Application Usage Distribution by Category\".\n*   **Data Labels:** Categories to be represented in the pie chart (Social, Utility, Entertainment, Productivity). These are string labels.\n*   **Data Values:** Numerical values representing the percentage or proportion of usage for each category. These need to sum to 100% (or a whole).\n*   **Interaction:** The diagram visually represents the data values as slices of a pie, where the size of each slice corresponds to the data value for its respective category. The category labels are linked to these slices, creating a visual representation of application usage distribution.",
        "output": "pie\n    title App Store Survey: Application Usage Distribution by Category\n    \"Social\" : 35\n    \"Utility\" : 25\n    \"Entertainment\" : 20\n    \"Productivity\" : 20"
    },
    {
        "diagram_type": "pie",
        "prompt": "Provide a Mermaid pie chart depicting the percentage breakdown of software bug severities (low, medium, high, critical) in an agile development project.",
        "planning": "*   **Chart Title:** Clearly label the chart as \"Software Bug Severity Breakdown.\"\n*   **Data Labels:** Each slice of the pie chart needs a label corresponding to a severity level (Low, Medium, High, Critical).\n*   **Data Values (Percentages):** Assign a percentage value to each severity level, representing its proportion of total bugs. The total of all percentages should equal 100%.\n*   **Slice Arrangement:** The order and visual arrangement of slices are considered for readability.\n*   **Colors:** Distinct colors for each slice to differentiate severity levels.",
        "output": "```mermaid\npie\n    title Software Bug Severity Breakdown\n    \"Low\" : 50\n    \"Medium\" : 30\n    \"High\" : 15\n    \"Critical\" : 5\n```"
    },
    {
        "diagram_type": "pie",
        "prompt": "Construct a Mermaid pie diagram illustrating the distribution of network traffic across protocols (TCP, UDP, ICMP) in a simulated network environment.",
        "planning": "*   **Nodes/Segments:** Represents simulated network areas (e.g., \"Client,\" \"Server,\" \"Network Core\").\n*   **Traffic Flow:** Arrows showing data exchange between nodes.\n*   **Protocols:** Labels on the traffic flow arrows indicating protocol used (TCP, UDP, ICMP).\n*   **Pie Chart Data Source:** A separate box indicating where the traffic data originates from (e.g., \"Network Sniffer,\" \"Simulation Log\").\n*   **Pie Chart:** The mermaid pie chart itself, visually representing the percentage of each protocol's traffic.\n*   **Legend:** Clearly labels each slice of the pie chart with the corresponding protocol and percentage.\n\nInteraction:\n\n1.  Traffic flows from nodes to other nodes.\n2.  The \"Data Source\" collects/generates the volume of TCP, UDP and ICMP traffic.\n3.  The \"Data Source\" feeds the traffic data to the \"Pie Chart\".\n4.  The \"Pie Chart\" visualizes the distribution of TCP, UDP, and ICMP traffic.\n5.  The \"Legend\" provides labels for the chart.",
        "output": "pie showData\n    \"TCP\" : 60\n    \"UDP\" : 30\n    \"ICMP\" : 10"
    },
    {
        "diagram_type": "pie",
        "prompt": "Design a Mermaid pie chart representing the breakdown of computation tasks (processing, memory I/O, disk access, network operations) in a parallel computing scenario.",
        "planning": "*   **Sections:** Processing, Memory I/O, Disk Access, Network Operations\n*   **Relative Size:** Each section's size represents the proportion of time spent on that task in the parallel computation.\n*   **Labels:** Clear labels for each section (\"Processing,\" \"Memory I/O,\" etc.).\n*   **Percentages:** Show the percentage of total computation time for each section.",
        "output": "pie showData\n    \"Processing\" : 45\n    \"Memory I/O\" : 25\n    \"Disk Access\" : 15\n    \"Network Operations\" : 15"
    },
    {
        "diagram_type": "pie",
        "prompt": "Generate a Mermaid pie diagram showing the distribution of digital content types (text, image, video, audio) in a multimedia content delivery network.",
        "planning": "**Plan:**\n\n1.  **Pie Chart:** Illustrate the percentage breakdown of content types.\n    *   Sections: Text, Image, Video, Audio.\n    *   Values: Represent the relative proportion (e.g., percentage) of each content type.\n2.  **Labels:** Clearly label each section with the content type.\n3.  **Percentages:** Display the percentage value for each content type next to its label in the pie chart.\n4.  **Title:** \"Distribution of Digital Content Types\"",
        "output": "pie showData\n    title Distribution of Digital Content Types\n    \"Text\" : 35\n    \"Image\" : 40\n    \"Video\" : 15\n    \"Audio\" : 10"
    },
    {
        "diagram_type": "pie",
        "prompt": "Produce a Mermaid pie chart representing the percentage share of academic research topics (blockchain, AI, cybersecurity, IoT) presented at a computer science conference.",
        "planning": "*   **Title:** Clear title indicating the chart's purpose (e.g., \"Academic Research Topics at CS Conference\").\n*   **Data Labels:** Labels for each slice representing the academic research topics (Blockchain, AI, Cybersecurity, IoT).\n*   **Data Values:** Percentage share for each research topic. These values determine slice size.\n*   **Legend:** Links each color of the slice to the corresponding research topic label for clarity.\n*   **Slices:** Visual representation of the percentage values as proportions of a circle. Size depends on the percentage share.\n*   **Interaction:** Data values dictate slice sizes. Labels clarify what each slice represents. The title provides context. Legend clarifies the representation of each slice.",
        "output": "pie\n    title Academic Research Topics at CS Conference\n    \"Blockchain\" : 15\n    \"AI\" : 40\n    \"Cybersecurity\" : 25\n    \"IoT\" : 20"
    },
    {
        "diagram_type": "pie",
        "prompt": "Create a Mermaid pie diagram depicting the distribution of user authentication methods (password, biometric, token, two-factor) in a secure enterprise application.",
        "planning": "*   **Title:** User Authentication Methods Distribution\n\n*   **Data Labels:**\n    *   Password\n    *   Biometric\n    *   Token\n    *   Two-Factor\n\n*   **Percentage Values:** (Example, but customize based on the hypothetical distribution)\n    *   Password: 40\n    *   Biometric: 25\n    *   Token: 20\n    *   Two-Factor: 15",
        "output": "pie\n    title User Authentication Methods Distribution\n    \"Password\" : 40\n    \"Biometric\" : 25\n    \"Token\" : 20\n    \"Two-Factor\" : 15"
    },
    {
        "diagram_type": "pie",
        "prompt": "Construct a Mermaid pie chart showing the breakdown of database operations (read, write, update, delete) in a transactional system.",
        "planning": "*   **Title:** \"Database Operations in Transactional System\"\n\n*   **Sections:**\n    *   Read: Percentage of read operations.\n    *   Write: Percentage of write operations.\n    *   Update: Percentage of update operations.\n    *   Delete: Percentage of delete operations.\n\n*   **Interaction:** Represents the proportion of each database operation type relative to the total number of operations.",
        "output": "pie\n    title Database Operations in Transactional System\n    \"Read\" : 55\n    \"Write\" : 25\n    \"Update\" : 15\n    \"Delete\" : 5"
    },
    {
        "diagram_type": "pie",
        "prompt": "Generate a Mermaid pie diagram representing the distribution of cloud service utilization (compute, storage, networking, database) in a small business cloud deployment.",
        "planning": "*   **Components:**\n    *   Compute: Represents virtual machines or serverless functions.\n    *   Storage: Represents data storage solutions (e.g., object storage, block storage).\n    *   Networking: Represents virtual networks, firewalls, load balancers.\n    *   Database: Represents managed database services.\n\n*   **Interactions (Pie Chart Representation):**\n    *   Each component represents a slice of the pie.\n    *   The size of each slice represents the percentage of total cloud service utilization.\n    *   The sum of all slices equals 100%.\n    *   Labels on slices clarify what they represent.",
        "output": "pie\n    \"Compute\" : 45\n    \"Storage\" : 25\n    \"Networking\" : 15\n    \"Database\" : 15"
    },
    {
        "diagram_type": "pie",
        "prompt": "Provide a Mermaid pie chart illustrating the percentage distribution of programming paradigms (object-oriented, functional, procedural, declarative) in computer science education.",
        "planning": "*   **Chart Title:** \"Programming Paradigm Distribution in Computer Science Education\" - Identifies the subject.\n*   **Sections:**\n    *   Object-Oriented: Representing the percentage of focus on OO programming.\n    *   Functional: Representing the percentage of focus on Functional programming.\n    *   Procedural: Representing the percentage of focus on Procedural programming.\n    *   Declarative: Representing the percentage of focus on Declarative programming.\n*   **Percentages:** Numerical values assigned to each section. The sum of all percentages must equal 100. These percentages represent the relative emphasis of each paradigm.\n*   **Labels:** Each section label should be associated with its corresponding percentage to provide context and clarity.",
        "output": "pie\n    title Programming Paradigm Distribution in Computer Science Education\n    \"Object-Oriented\" : 45\n    \"Functional\" : 25\n    \"Procedural\" : 15\n    \"Declarative\" : 15"
    },
    {
        "diagram_type": "pie",
        "prompt": "Design a Mermaid pie diagram showing the breakdown of banking transaction types (deposit, withdrawal, transfer, inquiry) in a banking system simulation.",
        "planning": "*   **Transaction Types (Pie Chart Sections):** Deposit, Withdrawal, Transfer, Inquiry. Each represents a portion of total transactions.\n*   **Percentage Values:** Each transaction type section should display its percentage of the total transaction volume.\n*   **Labels:** Clear labels for each section (Deposit, Withdrawal, Transfer, Inquiry).\n*   **Total Transactions (Optional):** Could display the total number of transactions the percentages are based on in the diagram's center or below.",
        "output": "pie showData\n    \"Deposit\" : 40\n    \"Withdrawal\" : 30\n    \"Transfer\" : 20\n    \"Inquiry\" : 10"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Generate a quadrantChart diagram showing the SWOT analysis for OpenAI in the field of artificial intelligence research.",
        "planning": "*   **Chart Type:** quadrantChart\n*   **Quadrants:** Four quadrants representing SWOT: Strengths, Weaknesses, Opportunities, Threats.\n*   **Data Points:** Each data point represents a specific aspect of OpenAI's SWOT analysis.\n*   **X-Axis:** No specific meaning.\n*   **Y-Axis:** No specific meaning.\n*   **Data Point Interaction:** No explicit interactions between data points visualized other than their position within the quadrant.\n*   **Quadrant Labels:** Clear labels identifying each SWOT quadrant (Strengths, Weaknesses, Opportunities, Threats).\n*   **Example Data Points (Illustrative):**\n    *   Strengths: [Advanced models, Strong research team]\n    *   Weaknesses: [High computational cost, Explainability limitations]\n    *   Opportunities: [Partnerships, Emerging markets]\n    *   Threats: [Competition, Ethical concerns]",
        "output": "quadrantChart\n    x-axis   --> \n    y-axis   --> \n    quadrant-1 Strengths\n    quadrant-2 Weaknesses\n    quadrant-3 Threats\n    quadrant-4 Opportunities\n    AdvancedModels: [0.8, 0.8]\n    ResearchTeam: [0.7, 0.7]\n    ComputationalCost: [0.2, 0.8]\n    Explainability: [0.3, 0.7]\n    Competition: [0.2, 0.2]\n    EthicalConcerns: [0.3, 0.3]\n    Partnerships: [0.8, 0.2]\n    EmergingMarkets: [0.7, 0.3]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Create a quadrantChart diagram comparing the strengths and weaknesses of a blockchain-based payment system in E-commerce.",
        "planning": "**I. Chart Structure:**\n\n*   **Quadrants:**\n    *   X-axis: \"Strength\" (Left to Right - Low to High).\n    *   Y-axis: \"Weakness\" (Bottom to Top - Low to High).\n    *   Quadrant Names (Optional): \"Niche,\" \"Potential,\" \"Challenge,\" \"Dominant.\"\n\n**II. Components (Data Points/Nodes):**\n\n*   **Transactions:** Speed, Cost, Security, Scalability, Transparency, Finality.\n*   **Infrastructure:** Regulatory Compliance, Interoperability, Energy Consumption, Development Complexity.\n*   **Users:** Adoption Rate, User Experience, Trust.\n*   **Merchants:** Integration Complexity, Fees, Chargeback Risk.\n\n**III. Interactions (Placement & Grouping):**\n\n*   Place each component based on its perceived strength and weakness.\n*   Group similar aspects (e.g., transaction-related items) near each other within the chart.\n*   Consider using colors or symbols to distinguish different component categories.\n\n**IV. Quadrant Examples:**\n\n*   **High Strength/Low Weakness (Dominant/Ideal):** High Security, Transparency.\n*   **High Strength/High Weakness (Potential/Strategic):** Scalability (potential with sidechains, but current limitations exist), Regulatory Compliance (can be strong in some areas but weak in others due to evolving laws).\n*   **Low Strength/Low Weakness (Niche/Acceptable):** Finality (often faster than traditional systems but not always instant).\n*   **Low Strength/High Weakness (Challenge/Critical):** Adoption Rate, Energy Consumption.",
        "output": "quadrantChart\n    x-axis Low Strength --> High Strength\n    y-axis Low Weakness --> High Weakness\n    quadrant-1 Niche\n    quadrant-2 Potential\n    quadrant-3 Challenge\n    quadrant-4 Dominant\n    Security: [0.10 0.90]\n    Transparency: [0.90 0.10]\n    Scalability: [0.70 0.70]\n    Compliance: [0.50 0.60]\n    Finality: [0.30 0.20]\n    Adoption: [0.20 0.80]\n    Energy: [0.15 0.75]\n    Integration: [0.35 0.50]\n    Speed: [0.80 0.25]\n    Cost: [0.75 0.30]\n    Experience: [0.40 0.45]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Develop a quadrantChart diagram representing the risk versus reward matrix for adopting a cloud-based microservices architecture in a retail application.",
        "planning": "**Quadrant Chart Components & Interactions Plan:**\n\n1.  **Axes:**\n    *   X-axis: \"Risk\" (Low to High)\n    *   Y-axis: \"Reward\" (Low to High)\n\n2.  **Quadrants:**\n    *   Top Right: \"Ideal\" (High Reward, Low Risk)\n    *   Top Left: \"Strategic\" (High Reward, High Risk)\n    *   Bottom Right: \"Pragmatic\" (Low Reward, Low Risk)\n    *   Bottom Left: \"Avoid\" (Low Reward, High Risk)\n\n3.  **Retail Application Microservices Factors (Points within the Chart):**\n    *   **High Reward, Low Risk:**\n        *   Scalability for peak seasons.\n        *   Improved system resilience.\n    *   **High Reward, High Risk:**\n        *   Vendor lock-in.\n        *   Data security/compliance concerns.\n    *   **Low Reward, Low Risk:**\n        *   Easier feature deployment.\n        *   Technology standardisation.\n    *   **Low Reward, High Risk:**\n        *   Increased infrastructure complexity.\n        *   Steeper learning curve for development team.\n\n4.  **Interactions:**\n    *   Factors are positioned based on perceived risk and reward.\n    *   Quadrant placement dictates strategy (e.g., aggressively pursue \"Ideal\", carefully evaluate \"Strategic\").\n    *   Analysis informs decision on adopting the architecture.",
        "output": "quadrantChart\n    x-axis Low Risk --> High Risk\n    y-axis Low Reward --> High Reward\n    quadrant-1 Ideal\n    quadrant-2 Strategic\n    quadrant-3 Avoid\n    quadrant-4 Pragmatic\n    Scalability: [0.9, 0.9]\n    Resilience: [0.8, 0.8]\n    VendorLockIn: [0.2, 0.8]\n    DataSecurity: [0.1, 0.7]\n    FeatureDeployment: [0.9, 0.2]\n    Standardisation: [0.8, 0.3]\n    Complexity: [0.2, 0.1]\n    LearningCurve: [0.1, 0.2]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Design a quadrantChart diagram for a SWOT analysis of integrating AI into healthcare management systems.",
        "planning": "**QuadrantChart Diagram Plan: AI in Healthcare Management SWOT**\n\n*   **Chart Type:** Quadrant Chart\n\n*   **Axes:** Not explicitly labeled but inherently represent positive (higher) and negative (lower) impact.\n\n*   **Quadrants:**\n\n    *   **Strengths (Top Right):** Internal factors *helping* AI integration succeed.\n    *   **Weaknesses (Top Left):** Internal factors *hindering* AI integration.\n    *   **Opportunities (Bottom Right):** External factors that AI integration can *capitalize* on.\n    *   **Threats (Bottom Left):** External factors that *pose a risk* to AI integration.\n\n*   **Elements within Quadrants:**\n\n    *   **Strengths:**\n        *   Improved Efficiency (streamlines tasks).\n        *   Data-Driven Decisions (better insights).\n        *   Reduced Errors (automation).\n        *   Enhanced Patient Care (personalized treatments).\n\n    *   **Weaknesses:**\n        *   High Initial Investment (costs of implementation).\n        *   Lack of Expertise (skill gap).\n        *   Data Security Concerns (privacy risks).\n        *   Integration Challenges (compatibility issues).\n\n    *   **Opportunities:**\n        *   Increased Funding (government support).\n        *   Growing Market Demand (patient expectations).\n        *   Technological Advancements (new AI tools).\n        *   Partnerships (collaboration opportunities).\n\n    *   **Threats:**\n        *   Regulatory Hurdles (compliance issues).\n        *   Ethical Concerns (bias in algorithms).\n        *   Resistance to Change (staff reluctance).\n        *   Cybersecurity Risks (data breaches).\n\n*   **Interactions:** Implicit through the SWOT framework. The factors within each quadrant interact with each other and influence the overall strategy. Strengths can leverage Opportunities, while mitigating Threats. Weaknesses need to be addressed to avoid hindering Opportunities and increasing vulnerability to Threats.",
        "output": "quadrantChart\n    x-axis Weaknesses --> Strengths\n    y-axis Threats --> Opportunities\n    quadrant-1 Weaknesses\n    quadrant-2 Strengths\n    quadrant-3 Threats\n    quadrant-4 Opportunities\n    A: [0.75, 0.25]\n    B: [0.25, 0.75]\n    C: [0.75, 0.75]\n    D: [0.25, 0.25]\n\n    %% Points with labels referencing content\n    A1: [0.8, 0.8]\n    A2: [0.85, 0.9]\n    A3: [0.9, 0.7]\n    A4: [0.7, 0.9]\n\n    B1: [0.1, 0.8]\n    B2: [0.2, 0.9]\n    B3: [0.3, 0.7]\n    B4: [0.05, 0.75]\n\n    C1: [0.8, 0.1]\n    C2: [0.9, 0.2]\n    C3: [0.7, 0.3]\n    C4: [0.75, 0.05]\n\n    D1: [0.1, 0.1]\n    D2: [0.2, 0.2]\n    D3: [0.3, 0.3]\n    D4: [0.05, 0.2]\n\n    %%Point Labels\n    A: High Initial Investment\n    B: Improved Efficiency\n    C: Regulatory Hurdles\n    D: Increased Funding"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Generate a quadrantChart diagram comparing the performance versus cost evaluation for machine learning algorithms used in image recognition.",
        "planning": "**Quadrant Chart Diagram Plan:**\n\n*   **Axes:**\n    *   X-axis: \"Cost\" (Low to High)\n    *   Y-axis: \"Performance\" (Low to High)\n*   **Quadrants:**\n    *   Quadrant 1 (Top Right): \"High Performance, High Cost\"\n    *   Quadrant 2 (Top Left): \"High Performance, Low Cost\"\n    *   Quadrant 3 (Bottom Left): \"Low Performance, Low Cost\"\n    *   Quadrant 4 (Bottom Right): \"Low Performance, High Cost\"\n*   **Data Points:**\n    *   Each data point represents a machine learning algorithm.\n    *   Position is determined by its relative cost and performance. Examples: CNN, SVM, Decision Tree, etc.\n*   **Labels/Annotations:**\n    *   Algorithm names labeling data points.\n    *   Optional: Brief description or justification for placement.\n*   **Interactions:**\n    *   Relative positioning of algorithms visually compares them.\n    *   Quadrants categorize algorithms based on cost/performance trade-offs.",
        "output": "quadrantChart\n    x-axis Low Cost --> High Cost\n    y-axis Low Performance --> High Performance\n    quadrant-1 High Performance High Cost\n    quadrant-2 High Performance Low Cost\n    quadrant-3 Low Performance Low Cost\n    quadrant-4 Low Performance High Cost\n    CNN: [0.8 0.7]\n    SVM: [0.6 0.5]\n    DecisionTree: [0.3 0.3]\n    RandomForest: [0.7 0.6]\n    LogisticRegression: [0.4 0.4]\n    NaiveBayes: [0.2 0.8]\n    EfficientNet: [0.9 0.9]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Construct a quadrantChart diagram comparing scalability and security aspects of SQL vs NoSQL database systems.",
        "planning": "**Axes:**\n\n*   X-axis: Scalability (Low to High)\n*   Y-axis: Security (Low to High)\n\n**Quadrants:**\n\n*   Top Right: High Security, High Scalability\n*   Top Left: High Security, Low Scalability\n*   Bottom Right: Low Security, High Scalability\n*   Bottom Left: Low Security, Low Scalability\n\n**Data Points:**\n\n*   SQL Databases: Positioned based on relative scalability and security characteristics.\n*   NoSQL Databases: Positioned based on relative scalability and security characteristics.\n\n**Interactions:**\n\n*   Position of each database type reflects trade-offs between scalability and security.\n*   Comparison is visual, highlighting relative strengths and weaknesses.",
        "output": "quadrantChart\n    x-axis Low Scalability --> High Scalability\n    y-axis Low Security --> High Security\n    quadrant-1 Ideal for Highly Secure and Scalable Applications\n    quadrant-2 Suited for Secure but Less Scalable Applications\n    quadrant-3 Focus on Scalability over Security\n    quadrant-4 Not Recommended Baseline Scenario\n    SQL Databases: [0.3, 0.7]\n    NoSQL Databases: [0.8, 0.4]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Create a quadrantChart diagram representing a risk and benefit assessment for implementing serverless architecture in a chat application.",
        "planning": "*   **Quadrants:** Define four quadrants based on Risk (High/Low) and Benefit (High/Low).\n*   **Chat Application:** Serverless Chat application context is the central system being assessed.\n*   **Serverless Components:** List serverless components used in the application:\n    *   API Gateway: Handles incoming requests.\n    *   Functions (e.g., AWS Lambda): Processes messages, manages users, etc.\n    *   Database (e.g., DynamoDB): Stores messages, user data.\n    *   Real-time Messaging Service (e.g., AWS IoT Core, Pusher): Enables real-time communication.\n*   **Risks:** List potential risks of using serverless:\n    *   Vendor Lock-in.\n    *   Cold Starts.\n    *   Security Vulnerabilities.\n    *   Debugging Complexity.\n    *   Cost Overruns (unpredictable scaling).\n*   **Benefits:** List potential benefits:\n    *   Scalability.\n    *   Reduced Operational Overhead.\n    *   Cost Efficiency (pay-per-use).\n    *   Faster Deployment.\n    *   Improved Resilience.\n*   **Placement:** Place each risk and benefit within the appropriate quadrant based on their risk/benefit level. For example, \"Scalability\" would be in the High Benefit/Low Risk quadrant. \"Vendor Lock-in\" might be High Risk/Low Benefit.\n*   **Relationships (Implicit):** The diagram implicitly shows the trade-offs. Items in the High Benefit/Low Risk quadrant are desirable, while those in the High Risk/Low Benefit quadrant are undesirable. The goal is to visually assess the overall balance between risk and benefit.",
        "output": "quadrantChart\n    x-axis High Risk --> Low Risk\n    y-axis Low Benefit --> High Benefit\n    quadrant-1 Avoid\n    quadrant-2 Mitigate\n    quadrant-3 Accept\n    quadrant-4 Exploit\n    \"Vendor Lock-in\": [0.9, 0.1]\n    \"Cold Starts\": [0.7, 0.3]\n    \"Security Risks\": [0.8, 0.2]\n    \"Debugging\": [0.6, 0.4]\n    \"Cost Overruns\": [0.7, 0.35]\n    Scalability: [0.2, 0.8]\n    \"Reduced Overhead\": [0.3, 0.7]\n    \"Cost Efficiency\": [0.4, 0.9]\n    \"Faster Deployment\": [0.35, 0.75]\n    Resilience: [0.25, 0.85]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Develop a quadrantChart diagram analyzing the impact of quantum computing on cryptography, focusing on efficiency and security.",
        "planning": "**Quadrant Chart Plan: Quantum Computing vs. Cryptography (Efficiency & Security)**\n\n*   **Axes:**\n    *   X-axis: Efficiency (Low to High)\n    *   Y-axis: Security (Low to High)\n\n*   **Quadrants:**\n    *   **Top Left (Low Efficiency, High Security):** \"Classical Cryptography (Pre-Quantum)\" - Includes AES, RSA (current standards), focus on security against classical attacks, lower efficiency for large datasets/complex operations compared to future solutions.\n    *   **Top Right (High Efficiency, High Security):** \"Post-Quantum Cryptography (Ideal)\" - Aims for algorithms resistant to quantum attacks, while maintaining or improving efficiency. Includes Lattice-based crypto, Code-based crypto. Goal state.\n    *   **Bottom Left (Low Efficiency, Low Security):** \"Vulnerable Classical Cryptography\" - Classical algorithms broken by quantum computers (e.g., RSA if Shor's algorithm is fully realized). Presents a clear danger.\n    *   **Bottom Right (High Efficiency, Low Security):** \"Quantum Algorithms for Cryptanalysis\" - Quantum algorithms (Shor's, Grover's) targeting classical crypto. High efficiency in breaking classical systems, inherently low security for those systems.\n\n*   **Components/Interactions:**\n    *   Classical Cryptography: Positioned in Top Left, vulnerable position shifts toward Bottom Left quadrant with quantum advancements.\n    *   Post-Quantum Cryptography (PQC): Positioned ideally in Top Right; represents the ongoing research and development efforts to replace vulnerable classical algorithms.\n    *   Quantum Algorithms: Located in Bottom Right; their increasing power drives the vulnerability of algorithms in the Top Left towards the Bottom Left.\n    *   Arrows/Movement: Arrows can illustrate the shift of classical algorithms downwards and leftward as quantum computing matures. Arrows can also show PQC algorithms moving towards high security and efficiency from lower starting positions.",
        "output": "quadrantChart\n    title Impact of Quantum Computing on Cryptography\n    x-axis Low Efficiency --> High Efficiency\n    y-axis Low Security --> High Security\n    quadrant-1 Classical Cryptography Pre Quantum\n    quadrant-2 Post Quantum Cryptography Ideal\n    quadrant-3 Vulnerable Classical Cryptography\n    quadrant-4 Quantum Algorithms for Cryptanalysis\n    ClassicalCrypto: [0.1, 0.8]\n    PostQuantumCrypto: [0.8, 0.9]\n    QuantumAlgorithms: [0.9, 0.1]\n    VulnerableClassical: [0.1, 0.2]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Generate a quadrantChart diagram comparing the advantages and challenges of deploying RAG systems in customer service automation.",
        "planning": "**I. Quadrants:**\n\n*   **Quadrant 1 (High Advantage, Low Challenge):**  *Enhanced Customer Experience*\n*   **Quadrant 2 (High Advantage, High Challenge):** *Effective Knowledge Management*\n*   **Quadrant 3 (Low Advantage, Low Challenge):** *Basic Information Retrieval*\n*   **Quadrant 4 (Low Advantage, High Challenge):** *Complex Query Understanding*\n\n**II. Components (RAG System in Customer Service Context):**\n\n*   **User Query:** Input from customer seeking assistance.\n*   **Retrieval Module:** Component fetching relevant documents/knowledge.\n*   **Knowledge Base:** Source of truth (documents, FAQs, etc.).\n*   **Generation Module:** Component generating the final response.\n*   **Customer Service Agent (optional):** Human agent for escalation.\n*   **Response:** Output provided to the user.\n\n**III. Interactions (Implicit in Quadrant Placement):**\n\n*   **Retrieval Accuracy:** Affects advantage; higher accuracy in simpler tasks (Q3) but faces challenges with complex queries (Q4).\n*   **Response Relevance:** Affects advantage; well-generated responses from enriched knowledge (Q1) vs. potential for hallucination with insufficient/poor knowledge management (Q2).\n*   **Scalability:** Challenges increase with complexity; handling basic queries scales easily (Q3) but requires robust infrastructure and knowledge management for effective knowledge management (Q2).\n*   **Maintenance:** Maintaining the knowledge base (Q2) poses a higher challenge than basic information retrieval (Q3).",
        "output": "quadrantChart\n    x-axis Low Challenge --> High Challenge\n    y-axis Low Advantage --> High Advantage\n    quadrant-1 Enhanced Customer Experience\n    quadrant-2 Effective Knowledge Management\n    quadrant-3 Basic Information Retrieval\n    quadrant-4 Complex Query Understanding\n    UserQuery: [0.2, 0.2]\n    RetrievalModule: [0.3, 0.4]\n    KnowledgeBase: [0.5, 0.6]\n    GenerationModule: [0.7, 0.8]\n    CustomerServiceAgent: [0.9, 0.3]\n    Response: [0.6, 0.2]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Design a quadrantChart diagram illustrating the risk assessment of IoT devices in smart city infrastructures.",
        "planning": "**Quadrant Chart Plan: IoT Device Risk Assessment in Smart Cities**\n\n*   **Axes:**\n    *   X-Axis: **Likelihood of Exploit** (Low to High)\n    *   Y-Axis: **Impact of Exploit** (Low to High)\n\n*   **Quadrants:**\n    *   Quadrant 1 (Low Likelihood, Low Impact): **Monitor**\n    *   Quadrant 2 (High Likelihood, Low Impact): **Mitigate**\n    *   Quadrant 3 (Low Likelihood, High Impact): **Prioritize**\n    *   Quadrant 4 (High Likelihood, High Impact): **Address Immediately**\n\n*   **IoT Device Examples (placed within quadrants based on risk):**\n    *   **Smart Streetlights:** (Likely low likelihood, low impact - Monitor)\n    *   **Environmental Sensors:** (Likely med-low likelihood, medium impact - Mitigate/Prioritize)\n    *   **Smart Meters:** (Likely medium likelihood, high impact - Prioritize/Address Immediately)\n    *   **Traffic Management Systems:** (Likely high likelihood, high impact - Address Immediately)\n    *   **Connected Vehicles:** (Likely medium-high likelihood, high impact - Address Immediately)\n\n*   **Interaction:**\n    *   Placement of each IoT device within the chart is determined by assessing the likelihood and impact of potential security exploits. This placement then dictates the appropriate risk management strategy (Monitor, Mitigate, Prioritize, Address Immediately).",
        "output": "quadrantChart\n    x-axis Low Likelihood --> High Likelihood\n    y-axis Low Impact --> High Impact\n    quadrant-1 Monitor\n    quadrant-2 Mitigate\n    quadrant-3 Prioritize\n    quadrant-4 Address Immediately\n    SmartStreetlights: [0.2, 0.2]\n    EnvironmentalSensors: [0.4, 0.5]\n    SmartMeters: [0.6, 0.8]\n    TrafficManagementSystems: [0.8, 0.9]\n    ConnectedVehicles: [0.7, 0.8]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Construct a quadrantChart diagram showing market positioning of mobile operating systems based on user base and innovation.",
        "planning": "*   **Axes:**\n    *   X-axis: \"User Base\" (Low to High).\n    *   Y-axis: \"Innovation\" (Low to High).\n*   **Quadrants:** Implicitly formed by the axes, defining the four market positioning categories:\n    *   Low User Base, Low Innovation.\n    *   High User Base, Low Innovation.\n    *   Low User Base, High Innovation.\n    *   High User Base, High Innovation.\n*   **Data Points:**\n    *   Represent different mobile operating systems (e.g., Android, iOS, alternative OS).\n    *   Positioned within the quadrant based on their relative user base and innovation level.\n*   **Labels:**\n    *   Each data point is labeled with the name of the operating system it represents.\n*   **Interaction:** The interaction comes from interpreting the placement of each data point. Position of data points indicates the market position relative to other operating systems and relative to user base and innovation.",
        "output": "quadrantChart\n    x-axis Low User Base --> High User Base\n    y-axis Low Innovation --> High Innovation\n    quadrant-1 Niche Market\n    quadrant-2 Market Leader\n    quadrant-3 Emerging\n    quadrant-4 Innovator\n    Android: [0.9, 0.7]\n    iOS: [0.8, 0.8]\n    AlternativeOS_A: [0.3, 0.4]\n    AlternativeOS_B: [0.2, 0.2]\n    FutureOS: [0.4, 0.9]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Generate a quadrantChart diagram that visualizes the trade-offs between security and usability in mobile banking applications.",
        "planning": "*   **Quadrants:** Define the axes.\n    *   X-axis: Usability (Low to High)\n    *   Y-axis: Security (Low to High)\n*   **Data Points (Mobile Banking Features):** Place features within quadrants based on their security and usability trade-off. Examples:\n    *   **Low Security, Low Usability:** SMS OTP (Older implementations, frustrating, less secure)\n    *   **High Security, Low Usability:** Complex Password with frequent changes + multi-factor hardware token (Very secure, annoying to use)\n    *   **Low Security, High Usability:** Simple PIN login, remember me features (Easy to use, vulnerable)\n    *   **High Security, High Usability:** Biometric Login (Fingerprint/Face ID), mobile push notifications for transaction authorization (Secure, Convenient)\n*   **Labels:** Clear labels for each quadrant describing the trade-offs.\n*   **Arrows/Lines (Optional):** Illustrate the direction of desired movement (e.g., Features should ideally move towards the \"High Security, High Usability\" quadrant).",
        "output": "quadrantChart\n    x-axis Low Usability --> High Usability\n    y-axis Low Security --> High Security\n    quadrant-1 Re-evaluate Security & Usability\n    quadrant-2 Improve Security\n    quadrant-3 Improve Usability\n    quadrant-4 Ideal: Secure & Usable\n    \"SMS OTP\": [0.1, 0.2]\n    \"Complex Password + Hardware Token\": [0.1, 0.8]\n    \"Simple PIN Login\": [0.8, 0.3]\n    \"Biometric Login\": [0.8, 0.8]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Create a quadrantChart diagram analyzing the strengths and weaknesses of natural language processing models in sentiment analysis.",
        "planning": "*   **Axes:**\n    *   X-axis: Model Performance (Low to High).\n    *   Y-axis: Interpretability/Explainability (Low to High).\n*   **Quadrants:**\n    *   Top Right: High Performance, High Interpretability (Ideal).\n    *   Top Left: Low Performance, High Interpretability.\n    *   Bottom Right: High Performance, Low Interpretability.\n    *   Bottom Left: Low Performance, Low Interpretability.\n*   **Models/Data Points:**\n    *   List NLP models like: Rule-Based Systems, Naive Bayes, SVM, Logistic Regression, Transformers (BERT, RoBERTa), Sentiment Lexicons.\n    *   Each model is positioned within a quadrant based on its estimated performance and interpretability in sentiment analysis.\n*   **Interactions:**\n    *   The diagram displays the trade-off between performance and interpretability.\n    *   A model's position relative to others allows for visual comparison.\n    *   The diagram helps to determine the suitability of different models for different use cases, considering the importance of performance and interpretability.",
        "output": "quadrantChart\n    x-axis Low Performance --> High Performance\n    y-axis Low Interpretability --> High Interpretability\n    quadrant-1 Ideal\n    quadrant-2 Needs Improvement\n    quadrant-3 Consider Trade-offs\n    quadrant-4 Not Recommended\n    \"Rule-Based\": [0.2, 0.7]\n    \"Naive Bayes\": [0.4, 0.6]\n    SVM: [0.6, 0.4]\n    \"Logistic Regression\": [0.5, 0.5]\n    Transformers: [0.8, 0.2]\n    \"Sentiment Lexicons\": [0.3, 0.8]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Develop a quadrantChart diagram evaluating cloud-based storage solutions based on speed versus reliability.",
        "planning": "**QuadrantChart Diagram Plan: Cloud Storage Solutions**\n\n1.  **Axes:**\n    *   X-axis: \"Speed\" (performance of data transfer, read/write operations). Left = Slow, Right = Fast.\n    *   Y-axis: \"Reliability\" (data durability, uptime, data redundancy). Bottom = Unreliable, Top = Reliable.\n\n2.  **Quadrants:**\n    *   Top Right: \"Leaders\" (High Speed, High Reliability)\n    *   Top Left: \"Niche Players\" (Low Speed, High Reliability)\n    *   Bottom Right: \"Challengers\" (High Speed, Low Reliability)\n    *   Bottom Left: \"Laggards\" (Low Speed, Low Reliability)\n\n3.  **Data Points:**\n    *   Each cloud storage solution (e.g., AWS S3, Google Cloud Storage, Azure Blob Storage, Dropbox, Box, Backblaze B2) is represented as a point on the chart.\n    *   Position determined by its assessed speed and reliability.\n\n4.  **Placement Logic:**\n    *   Evaluate each solution against defined metrics for speed (e.g., latency, throughput) and reliability (e.g., uptime SLAs, data redundancy mechanisms).\n    *   Plot the data points within the quadrants based on these evaluations. The position reflects relative performance compared to other solutions.\n\n5.  **Interactions:**\n    *   Solutions in the top right are the best overall.\n    *   Trade-offs are visible: Some solutions prioritize speed over reliability (bottom right) or vice-versa (top left).\n    *   Relative positioning reveals competitive advantages and weaknesses.",
        "output": "quadrantChart\n    x-axis Slow --> Fast\n    y-axis Unreliable --> Reliable\n    quadrant-1 Niche Players\n    quadrant-2 Leaders\n    quadrant-3 Laggards\n    quadrant-4 Challengers\n    AWS_S3: [0.8, 0.9]\n    Google_Cloud_Storage: [0.75, 0.85]\n    Azure_Blob_Storage: [0.7, 0.8]\n    Dropbox: [0.5, 0.6]\n    Box: [0.4, 0.7]\n    Backblaze_B2: [0.3, 0.75]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Construct a quadrantChart diagram comparing the performance of virtual machines and containers within a microservices architecture.",
        "planning": "**Quadrant Chart Axes:**\n\n*   **X-axis:** Resource Utilization (Low to High)\n*   **Y-axis:** Deployment Speed (Slow to Fast)\n\n**Quadrants:**\n\n*   **Top Left:** Slow Deployment, Low Resource Utilization\n*   **Top Right:** Fast Deployment, High Resource Utilization\n*   **Bottom Left:** Slow Deployment, High Resource Utilization\n*   **Bottom Right:** Fast Deployment, Low Resource Utilization\n\n**Components to Plot (as points/bubbles):**\n\n*   **Virtual Machines (VMs):** Plot based on their resource utilization and deployment speed characteristics.\n*   **Containers (e.g., Docker):** Plot based on their resource utilization and deployment speed characteristics.\n\n**Interactions (Implicit):**\n\n*   The quadrant chart visualizes the *comparison* of VMs and Containers across the two chosen dimensions (resource utilization and deployment speed). The *position* of each type shows their relative performance.",
        "output": "quadrantChart\n    x-axis Low Resource Utilization --> High Resource Utilization\n    y-axis Slow Deployment --> Fast Deployment\n    quadrant-1 Slow Deployment Low Resource Use\n    quadrant-2 Fast Deployment High Resource Use\n    quadrant-3 Slow Deployment High Resource Use\n    quadrant-4 Fast Deployment Low Resource Use\n    VirtualMachines: [0.2 0.1]\n    Containers: [0.8 0.9]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Generate a quadrantChart diagram presenting a SWOT analysis for implementing augmented reality features in gaming applications.",
        "planning": "**Quadrant Chart Plan: AR in Gaming SWOT Analysis**\n\n*   **Quadrants:**\n    *   **Strengths:** Internal positive factors enabling AR implementation.\n    *   **Weaknesses:** Internal negative factors hindering AR implementation.\n    *   **Opportunities:** External positive factors AR implementation can leverage.\n    *   **Threats:** External negative factors AR implementation faces.\n*   **Components (Points within each quadrant):**\n    *   **Strengths:** Innovation potential, Immersive user experience, Brand differentiation, Novel gameplay mechanics.\n    *   **Weaknesses:** Development complexity, High development costs, Limited device compatibility, Battery drain.\n    *   **Opportunities:** Growing AR market, Advancing AR technology, Partnerships with AR device manufacturers, New revenue streams.\n    *   **Threats:** Competition from traditional gaming, User privacy concerns, Potential for motion sickness, High user expectations.\n*   **Interactions:**\n    *   Strengths can mitigate weaknesses.\n    *   Opportunities can leverage strengths.\n    *   Weaknesses can exacerbate threats.\n    *   AR strategy aims to maximize strengths and opportunities while minimizing weaknesses and threats.",
        "output": "quadrantChart\n    title SWOT Analysis for AR in Gaming\n    x-axis Weaknesses --> Strengths\n    y-axis Threats --> Opportunities\n    quadrant-1 Mitigate\n    quadrant-2 Leverage\n    quadrant-3 Address\n    quadrant-4 Exploit\n\n    Strengths_1: [0.8, 0.8]\n    Strengths_2: [0.9, 0.7]\n    Strengths_3: [0.7, 0.9]\n    Strengths_4: [0.9, 0.9]\n\n    Weaknesses_1: [0.2, 0.8]\n    Weaknesses_2: [0.1, 0.7]\n    Weaknesses_3: [0.3, 0.9]\n    Weaknesses_4: [0.1, 0.9]\n\n    Opportunities_1: [0.8, 0.2]\n    Opportunities_2: [0.9, 0.3]\n    Opportunities_3: [0.7, 0.1]\n    Opportunities_4: [0.9, 0.1]\n\n    Threats_1: [0.2, 0.2]\n    Threats_2: [0.1, 0.3]\n    Threats_3: [0.3, 0.1]\n    Threats_4: [0.1, 0.1]\n\n    Strengths_1: [0.8, 0.8]\n    Strengths_2: [0.9, 0.7]\n    Strengths_3: [0.7, 0.9]\n    Strengths_4: [0.9, 0.9]\n\n    Weaknesses_1: [0.2, 0.8]\n    Weaknesses_2: [0.1, 0.7]\n    Weaknesses_3: [0.3, 0.9]\n    Weaknesses_4: [0.1, 0.9]\n\n    Opportunities_1: [0.8, 0.2]\n    Opportunities_2: [0.9, 0.3]\n    Opportunities_3: [0.7, 0.1]\n    Opportunities_4: [0.9, 0.1]\n\n    Threats_1: [0.2, 0.2]\n    Threats_2: [0.1, 0.3]\n    Threats_3: [0.3, 0.1]\n    Threats_4: [0.1, 0.1]\n\n    Innovation potential: [0.8, 0.8]\n    Immersive user experience: [0.9, 0.7]\n    Brand differentiation: [0.7, 0.9]\n    Novel gameplay mechanics: [0.9, 0.9]\n\n    Development complexity: [0.2, 0.8]\n    High development costs: [0.1, 0.7]\n    Limited device compatibility: [0.3, 0.9]\n    Battery drain: [0.1, 0.9]\n\n    Growing AR market: [0.8, 0.2]\n    Advancing AR technology: [0.9, 0.3]\n    Partnerships with AR device manufacturers: [0.7, 0.1]\n    New revenue streams: [0.9, 0.1]\n\n    Competition from traditional gaming: [0.2, 0.2]\n    User privacy concerns: [0.1, 0.3]\n    Potential for motion sickness: [0.3, 0.1]\n    High user expectations: [0.1, 0.1]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Design a quadrantChart diagram analyzing the impact of 5G technology on latency versus bandwidth in smart traffic management systems.",
        "planning": "**Quadrant Chart Plan: 5G in Smart Traffic Management**\n\n**Axes:**\n\n*   **X-Axis:** Bandwidth (Low to High)\n*   **Y-Axis:** Latency (High to Low)\n\n**Quadrants:**\n\n*   **Quadrant 1 (Top-Right):** High Bandwidth, Low Latency (Ideal)\n*   **Quadrant 2 (Top-Left):** Low Bandwidth, Low Latency\n*   **Quadrant 3 (Bottom-Left):** Low Bandwidth, High Latency (Problematic)\n*   **Quadrant 4 (Bottom-Right):** High Bandwidth, High Latency\n\n**Components/Points to Plot:**\n\n1.  **Real-time Traffic Monitoring:** (High Bandwidth, Low Latency)\n    *   *Interaction:* Requires high data transfer for video feeds and sensor data with minimal delay for quick response.\n\n2.  **Adaptive Traffic Light Control:** (Medium Bandwidth, Low Latency)\n    *   *Interaction:* Needs moderate bandwidth for data exchange between traffic lights but requires quick processing to adjust timings.\n\n3.  **Autonomous Vehicle Communication:** (High Bandwidth, Very Low Latency)\n    *   *Interaction:* Critical, needs very high bandwidth and ultra-low latency for vehicle-to-vehicle (V2V) and vehicle-to-infrastructure (V2I) communication.\n\n4.  **Emergency Vehicle Prioritization:** (Medium Bandwidth, Low Latency)\n    *   *Interaction:* Requires moderate bandwidth for location and status updates with fast processing for traffic light overrides.\n\n5.  **Public Transportation Management:** (Low-Medium Bandwidth, Medium Latency)\n    *   *Interaction:* Uses relatively lower bandwidth for tracking and schedule updates, and can tolerate slightly higher latency.",
        "output": "quadrantChart\n    title 5G Impact on Smart Traffic Management\n    x-axis Low Bandwidth --> High Bandwidth\n    y-axis High Latency --> Low Latency\n    quadrant-1 Ideal - High Performance\n    quadrant-2 Acceptable Performance\n    quadrant-3 Problematic - Needs Improvement\n    quadrant-4 Potential Bottleneck\n    Real-time Traffic Monitoring: [0.8, 0.1]\n    Adaptive Traffic Light Control: [0.6, 0.3]\n    Autonomous Vehicle Communication: [0.9, 0.05]\n    Emergency Vehicle Prioritization: [0.7, 0.2]\n    Public Transportation Management: [0.3, 0.5]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Create a quadrantChart diagram comparing the environmental impact and efficiency of data center cooling technologies.",
        "planning": "*   **Quadrants:** Define axes:\n    *   X-axis: Environmental Impact (Low to High)\n    *   Y-axis: Efficiency (Low to High)\n    *   Divide the chart into four quadrants based on these axes.\n\n*   **Data Center Cooling Technologies (Points):**\n    *   Each technology is a point on the chart. Examples:\n        *   Air Cooling\n        *   Liquid Cooling (Direct-to-Chip)\n        *   Immersion Cooling\n        *   Free Cooling (Air or Water)\n        *   Rear Door Heat Exchangers\n\n*   **Technology Placement:**\n    *   Position each technology based on its relative environmental impact and efficiency.\n\n*   **Interaction (Implied):**\n    *   The position of each technology implicitly compares it to others.\n    *   Users visually compare technologies based on their quadrant and relative position.",
        "output": "quadrantChart\n    x-axis Low Impact --> High Impact\n    y-axis Low Efficiency --> High Efficiency\n    quadrant-1 Re-evaluate\n    quadrant-2 Need to improve\n    quadrant-3 Phase out\n    quadrant-4 Best option\n    Air Cooling: [0.8, 0.2]\n    Liquid Cooling: [0.3, 0.7]\n    Immersion Cooling: [0.2, 0.8]\n    Free Cooling: [0.4, 0.6]\n    Rear Door Heat Exchangers: [0.6, 0.4]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Develop a quadrantChart diagram evaluating user satisfaction versus system performance in a streaming service.",
        "planning": "*   **Axes:**\n    *   X-axis: System Performance (e.g., buffering time, video quality, responsiveness).\n    *   Y-axis: User Satisfaction (e.g., ease of use, content availability, overall experience).\n\n*   **Quadrants:**\n    *   High Performance, High Satisfaction (Ideal Zone)\n    *   High Performance, Low Satisfaction\n    *   Low Performance, High Satisfaction\n    *   Low Performance, Low Satisfaction (Problem Area)\n\n*   **Data Points:**\n    *   Each data point represents a specific aspect or feature of the streaming service.\n\n*   **Interaction:**\n    *   Placement of data points within the quadrants is determined by their scores on both System Performance and User Satisfaction.\n    *   Clusters of data points can highlight areas needing improvement or areas of strength.",
        "output": "quadrantChart\n    x-axis Low Performance --> High Performance\n    y-axis Low Satisfaction --> High Satisfaction\n    quadrant-1 Ideal Zone\n    quadrant-2 Retain\n    quadrant-3 Problem Area\n    quadrant-4 Improve\n    Buffering: [0.2, 0.1]\n    VideoQuality: [0.9, 0.8]\n    Responsiveness: [0.7, 0.6]\n    EaseOfUse: [0.6, 0.9]\n    ContentAvailability: [0.4, 0.7]\n    OverallExperience: [0.5, 0.3]"
    },
    {
        "diagram_type": "quadrantChart",
        "prompt": "Construct a quadrantChart diagram presenting a risk versus innovation analysis for adopting edge computing in industrial automation.",
        "planning": "**Quadrant Chart Components:**\n\n*   **X-Axis:** Risk (Low to High)\n*   **Y-Axis:** Innovation (Low to High)\n*   **Quadrants:**\n    *   **Quadrant 1 (Top-Left):** High Innovation, Low Risk (Ideal Zone)\n    *   **Quadrant 2 (Top-Right):** High Innovation, High Risk (Explore/Pilot)\n    *   **Quadrant 3 (Bottom-Left):** Low Innovation, Low Risk (Conservative)\n    *   **Quadrant 4 (Bottom-Right):** Low Innovation, High Risk (Avoid)\n\n**Elements to Plot (Examples):**\n\n*   **Predictive Maintenance:** (High Innovation, Medium Risk). Real-time analysis, but requires data security measures.\n*   **Real-time Control:** (Medium Innovation, High Risk). Fast responses, but vulnerable to cyberattacks.\n*   **Localized Data Processing:** (Low Innovation, Low Risk). Simple task offload, but limited impact.\n*   **Remote Asset Monitoring:** (Medium Innovation, Medium Risk). Easier monitoring, network dependency creates security risk.\n\n**Interaction:**\n\n*   Elements are plotted on the chart based on their risk and innovation levels. Placement visually indicates their attractiveness for adoption. The position helps in prioritizing initiatives.",
        "output": "quadrantChart\n    x-axis Low Risk --> High Risk\n    y-axis Low Innovation --> High Innovation\n    quadrant-1 Ideal Zone\n    quadrant-2 Explore Pilot\n    quadrant-3 Conservative\n    quadrant-4 Avoid\n    PredictiveMaintenance: [0.6, 0.7]\n    RealtimeControl: [0.8, 0.6]\n    LocalizedDataProcessing: [0.2, 0.3]\n    RemoteAssetMonitoring: [0.5, 0.5]"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Draw a requirementDiagram that shows the relationship between high-level and sub-level requirements for a basic chat application.",
        "planning": "*   **Root Requirement:** \"Chat Application\" (High-level)\n*   **Sub-Requirements:** Decompose \"Chat Application\" into functional areas.\n    *   \"User Management\": Handles user registration, login, profile management.\n    *   \"Message Handling\": Handles sending, receiving, displaying messages.\n    *   \"Connection Management\": Handles establishing and maintaining connections.\n    *   \"Security\": Handles authentication, authorization, and data encryption.\n*   **Relationships:** Use \"DeriveReqt\" relationships to connect the root requirement to its sub-requirements. Arrows point from high-level to sub-level requirements.\n*   **Optional Details (if needed):**\n    *   Requirement IDs: Assign unique IDs (e.g., \"REQ-001\") to each requirement.\n    *   Textual Description: Briefly describe each requirement's purpose.\n    *   Constraints: Add constraints on sub-requirements (e.g., message size limit).\n    *   Verification methods: Specify how each sub-requirement will be verified.",
        "output": "requirementDiagram\n\n    requirement chatApp {\n        id: REQ-001\n        text: Chat Application High-level Requirement.\n        risk: Low\n        verifymethod: Test\n    }\n\n    functionalRequirement userManagement {\n        id: REQ-002\n        text: Handles user registration login profile management.\n        risk: Medium\n        verifymethod: Test\n    }\n\n    functionalRequirement messageHandling {\n        id: REQ-003\n        text: Handles sending receiving displaying messages.\n        risk: Medium\n        verifymethod: Test\n    }\n\n    functionalRequirement connectionManagement {\n        id: REQ-004\n        text: Handles establishing and maintaining connections.\n        risk: Medium\n        verifymethod: Test\n    }\n\n    functionalRequirement securityRequirement {\n        id: REQ-005\n        text: Handles authentication authorization and data encryption.\n        risk: High\n        verifymethod: Test\n    }\n\n    chatApp - derives -> userManagement\n    chatApp - derives -> messageHandling\n    chatApp - derives -> connectionManagement\n    chatApp - derives -> securityRequirement"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Construct a requirementDiagram that represents the requirements hierarchy for user authentication in an E-commerce website.",
        "planning": "*   **Top-Level Requirement:** \"Secure User Authentication\" (Overall goal)\n*   **Child Requirements:**\n    *   \"User Registration\" (Creating new accounts)\n    *   \"User Login\" (Accessing existing accounts)\n    *   \"Password Management\" (Resetting/changing passwords)\n    *   \"Account Security\" (Protecting user accounts)\n*   **\"User Registration\" Child Requirements:**\n    *   \"Unique Username Validation\"\n    *   \"Strong Password Enforcement\"\n    *   \"Email Verification\"\n*   **\"User Login\" Child Requirements:**\n    *   \"Username/Password Authentication\"\n    *   \"Multi-Factor Authentication (Optional)\"\n*   **\"Password Management\" Child Requirements:**\n    *   \"Password Reset via Email\"\n    *   \"Password Change Functionality\"\n    *   \"Password Expiry (Optional)\"\n*   **\"Account Security\" Child Requirements:**\n    *   \"Account Lockout after Failed Attempts\"\n    *   \"Activity Logging\"\n\n**Interactions (Implicit through hierarchy):**\n\n*   \"Secure User Authentication\" *contains* all child requirements.\n*   Each child (e.g., \"User Registration\") *contains* its own more specific requirements.",
        "output": "requirementDiagram\n\n    requirement secure_auth { \n        id: 1 \n        text: Secure User Authentication \n        risk: High \n        verifymethod: Test \n    }\n\n    requirement user_reg { \n        id: 1.1 \n        text: User Registration \n        risk: Medium \n        verifymethod: Test \n    }\n\n    requirement user_login { \n        id: 1.2 \n        text: User Login \n        risk: Medium \n        verifymethod: Test \n    }\n\n    requirement pwd_mgmt { \n        id: 1.3 \n        text: Password Management \n        risk: Medium \n        verifymethod: Test \n    }\n\n    requirement acct_sec { \n        id: 1.4 \n        text: Account Security \n        risk: High \n        verifymethod: Test \n    }\n\n    requirement unique_user { \n        id: 1.1.1 \n        text: Unique Username Validation \n        risk: High \n        verifymethod: Test \n    }\n\n    requirement strong_pwd { \n        id: 1.1.2 \n        text: Strong Password Enforcement \n        risk: High \n        verifymethod: Test \n    }\n\n    requirement email_verif { \n        id: 1.1.3 \n        text: Email Verification \n        risk: Medium \n        verifymethod: Test \n    }\n\n    requirement user_pwd_auth { \n        id: 1.2.1 \n        text: Username/Password Authentication \n        risk: High \n        verifymethod: Test \n    }\n\n    requirement mfa { \n        id: 1.2.2 \n        text: Multi-Factor Authentication \n        risk: High \n        verifymethod: Test \n    }\n\n    requirement pwd_reset { \n        id: 1.3.1 \n        text: Password Reset via Email \n        risk: Medium \n        verifymethod: Test \n    }\n\n    requirement pwd_change { \n        id: 1.3.2 \n        text: Password Change Functionality \n        risk: Medium \n        verifymethod: Test \n    }\n\n    requirement pwd_expiry { \n        id: 1.3.3 \n        text: Password Expiry \n        risk: Low \n        verifymethod: Test \n    }\n\n    requirement acct_lockout { \n        id: 1.4.1 \n        text: Account Lockout after Failed Attempts \n        risk: High \n        verifymethod: Test \n    }\n\n    requirement activity_log { \n        id: 1.4.2 \n        text: Activity Logging \n        risk: Medium \n        verifymethod: Test \n    }\n\n    secure_auth - contains -> user_reg\n    secure_auth - contains -> user_login\n    secure_auth - contains -> pwd_mgmt\n    secure_auth - contains -> acct_sec\n\n    user_reg - contains -> unique_user\n    user_reg - contains -> strong_pwd\n    user_reg - contains -> email_verif\n\n    user_login - contains -> user_pwd_auth\n    user_login - contains -> mfa\n\n    pwd_mgmt - contains -> pwd_reset\n    pwd_mgmt - contains -> pwd_change\n    pwd_mgmt - contains -> pwd_expiry\n\n    acct_sec - contains -> acct_lockout\n    acct_sec - contains -> activity_log"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Present a requirementDiagram that details the breakdown of requirements for implementing a simple OAuth process in a mobile banking app.",
        "planning": "**Components:**\n\n*   **Mobile Banking App (Client):**\n    *   *Req:* User Authentication, Request Authorization, Access Protected Resources, Handle Tokens.\n*   **Authorization Server (Identity Provider):**\n    *   *Req:* Authenticate User, Grant Authorization, Issue Access Token, Issue Refresh Token.\n*   **Resource Server (Bank API):**\n    *   *Req:* Validate Access Token, Provide Protected Resources.\n\n**Interactions/Relationships (Requirements):**\n\n1.  **User Authentication (App <-> Auth Server):**\n    *   *Req:* App redirects user to Auth Server for login.\n    *   *Req:* Auth Server authenticates user (username/password, MFA).\n2.  **Authorization Grant (App <-> Auth Server):**\n    *   *Req:* App requests authorization code from Auth Server.\n    *   *Req:* Auth Server presents consent screen to the user.\n    *   *Req:* Auth Server issues authorization code to the App (if user grants consent).\n3.  **Token Exchange (App <-> Auth Server):**\n    *   *Req:* App exchanges authorization code for access token and refresh token.\n    *   *Req:* Auth Server validates authorization code.\n    *   *Req:* Auth Server issues access and refresh tokens.\n4.  **Resource Access (App <-> Resource Server):**\n    *   *Req:* App uses access token to request protected resources from Resource Server.\n    *   *Req:* Resource Server validates access token.\n    *   *Req:* Resource Server provides protected resource to the App.\n5.  **Token Refresh (App <-> Auth Server):**\n    *   *Req:* App uses refresh token to obtain new access token.\n    *   *Req:* Auth Server validates refresh token.\n    *   *Req:* Auth Server issues new access token.\n6.  **Error Handling:**\n    *   *Req:* App handles errors during authentication, authorization, and resource access.\n    *   *Req:* Auth Server and Resource Server return appropriate error codes.\n7.  **Security:**\n    *   *Req:* Secure communication channels (HTTPS).\n    *   *Req:* Token storage security on App.\n    *   *Req:* Token validation and revocation mechanisms.",
        "output": "requirementDiagram\n\n    requirement user_auth {\n        id: 1\n        text: User Authentication\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement auth_grant {\n        id: 2\n        text: Authorization Grant\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement token_exchange {\n        id: 3\n        text: Token Exchange\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement resource_access {\n        id: 4\n        text: Resource Access\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement token_refresh {\n        id: 5\n        text: Token Refresh\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement error_handling {\n        id: 6\n        text: Error Handling\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement security {\n        id: 7\n        text: Security\n        risk: High\n        verifymethod: Test\n    }\n\n    element mobile_app {\n        type: Client\n    }\n\n    element auth_server {\n        type: Authorization Server\n    }\n\n    element resource_server {\n        type: Resource Server\n    }\n\n    mobile_app - satisfies -> user_auth\n    auth_server - satisfies -> user_auth\n\n    mobile_app - satisfies -> auth_grant\n    auth_server - satisfies -> auth_grant\n\n    mobile_app - satisfies -> token_exchange\n    auth_server - satisfies -> token_exchange\n\n    mobile_app - satisfies -> resource_access\n    resource_server - satisfies -> resource_access\n\n    mobile_app - satisfies -> token_refresh\n    auth_server - satisfies -> token_refresh\n\n    mobile_app - satisfies -> error_handling\n    auth_server - satisfies -> error_handling\n    resource_server - satisfies -> error_handling\n\n    mobile_app - satisfies -> security\n    auth_server - satisfies -> security\n    resource_server - satisfies -> security"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Sketch a requirementDiagram to illustrate the security requirements for a lightweight file encryption tool.",
        "planning": "*   **Requirement Elements:**\n    *   `Encryption`: High-level requirement for file encryption.\n    *   `DataConfidentiality`: Requirement for ensuring data confidentiality.\n    *   `AccessControl`: Requirement for controlling access to decrypted files.\n    *   `IntegrityProtection`: Requirement to ensure file integrity.\n    *   `KeyManagement`: Requirement for secure key generation, storage, and retrieval.\n    *   `Usability`: Requirement for ease of use.\n    *   `Performance`: Requirement for acceptable encryption/decryption speed.\n\n*   **Relationship Elements:**\n    *   `Satisfies`: Used to link requirements to higher-level requirements (e.g., `DataConfidentiality` satisfies `Encryption`).\n    *   `Refines`: Used to break down a high-level requirement into more detailed requirements (e.g., `Encryption` refines into `KeyManagement`, `DataConfidentiality`, `IntegrityProtection`).\n    *   `Constrains`: Used to specify constraints on other requirements (e.g., `Performance` constrains `Encryption`).\n    *   `Derives`: Used to show the derivation from User Need to Requirement\n\n*   **Stakeholders:**\n    *   `User`: The end-user of the tool.\n    *   `SecurityOfficer`: The security expert.\n\n*   **Diagram Structure/Interaction:**\n    1.  Start with the high-level requirement: `Encryption`.\n    2.  Refine `Encryption` into lower-level requirements like `DataConfidentiality`, `IntegrityProtection`, `AccessControl`, and `KeyManagement`.\n    3.  Relate stakeholder needs to the requirements with \"Derives\".\n    4.  Use `Satisfies` to show how lower-level requirements contribute to satisfying higher-level requirements.\n    5.  Use `Constrains` to show how `Usability` and `Performance` impact `Encryption`, `KeyManagement`, and other requirements.\n    6.  Label each Requirement with ID, Text, and optionally a rationale.",
        "output": "requirementDiagram\n\n    requirement Encryption {\n        id: REQ-001\n        text: File Encryption\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement DataConfidentiality {\n        id: REQ-002\n        text: Ensure Data Confidentiality\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement AccessControl {\n        id: REQ-003\n        text: Control Access to Decrypted Files\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement IntegrityProtection {\n        id: REQ-004\n        text: Ensure File Integrity\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement KeyManagement {\n        id: REQ-005\n        text: Secure Key Management\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement Usability {\n        id: REQ-006\n        text: Ease of Use\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    requirement Performance {\n        id: REQ-007\n        text: Acceptable Encryption/Decryption Speed\n        risk: Medium\n        verifymethod: Test\n    }\n\n\n    element User {\n        type: Stakeholder\n        docref: End-User\n    }\n\n    element SecurityOfficer {\n        type: Stakeholder\n        docref: Security Expert\n    }\n\n\n    Encryption - refines -> DataConfidentiality\n    Encryption - refines -> AccessControl\n    Encryption - refines -> IntegrityProtection\n    Encryption - refines -> KeyManagement\n\n    DataConfidentiality - satisfies -> Encryption\n    AccessControl - satisfies -> Encryption\n    IntegrityProtection - satisfies -> Encryption\n    KeyManagement - satisfies -> Encryption\n\n    Performance - refines -> Encryption\n    Usability - refines -> Encryption\n\n    User - derives -> Usability\n    User - derives -> Performance\n    SecurityOfficer - derives -> KeyManagement\n\n\n    Performance - contains -> KeyManagement"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Design a requirementDiagram depicting the requirement hierarchy for a cloud-based file storage system focusing on file upload and download features.",
        "planning": "**Requirements:**\n\n*   **Functional Requirement: Cloud File Storage System** (Top-level)\n    *   **Functional Requirement: File Upload**\n        *   **Functional Requirement: User Authentication** (Requires User Management)\n        *   **Performance Requirement: Upload Speed** (Constrains File Upload)\n        *   **Security Requirement: Secure Upload** (Refines/Depends on Security)\n        *   **Non-Functional Requirement: Upload File Size Limit** (Constrains File Upload)\n    *   **Functional Requirement: File Download**\n        *   **Functional Requirement: User Authentication** (Requires User Management)\n        *   **Performance Requirement: Download Speed** (Constrains File Download)\n        *   **Security Requirement: Secure Download** (Refines/Depends on Security)\n        *   **Non-Functional Requirement: Download Concurrent Users** (Constrains File Download)\n    *   **Functional Requirement: User Management** (Required by both Upload and Download)\n        *   **Security Requirement: User Data Protection** (Refines/Depends on Security)\n*   **Security Requirement: Security** (General Security Requirement)",
        "output": "requirementDiagram\n\n    requirement CloudFileStorage {\n        id: CFS-001\n        text: Cloud File Storage System\n        risk: Low\n        verifymethod: Test\n    }\n\n    functionalRequirement FileUpload {\n        id: FU-001\n        text: File Upload Feature\n        risk: Medium\n        verifymethod: Test\n    }\n\n    functionalRequirement FileDownload {\n        id: FD-001\n        text: File Download Feature\n        risk: Medium\n        verifymethod: Test\n    }\n\n    functionalRequirement UserManagement {\n        id: UM-001\n        text: User Management Feature\n        risk: High\n        verifymethod: Test\n    }\n\n    functionalRequirement UserAuthUpload {\n        id: AU-001\n        text: User Authentication for Upload\n        risk: High\n        verifymethod: Test\n    }\n\n    functionalRequirement UserAuthDownload {\n        id: AD-001\n        text: User Authentication for Download\n        risk: High\n        verifymethod: Test\n    }\n\n    performanceRequirement UploadSpeed {\n        id: PS-001\n        text: Upload Speed Requirement\n        risk: Low\n        verifymethod: Test\n    }\n\n    performanceRequirement DownloadSpeed {\n        id: DS-001\n        text: Download Speed Requirement\n        risk: Low\n        verifymethod: Test\n    }\n\n    securityRequirement SecureUpload {\n        id: SU-001\n        text: Secure File Upload\n        risk: High\n        verifymethod: Analysis\n    }\n\n    securityRequirement SecureDownload {\n        id: SD-001\n        text: Secure File Download\n        risk: High\n        verifymethod: Analysis\n    }\n\n    designConstraint UploadFileSizeLimit {\n        id: FS-001\n        text: Upload File Size Limit\n        risk: Medium\n        verifymethod: Inspection\n    }\n\n    designConstraint ConcurrentUsers {\n        id: CU-001\n        text: Concurrent Users Limit\n        risk: Medium\n        verifymethod: Inspection\n    }\n\n    securityRequirement Security {\n        id: SEC-001\n        text: General Security Requirement\n        risk: High\n        verifymethod: Analysis\n    }\n\n    securityRequirement UserDataProtection {\n        id: UDP-001\n        text: User Data Protection\n        risk: High\n        verifymethod: Analysis\n    }\n\n    CloudFileStorage - contains -> FileUpload\n    CloudFileStorage - contains -> FileDownload\n    CloudFileStorage - contains -> UserManagement\n\n    FileUpload - contains -> UserAuthUpload\n    FileUpload - contains -> UploadSpeed\n    FileUpload - contains -> SecureUpload\n    FileUpload - contains -> UploadFileSizeLimit\n\n    FileDownload - contains -> UserAuthDownload\n    FileDownload - contains -> DownloadSpeed\n    FileDownload - contains -> ConcurrentUsers\n    FileDownload - contains -> SecureDownload\n\n    UserAuthUpload - derives -> UserManagement\n    UserAuthDownload - derives -> UserManagement\n\n    UserManagement - contains -> UserDataProtection\n\n    SecureUpload - refines -> Security\n    SecureDownload - refines -> Security\n    UserDataProtection - refines -> Security"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Generate a requirementDiagram showing the requirements structure for a simplified task management app notification system.",
        "planning": "*   **Root Requirement:** \"Task Management App Notification System\"\n\n*   **Functional Requirements:**\n    *   \"Send Task Due Notifications\" (refines Root)\n    *   \"Send Task Assigned Notifications\" (refines Root)\n    *   \"Allow User Notification Preferences\" (refines Root)\n\n*   **Non-Functional Requirements:**\n    *   \"Notifications Must Be Delivered Promptly\" (constrains \"Send Task Due Notifications\", \"Send Task Assigned Notifications\")\n    *   \"Notifications Should Be Customizable\" (elaborates \"Allow User Notification Preferences\")\n\n*   **Stakeholders:**\n    *   \"User\" (satisfies \"Allow User Notification Preferences\")\n    *   \"System Administrator\" (potentially involved in \"Notifications Should Be Customizable\" - default settings)\n\n*   **Relationships:**\n    *   `refine` for functional breakdown.\n    *   `constrain` for non-functional constraints on functional requirements.\n    *   `satisfy` for stakeholder needs.\n    *   `elaborate` for more detailed explanations of requirements.",
        "output": "requirementDiagram\n\n    requirement root_req {\n    id: 1\n    text: Task Management App Notification System\n    risk: low\n    verifymethod: analysis\n    }\n\n    functionalRequirement task_due_req {\n    id: 1.1\n    text: Send Task Due Notifications\n    risk: medium\n    verifymethod: test\n    }\n\n    functionalRequirement task_assigned_req {\n    id: 1.2\n    text: Send Task Assigned Notifications\n    risk: medium\n    verifymethod: test\n    }\n\n    functionalRequirement user_pref_req {\n    id: 1.3\n    text: Allow User Notification Preferences\n    risk: low\n    verifymethod: inspection\n    }\n\n    designConstraint prompt_delivery_req {\n    id: 2.1\n    text: Notifications Must Be Delivered Promptly\n    risk: high\n    verifymethod: test\n    }\n\n    designConstraint customizable_req {\n    id: 2.2\n    text: Notifications Should Be Customizable\n    risk: medium\n    verifymethod: inspection\n    }\n\n    element user {\n    type: Stakeholder\n    }\n\n    element admin {\n    type: Stakeholder\n    }\n\n    root_req - contains -> task_due_req\n    root_req - contains -> task_assigned_req\n    root_req - contains -> user_pref_req\n\n    prompt_delivery_req - refines -> task_due_req\n    prompt_delivery_req - refines -> task_assigned_req\n    customizable_req - refines -> user_pref_req\n\n    user - satisfies -> user_pref_req\n\n    admin - satisfies -> customizable_req"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Outline a requirementDiagram for the requirements of implementing RSA cryptography in a secure messaging application.",
        "planning": "**RequirementDiagram Plan: RSA in Secure Messaging App**\n\n1.  **Top-Level Requirement:** \"Secure Communication\"\n    *   Sub-requirements: \"Data Confidentiality\", \"Data Integrity\", \"Authentication\"\n\n2.  **Data Confidentiality Requirement:**\n    *   Sub-requirement: \"RSA Encryption\"\n    *   Sub-requirement: \"RSA Decryption\"\n\n3.  **RSA Encryption Requirement:**\n    *   Refines: Data Confidentiality\n    *   Requires: \"Key Generation\", \"Padding Scheme\", \"Message Encoding\"\n\n4.  **RSA Decryption Requirement:**\n    *   Refines: Data Confidentiality\n    *   Requires: \"Key Management\", \"Padding Scheme\", \"Message Decoding\"\n\n5.  **Authentication Requirement:**\n    *   Sub-requirement: \"Digital Signatures\"\n\n6.  **Digital Signatures Requirement:**\n    *   Requires: \"RSA Encryption\" (for signature creation), \"RSA Decryption\" (for signature verification), \"Hashing Algorithm\"\n\n7.  **Key Generation Requirement:**\n    *   Requires: \"Random Number Generation\", \"Prime Number Generation\"\n\n8.  **Key Management Requirement:**\n    *   Requires: \"Secure Key Storage\", \"Key Exchange Protocol\" (if applicable)\n\n9.  **Performance Requirement:**\n    *   Constrains: \"RSA Encryption\", \"RSA Decryption\" (related to key size and algorithm implementation)\n\n10. **Security Requirement:**\n    *   Constrains: \"Key Generation\", \"Key Management\", \"Padding Scheme\", \"Random Number Generation\"\n\n**Interactions:**\n\n*   \"Secure Communication\" is the parent requirement driving all others.\n*   \"Data Confidentiality\" is achieved via \"RSA Encryption\" and \"RSA Decryption\".\n*   \"Digital Signatures\" relies on \"RSA Encryption\" and \"RSA Decryption\" for authentication and integrity.\n*   \"Key Generation\" supports \"RSA Encryption\", \"RSA Decryption\", and \"Key Management\".\n*   \"Key Management\" supports \"RSA Decryption\" and secure key handling.\n*   \"Performance Requirement\" and \"Security Requirement\" constrain the implementation of encryption/decryption and key generation/management processes.",
        "output": "requirementDiagram\n\n    requirement secure_comm {\n        id: 1\n        text: Secure Communication\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement data_confidentiality {\n        id: 1.1\n        text: Data Confidentiality\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement data_integrity {\n        id: 1.2\n        text: Data Integrity\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement authentication {\n        id: 1.3\n        text: Authentication\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement rsa_encryption {\n        id: 2.1\n        text: RSA Encryption\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement rsa_decryption {\n        id: 2.2\n        text: RSA Decryption\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement digital_signatures {\n        id: 3.1\n        text: Digital Signatures\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement key_generation {\n        id: 4.1\n        text: Key Generation\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement key_management {\n        id: 4.2\n        text: Key Management\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement performance_req {\n        id: 5.1\n        text: Performance Requirement\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement security_req {\n        id: 5.2\n        text: Security Requirement\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement padding_scheme {\n        id: 6.1\n        text: Padding Scheme\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement message_encoding {\n        id: 6.2\n        text: Message Encoding\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement message_decoding {\n        id: 6.3\n        text: Message Decoding\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement random_number_gen {\n        id: 7.1\n        text: Random Number Generation\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement prime_number_gen {\n        id: 7.2\n        text: Prime Number Generation\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement secure_key_storage {\n        id: 8.1\n        text: Secure Key Storage\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement key_exchange_protocol {\n        id: 8.2\n        text: Key Exchange Protocol\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n\n    secure_comm - contains -> data_confidentiality\n    secure_comm - contains -> data_integrity\n    secure_comm - contains -> authentication\n\n    data_confidentiality - contains -> rsa_encryption\n    data_confidentiality - contains -> rsa_decryption\n\n    rsa_encryption - refines -> data_confidentiality\n    rsa_decryption - refines -> data_confidentiality\n\n    rsa_encryption - refines -> digital_signatures\n    rsa_decryption - refines -> digital_signatures\n\n    digital_signatures - refines -> authentication\n\n    rsa_encryption - refines -> performance_req\n    rsa_decryption - refines -> performance_req\n\n    key_generation - refines -> performance_req\n    key_management - refines -> performance_req\n\n    random_number_gen - refines -> security_req\n    prime_number_gen - refines -> security_req\n    secure_key_storage - refines -> security_req\n\n    rsa_encryption - refines -> security_req\n    rsa_decryption - refines -> security_req\n\n    rsa_encryption - refines -> padding_scheme\n    rsa_decryption - refines -> padding_scheme\n\n    rsa_encryption - refines -> message_encoding\n    rsa_decryption - refines -> message_decoding\n\n    key_generation - refines -> rsa_encryption\n    key_generation - refines -> rsa_decryption\n    key_generation - refines -> key_management\n\n    key_management - refines -> rsa_decryption\n\n    key_generation - refines -> random_number_gen\n    key_generation - refines -> prime_number_gen\n\n    key_management - refines -> secure_key_storage\n    key_management - refines -> key_exchange_protocol"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Develop a requirementDiagram for the requirements involved in establishing a basic TCP connection handshake process.",
        "planning": "**Requirements (High-Level):**\n\n*   Establish Connection: Top-level requirement for successful TCP connection establishment.\n\n**Functional Requirements (Decomposition of Establish Connection):**\n\n*   SYN Transmission: Send a SYN (Synchronization) packet to the server.\n*   SYN-ACK Reception: Receive a SYN-ACK (Synchronization-Acknowledgment) packet from the server.\n*   ACK Transmission: Send an ACK (Acknowledgment) packet to the server.\n*   Connection Established: Final state indicating successful connection.\n\n**System Elements (Actors/Components):**\n\n*   Client: Initiates the connection.\n*   Server: Receives the connection request and responds.\n*   Network: Facilitates the transmission of packets between client and server.\n\n**Relationships:**\n\n*   `satisfies` relationship: Functional requirements satisfy the \"Establish Connection\" requirement.\n*   `allocates` relationship: The Client and Server system elements are allocated responsibilities for certain functions.\n* `verifies` relationship: Verification requirements would verify the behavior.\n\n**Verification Requirements (Examples):**\n\n*   SYN Packet Sent: Verify the client sends a SYN packet with the correct sequence number.\n*   SYN-ACK Packet Received: Verify the client receives a SYN-ACK packet with the correct acknowledgement number.\n*   ACK Packet Sent: Verify the client sends an ACK packet with the correct acknowledgement number.\n*   Connection Established Status: Verify the client enters the \"ESTABLISHED\" state.",
        "output": "requirementDiagram\n\n    requirement establish_connection {\n        id: 1\n        text: Establish TCP Connection\n        risk: Low\n        verifymethod: Test\n    }\n\n    functionalRequirement syn_transmission {\n        id: 1.1\n        text: Send SYN packet\n        risk: Low\n        verifymethod: Test\n    }\n\n    functionalRequirement syn_ack_reception {\n        id: 1.2\n        text: Receive SYN-ACK packet\n        risk: Low\n        verifymethod: Test\n    }\n\n    functionalRequirement ack_transmission {\n        id: 1.3\n        text: Send ACK packet\n        risk: Low\n        verifymethod: Test\n    }\n\n    functionalRequirement connection_established {\n        id: 1.4\n        text: Connection Established State\n        risk: Low\n        verifymethod: Test\n    }\n\n    element client {\n        type: System\n    }\n\n    element server {\n        type: System\n    }\n\n    element network {\n        type: Network\n    }\n\n    element syn_packet_sent_verify {\n        type: Verification\n        docref: SYN Verification\n    }\n\n    element syn_ack_received_verify {\n        type: Verification\n        docref: SYN-ACK Verification\n    }\n\n    element ack_packet_sent_verify {\n        type: Verification\n        docref: ACK Verification\n    }\n\n    element connection_established_verify {\n        type: Verification\n        docref: Connection Established Verification\n    }\n\n\n    syn_transmission - satisfies -> establish_connection\n    syn_ack_reception - satisfies -> establish_connection\n    ack_transmission - satisfies -> establish_connection\n    connection_established - satisfies -> establish_connection\n\n    client - verifies -> syn_transmission\n    server - verifies -> syn_ack_reception\n    client - verifies -> ack_transmission\n    client - verifies -> connection_established\n\n    syn_packet_sent_verify - verifies -> syn_transmission\n    syn_ack_received_verify - verifies -> syn_ack_reception\n    ack_packet_sent_verify - verifies -> ack_transmission\n    connection_established_verify - verifies -> connection_established"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Create a requirementDiagram that breaks down the requirements for data packet transmission using UDP in a real-time communication app.",
        "planning": "*   **Top-Level Requirement:** \"Real-time Data Packet Transmission via UDP\"\n*   **Functional Requirements (Decomposition):**\n    *   \"Packet Creation\": Application creates data packets.\n        *   \"Data Encapsulation\": Encapsulate application data.\n        *   \"Header Generation\": Generate UDP header (source/dest port, length, checksum).\n    *   \"Packet Transmission\": Send packet over network.\n        *   \"Socket Binding\": Bind application to a specific port.\n        *   \"IP Addressing\": Resolve destination IP address.\n        *   \"Data Transfer\": Send data to specified IP and port.\n    *   \"Packet Reception\": Receive packet.\n        *   \"Socket Listening\": Listen for incoming packets.\n        *   \"Data Extraction\": Extract data from the received packet.\n        *   \"Header Validation\": Validate UDP header (checksum).\n*   **Performance Requirements:**\n    *   \"Low Latency\": Minimize delay in packet transmission/reception.\n    *   \"High Throughput\": Maximize data transfer rate.\n*   **Non-Functional Requirements:**\n    *   \"Reliability (Best Effort)\": Acknowledge UDP's unreliable nature.\n    *   \"Security\": Consider basic data protection.\n*   **Interface Requirements:**\n    *   \"Application API\": Define API for application to send/receive data.\n    *   \"Network Interface\": Interface with underlying network protocol (IP).\n*   **Constraints:**\n    *   \"UDP Packet Size Limit\": Constrained by MTU.\n\n**Interactions:**\n\n*   \"Packet Creation\" *satisfies* \"Real-time Data Packet Transmission via UDP\".\n*   \"Packet Transmission\" *satisfies* \"Real-time Data Packet Transmission via UDP\".\n*   \"Packet Reception\" *satisfies* \"Real-time Data Packet Transmission via UDP\".\n*   \"Low Latency\" *constrains* \"Packet Transmission\" and \"Packet Reception\".\n*   \"High Throughput\" *constrains* \"Packet Transmission\" and \"Packet Reception\".\n*   \"Data Encapsulation\" *refines* \"Packet Creation\".\n*   \"Header Generation\" *refines* \"Packet Creation\".\n*   \"Socket Binding\" *refines* \"Packet Transmission\".\n*   \"IP Addressing\" *refines* \"Packet Transmission\".\n*   \"Data Transfer\" *refines* \"Packet Transmission\".\n*   \"Socket Listening\" *refines* \"Packet Reception\".\n*   \"Data Extraction\" *refines* \"Packet Reception\".\n*   \"Header Validation\" *refines* \"Packet Reception\".\n*   \"UDP Packet Size Limit\" *constrains* \"Packet Creation\" and \"Data Encapsulation\".\n*   \"Application API\" *interfaces with* \"Packet Creation\", \"Packet Transmission\", \"Packet Reception\".\n*   \"Network Interface\" *interfaces with* \"Packet Transmission\", \"Packet Reception\".",
        "output": "requirementDiagram\n\n    requirement realtime_udp { id: 1 text: Real-time Data Packet Transmission via UDP risk: low verifymethod: test }\n\n    functionalRequirement packet_creation { id: 1.1 text: Packet Creation risk: low verifymethod: test }\n    functionalRequirement packet_tx { id: 1.2 text: Packet Transmission risk: low verifymethod: test }\n    functionalRequirement packet_rx { id: 1.3 text: Packet Reception risk: low verifymethod: test }\n\n    performanceRequirement low_latency { id: 2.1 text: Low Latency risk: low verifymethod: analysis }\n    performanceRequirement high_throughput { id: 2.2 text: High Throughput risk: low verifymethod: analysis }\n\n    requirement reliability { id: 3.1 text: Best Effort Reliability risk: low verifymethod: analysis }\n    requirement security { id: 3.2 text: Basic Data Protection risk: low verifymethod: analysis }\n\n    interfaceRequirement app_api { id: 4.1 text: Application API risk: low verifymethod: analysis }\n    interfaceRequirement net_iface { id: 4.2 text: Network Interface risk: low verifymethod: analysis }\n\n    designConstraint udp_mtu { id: 5.1 text: UDP Packet Size Limit risk: low verifymethod: analysis }\n\n    requirement data_encap { id: 1.1.1 text: Data Encapsulation risk: low verifymethod: test }\n    requirement header_gen { id: 1.1.2 text: Header Generation risk: low verifymethod: test }\n    requirement socket_bind { id: 1.2.1 text: Socket Binding risk: low verifymethod: test }\n    requirement ip_addr { id: 1.2.2 text: IP Addressing risk: low verifymethod: test }\n    requirement data_transfer { id: 1.2.3 text: Data Transfer risk: low verifymethod: test }\n    requirement socket_listen { id: 1.3.1 text: Socket Listening risk: low verifymethod: test }\n    requirement data_extract { id: 1.3.2 text: Data Extraction risk: low verifymethod: test }\n    requirement header_validate { id: 1.3.3 text: Header Validation risk: low verifymethod: test }\n\n\n    packet_creation - satisfies -> realtime_udp\n    packet_tx - satisfies -> realtime_udp\n    packet_rx - satisfies -> realtime_udp\n\n    low_latency - refines -> packet_tx\n    low_latency - refines -> packet_rx\n    high_throughput - refines -> packet_tx\n    high_throughput - refines -> packet_rx\n\n    data_encap - refines -> packet_creation\n    header_gen - refines -> packet_creation\n    socket_bind - refines -> packet_tx\n    ip_addr - refines -> packet_tx\n    data_transfer - refines -> packet_tx\n    socket_listen - refines -> packet_rx\n    data_extract - refines -> packet_rx\n    header_validate - refines -> packet_rx\n\n    udp_mtu - refines -> packet_creation\n    udp_mtu - refines -> data_encap\n\n    app_api - refines -> packet_creation\n    app_api - refines -> packet_tx\n    app_api - refines -> packet_rx\n    net_iface - refines -> packet_tx\n    net_iface - refines -> packet_rx"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Construct a requirementDiagram showing the hierarchical requirements for a collaborative document editing web application.",
        "planning": "**Root Requirement:** Collaborative Document Editing Web Application\n\n**Child Requirements (Examples):**\n\n*   **Document Management:**\n    *   *Create Document:* User can create a new document.\n    *   *Open Document:* User can open an existing document.\n    *   *Save Document:* User can save the document.\n    *   *Delete Document:* User can delete a document.\n*   **Collaborative Editing:**\n    *   *Real-time Editing:* Multiple users can edit simultaneously.\n        *   *Conflict Resolution:* Resolve conflicting edits.\n    *   *User Identification:* Identify each user's edits.\n    *   *Access Control:* Manage user permissions (view, edit, comment).\n*   **User Interface:**\n    *   *Text Formatting:* Basic text formatting options (bold, italic, etc.).\n    *   *Commenting:* Users can add comments to the document.\n    *   *Version History:* View and revert to previous versions.\n*   **Communication:**\n    *   *Chat:* Real-time chat among collaborators.\n    *   *Notifications:* Notifications for changes and updates.\n\n**Interactions:**\n\n*   Each child requirement satisfies the root requirement.\n*   Sub-requirements within Document Management, Collaborative Editing, User Interface, and Communication further specify the parent requirements.\n*   For instance, \"Conflict Resolution\" refines \"Real-time Editing\" by addressing a potential issue.\n*   \"Access Control\" directly influences \"Collaborative Editing\" by defining who can participate and how.",
        "output": "requirementDiagram\n\n    requirement root_req {\n        id: 1\n        text: Collaborative Document Editing Web Application\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement doc_manage {\n        id: 1.1\n        text: Document Management\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement collab_edit {\n        id: 1.2\n        text: Collaborative Editing\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement ui {\n        id: 1.3\n        text: User Interface\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    requirement comm {\n        id: 1.4\n        text: Communication\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    requirement create_doc {\n        id: 1.1.1\n        text: Create Document\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement open_doc {\n        id: 1.1.2\n        text: Open Document\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement save_doc {\n        id: 1.1.3\n        text: Save Document\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement delete_doc {\n        id: 1.1.4\n        text: Delete Document\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement real_time {\n        id: 1.2.1\n        text: Real-time Editing\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement conflict_res {\n        id: 1.2.1.1\n        text: Conflict Resolution\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement user_id {\n        id: 1.2.2\n        text: User Identification\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement access_control {\n        id: 1.2.3\n        text: Access Control\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement text_format {\n        id: 1.3.1\n        text: Text Formatting\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    requirement commenting {\n        id: 1.3.2\n        text: Commenting\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    requirement version_hist {\n        id: 1.3.3\n        text: Version History\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    requirement chat {\n        id: 1.4.1\n        text: Chat\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    requirement notifications {\n        id: 1.4.2\n        text: Notifications\n        risk: Low\n        verifymethod: Inspection\n    }\n\n    root_req - contains -> doc_manage\n    root_req - contains -> collab_edit\n    root_req - contains -> ui\n    root_req - contains -> comm\n\n    doc_manage - contains -> create_doc\n    doc_manage - contains -> open_doc\n    doc_manage - contains -> save_doc\n    doc_manage - contains -> delete_doc\n\n    collab_edit - contains -> real_time\n    collab_edit - contains -> user_id\n    collab_edit - contains -> access_control\n\n    real_time - contains -> conflict_res\n    real_time - refines -> conflict_res\n\n    ui - contains -> text_format\n    ui - contains -> commenting\n    ui - contains -> version_hist\n\n    comm - contains -> chat\n    comm - contains -> notifications"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Provide a requirementDiagram for the requirements analysis of a weather forecasting application focusing on data collection and processing features.",
        "planning": "*   **Top-Level Requirement:** \"Accurate and Timely Weather Forecasts\" (parent requirement).\n\n*   **Data Collection Requirements:**\n    *   \"Collect Real-time Weather Data\" (child of \"Accurate and Timely Weather Forecasts\").\n        *   Sources: \"Satellite Data Collection,\" \"Weather Station Data Collection,\" \"Radar Data Collection,\" \"User Reported Data Collection.\" (child of \"Collect Real-time Weather Data\"). Use `<contains>` relationship.\n        *   \"Data Collection Frequency\" (child of \"Collect Real-time Weather Data\").\n        *   \"Data Collection Accuracy\" (child of \"Collect Real-time Weather Data\").\n        *   \"Data Transmission Security\" (child of \"Collect Real-time Weather Data\").\n    *   Constraints: \"Data Collection Cost Constraint,\" \"Data Source Availability Constraint.\" `<constrains>` to data collection.\n\n*   **Data Processing Requirements:**\n    *   \"Process Weather Data\" (child of \"Accurate and Timely Weather Forecasts\").\n        *   \"Data Validation and Cleaning\" (child of \"Process Weather Data\"). Use `<contains>` relationship.\n        *   \"Data Storage\" (child of \"Process Weather Data\"). Use `<contains>` relationship.\n        *   \"Weather Model Execution\" (child of \"Process Weather Data\"). Use `<contains>` relationship.\n        *   \"Forecast Generation\" (child of \"Process Weather Data\"). Use `<contains>` relationship.\n    *   Constraints: \"Processing Power Constraint,\" \"Storage Capacity Constraint.\" `<constrains>` to data processing.\n\n*   **Interactions:**\n    *   `satisfies` relationship: Each of the data collection and processing requirements `satisfies` \"Accurate and Timely Weather Forecasts\".\n    *   `dependsOn` relationship: \"Process Weather Data\" `dependsOn` \"Collect Real-time Weather Data\".",
        "output": "requirementDiagram\n\n    requirement accurate_forecasts { \n        id: RF001\n        text: Accurate and Timely Weather Forecasts\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement collect_data { \n        id: DC001\n        text: Collect Real-time Weather Data\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement process_data { \n        id: DP001\n        text: Process Weather Data\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement satellite_data { \n        id: DC001.01\n        text: Satellite Data Collection\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement weather_station_data { \n        id: DC001.02\n        text: Weather Station Data Collection\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement radar_data { \n        id: DC001.03\n        text: Radar Data Collection\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement user_data { \n        id: DC001.04\n        text: User Reported Data Collection\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement data_frequency { \n        id: DC002\n        text: Data Collection Frequency\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement data_accuracy { \n        id: DC003\n        text: Data Collection Accuracy\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement data_security { \n        id: DC004\n        text: Data Transmission Security\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement data_validation { \n        id: DP001.01\n        text: Data Validation and Cleaning\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement data_storage { \n        id: DP001.02\n        text: Data Storage\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement model_execution { \n        id: DP001.03\n        text: Weather Model Execution\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    requirement forecast_generation { \n        id: DP001.04\n        text: Forecast Generation\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    element data_collection_constraint { \n        type: Constraint\n        docref: N/A\n    }\n\n    element data_processing_constraint { \n        type: Constraint\n        docref: N/A\n    }\n\n    collect_data - satisfies -> accurate_forecasts\n    process_data - satisfies -> accurate_forecasts\n    collect_data - contains -> satellite_data\n    collect_data - contains -> weather_station_data\n    collect_data - contains -> radar_data\n    collect_data - contains -> user_data\n    collect_data - contains -> data_frequency\n    collect_data - contains -> data_accuracy\n    collect_data - contains -> data_security\n    process_data - contains -> data_validation\n    process_data - contains -> data_storage\n    process_data - contains -> model_execution\n    process_data - contains -> forecast_generation\n    process_data <- derives - collect_data\n    data_collection_constraint - verifies -> collect_data\n    data_processing_constraint - verifies -> process_data"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Design a requirementDiagram that illustrates the requirements breakdown for driver assignment in a simple ride-sharing application.",
        "planning": "*   **Top-Level Requirement:** Ride Request Fulfillment (Abstract Requirement)\n*   **Child Requirements:**\n    *   Driver Assignment (Main focus - decompose further)\n    *   Ride Tracking\n    *   Payment Processing\n*   **Driver Assignment Requirements Breakdown:**\n    *   Driver Availability: (Refine to ensure clarity)\n        *   Driver Online Status\n        *   Driver Current Location\n        *   Driver Vehicle Type\n    *   Matching Algorithm: (refine into criteria)\n        *   Proximity Matching (Closest Driver)\n        *   Ride Type Matching (Vehicle Compatibility)\n        *   Driver Rating Considerations (optional)\n    *   Assignment Confirmation: (how the assigned driver will be confirmed)\n        *   Driver Acceptance Time Limit\n        *   Re-assignment Mechanism (if driver declines)\n*   **Relationships:**\n    *   `Ride Request Fulfillment` contains `Driver Assignment`, `Ride Tracking`, and `Payment Processing`.\n    *   `Driver Assignment` contains `Driver Availability`, `Matching Algorithm`, and `Assignment Confirmation`.\n    *   `Driver Availability` contains `Driver Online Status`, `Driver Current Location`, and `Driver Vehicle Type`.\n    *   `Matching Algorithm` contains `Proximity Matching`, `Ride Type Matching`, and potentially `Driver Rating Considerations`.",
        "output": "requirementDiagram\n\n    requirement ride_request_fulfillment { \n        id: RRF\n        text: Ride Request Fulfillment\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement driver_assignment { \n        id: DA\n        text: Driver Assignment\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement ride_tracking { \n        id: RT\n        text: Ride Tracking\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement payment_processing { \n        id: PP\n        text: Payment Processing\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement driver_availability { \n        id: DAV\n        text: Driver Availability\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement matching_algorithm { \n        id: MA\n        text: Matching Algorithm\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement assignment_confirmation { \n        id: AC\n        text: Assignment Confirmation\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement driver_online_status { \n        id: DOS\n        text: Driver Online Status\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement driver_current_location { \n        id: DCL\n        text: Driver Current Location\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement driver_vehicle_type { \n        id: DVT\n        text: Driver Vehicle Type\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement proximity_matching { \n        id: PM\n        text: Proximity Matching\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement ride_type_matching { \n        id: RTM\n        text: Ride Type Matching\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement driver_rating_considerations { \n        id: DRC\n        text: Driver Rating Considerations\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    ride_request_fulfillment - contains -> driver_assignment\n    ride_request_fulfillment - contains -> ride_tracking\n    ride_request_fulfillment - contains -> payment_processing\n\n    driver_assignment - contains -> driver_availability\n    driver_assignment - contains -> matching_algorithm\n    driver_assignment - contains -> assignment_confirmation\n\n    driver_availability - contains -> driver_online_status\n    driver_availability - contains -> driver_current_location\n    driver_availability - contains -> driver_vehicle_type\n\n    matching_algorithm - contains -> proximity_matching\n    matching_algorithm - contains -> ride_type_matching\n    matching_algorithm - contains -> driver_rating_considerations"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Sketch a requirementDiagram depicting the requirements for a basic inventory management system in a retail store.",
        "planning": "*   **Requirements:**\n    *   `Manage Inventory`: Top-level requirement.\n    *   `Track Stock Levels`: Sub-requirement of `Manage Inventory`.\n    *   `Receive Stock`: Sub-requirement of `Manage Inventory`.\n    *   `Update Stock`: Sub-requirement of `Manage Inventory`.\n    *   `Generate Reports`: Sub-requirement of `Manage Inventory`.\n    *   `Alert Low Stock`: Sub-requirement of `Manage Inventory`.\n\n*   **Relationships:**\n    *   `containment`: `Manage Inventory` contains all other requirements.\n    *   `derivation`: Each sub-requirement refines `Manage Inventory`.\n\n*   **Elements (Optional):**\n    *   `Use Cases`: `Restock Inventory`, `Sales Transactions`, `Stock Audit` relating to requirements.\n    *   `Stakeholders`: `Store Manager`, `Inventory Clerk` relating to requirements.",
        "output": "requirementDiagram\n\n    requirement manage_inventory {\n        id: 1\n        text: Manage Inventory\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement track_stock {\n        id: 1.1\n        text: Track Stock Levels\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement receive_stock {\n        id: 1.2\n        text: Receive Stock\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement update_stock {\n        id: 1.3\n        text: Update Stock\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement generate_reports {\n        id: 1.4\n        text: Generate Reports\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement alert_low_stock {\n        id: 1.5\n        text: Alert Low Stock\n        risk: Medium\n        verifymethod: Test\n    }\n\n    element restock_uc {\n        type: Use Case\n        docref: Restock Inventory\n    }\n\n    element sales_uc {\n        type: Use Case\n        docref: Sales Transactions\n    }\n\n    element stock_audit_uc {\n        type: Use Case\n        docref: Stock Audit\n    }\n\n    element store_manager {\n        type: Stakeholder\n        docref: Store Manager\n    }\n\n    element inventory_clerk {\n        type: Stakeholder\n        docref: Inventory Clerk\n    }\n\n\n\n    manage_inventory - contains -> track_stock\n    manage_inventory - contains -> receive_stock\n    manage_inventory - contains -> update_stock\n    manage_inventory - contains -> generate_reports\n    manage_inventory - contains -> alert_low_stock\n\n    track_stock - derives -> manage_inventory\n    receive_stock - derives -> manage_inventory\n    update_stock - derives -> manage_inventory\n    generate_reports - derives -> manage_inventory\n    alert_low_stock - derives -> manage_inventory\n\n    restock_uc - satisfies -> receive_stock\n    sales_uc - satisfies -> update_stock\n    stock_audit_uc - verifies -> track_stock\n\n    store_manager - refines -> manage_inventory\n    inventory_clerk - refines -> manage_inventory"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Generate a requirementDiagram representing the requirements structure for a board game database application's core features.",
        "planning": "**Components:**\n\n*   **Stakeholders:** Game Developers, Game Designers, Players/Users, Database Administrators.\n*   **High-Level Requirements (Use Cases):** Manage Games, Manage Players, Track Game Sessions, Generate Reports, Search Functionality.\n*   **Functional Requirements:**\n    *   Add/Edit/Delete Game Data (Title, Genre, Mechanics, etc.)\n    *   Add/Edit/Delete Player Data (Name, UserID, Stats, etc.)\n    *   Record Game Session Details (Players, Winner, Date, Duration, etc.)\n    *   Generate Reports (e.g., Most Played Games, Player Statistics).\n    *   Efficient Game/Player Search (by various criteria).\n*   **Non-Functional Requirements:**\n    *   Performance (Query Response Time)\n    *   Security (User Authentication, Data Protection)\n    *   Usability (Intuitive Interface)\n    *   Scalability (Handle Large Datasets)\n    *   Reliability (Data Integrity).\n*   **Constraints:**\n    *   Budgetary Constraints\n    *   Technological Constraints (Specific database system, platform).\n*   **Verification/Validation Methods:**\n    *   Unit Testing\n    *   Integration Testing\n    *   User Acceptance Testing.\n\n**Interactions:**\n\n*   Stakeholders *elicit* high-level requirements.\n*   High-level requirements *refine into* functional and non-functional requirements.\n*   Constraints *affect* the feasibility of functional and non-functional requirements.\n*   Functional and non-functional requirements *satisfy* high-level requirements.\n*   Verification/Validation methods *verify* that requirements are met.",
        "output": "requirementDiagram\n\n    element game_developers {\n        type: Stakeholder\n    }\n\n    element game_designers {\n        type: Stakeholder\n    }\n\n    element players {\n        type: Stakeholder\n    }\n\n    element db_admins {\n        type: Stakeholder\n    }\n\n    requirement manage_games {\n        id: UC1\n        text: Manage game data\n    }\n\n    requirement manage_players {\n        id: UC2\n        text: Manage player data\n    }\n\n    requirement track_sessions {\n        id: UC3\n        text: Track game sessions\n    }\n\n    requirement generate_reports {\n        id: UC4\n        text: Generate reports\n    }\n\n    requirement search_functionality {\n        id: UC5\n        text: Search functionality\n    }\n\n    functionalRequirement add_edit_game {\n        id: FR1\n        text: Add Edit Delete Game Data\n    }\n\n    functionalRequirement add_edit_player {\n        id: FR2\n        text: Add Edit Delete Player Data\n    }\n\n    functionalRequirement record_session {\n        id: FR3\n        text: Record Game Session Details\n    }\n\n    functionalRequirement generate_report_func {\n        id: FR4\n        text: Generate Reports\n    }\n\n    functionalRequirement efficient_search {\n        id: FR5\n        text: Efficient Game Player Search\n    }\n\n    performanceRequirement query_response {\n        id: NFR1\n        text: Query Response Time\n    }\n\n    performanceRequirement scalability {\n        id: NFR2\n        text: Handle Large Datasets\n    }\n\n    physicalRequirement security {\n        id: NFR3\n        text: User Authentication Data Protection\n    }\n\n    interfaceRequirement usability {\n        id: NFR4\n        text: Intuitive Interface\n    }\n\n    physicalRequirement reliability {\n        id: NFR5\n        text: Data Integrity\n    }\n\n    designConstraint budgetary_constraints {\n        id: C1\n        text: Budgetary Constraints\n    }\n\n    designConstraint tech_constraints {\n        id: C2\n        text: Technological Constraints\n    }\n\n    element unit_testing {\n        type: Verification\n    }\n\n    element integration_testing {\n        type: Verification\n    }\n\n    element user_acceptance_testing {\n        type: Verification\n    }\n\n    game_developers - refines -> manage_games\n    game_designers - refines -> manage_games\n    players - refines -> manage_players\n    db_admins - refines -> manage_games\n\n    manage_games - refines -> add_edit_game\n    manage_players - refines -> add_edit_player\n    track_sessions - refines -> record_session\n    generate_reports - refines -> generate_report_func\n    search_functionality - refines -> efficient_search\n\n    manage_games - refines -> query_response\n    manage_players - refines -> security\n    track_sessions - refines -> usability\n    generate_reports - refines -> scalability\n    search_functionality - refines -> reliability\n\n    budgetary_constraints - traces -> add_edit_game\n    tech_constraints - traces -> add_edit_game\n\n    add_edit_game - satisfies -> manage_games\n    add_edit_player - satisfies -> manage_players\n    record_session - satisfies -> track_sessions\n    generate_report_func - satisfies -> generate_reports\n    efficient_search - satisfies -> search_functionality\n\n    unit_testing - verifies -> add_edit_game\n    integration_testing - verifies -> add_edit_player\n    user_acceptance_testing - verifies -> record_session"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Develop a requirementDiagram for the requirements guidelines of an automatic email notification system in a customer support ticketing app.",
        "planning": "*   **System (Subject):** \"Automatic Email Notification System\" - Central requirement focus.\n\n*   **Stakeholders (Users):**\n    *   \"Customer\" - Receives notifications, defines content needs.\n    *   \"Support Agent\" - Triggers/manages notifications, needs tracking.\n    *   \"Administrator\" - Configures/maintains the system.\n\n*   **Functional Requirements (Functions):**\n    *   \"Send New Ticket Notification\" - Triggers: Ticket creation.\n    *   \"Send Ticket Update Notification\" - Triggers: Ticket status change.\n    *   \"Send Ticket Assignment Notification\" - Triggers: Ticket assignment.\n    *   \"Send Ticket Resolution Notification\" - Triggers: Ticket resolution.\n    *   \"Manage Notification Templates\" - Allows Admin to customize email content.\n    *   \"Track Notification Delivery\" - Logs successful/failed sends for audit.\n\n*   **Non-Functional Requirements (Qualities):**\n    *   \"Reliable Delivery\" - Ensures emails reach recipients.\n    *   \"Timely Delivery\" - Emails sent promptly after triggering event.\n    *   \"Secure Delivery\" - Protects sensitive data in emails.\n    *   \"Customizable Content\" - Tailored messages for different scenarios.\n\n*   **Relationships:**\n    *   \"Satisfies\" - Functional and Non-Functional Requirements *satisfy* the Stakeholder needs and System requirement.\n    *   \"Triggers\" - Specific events *trigger* Functional Requirements (email sending).\n    *   \"Contains\" - The System *contains* the Functional and Non-Functional Requirements.\n    *   \"Requires\" - Each Functional Requirement may *require* specific configurations or data.",
        "output": "requirementDiagram\n\n  requirement auto_email {\n    id: 1\n    text: Automatic Email Notification System Requirements.\n    risk: Low\n    verifymethod: Test\n  }\n\n  element customer {\n    type: Stakeholder\n  }\n\n  element support_agent {\n    type: Stakeholder\n  }\n\n  element administrator {\n    type: Stakeholder\n  }\n\n  functionalRequirement send_new_ticket {\n    id: 2\n    text: Send New Ticket Notification on Ticket Creation.\n    risk: Low\n    verifymethod: Test\n  }\n\n  functionalRequirement send_update_ticket {\n    id: 3\n    text: Send Ticket Update Notification on Status Change.\n    risk: Low\n    verifymethod: Test\n  }\n\n  functionalRequirement send_assignment_ticket {\n    id: 4\n    text: Send Ticket Assignment Notification.\n    risk: Low\n    verifymethod: Test\n  }\n\n  functionalRequirement send_resolution_ticket {\n    id: 5\n    text: Send Ticket Resolution Notification.\n    risk: Low\n    verifymethod: Test\n  }\n\n  functionalRequirement manage_templates {\n    id: 6\n    text: Manage Notification Templates Configuration.\n    risk: Medium\n    verifymethod: Test\n  }\n\n  functionalRequirement track_delivery {\n    id: 7\n    text: Track Notification Delivery Logs.\n    risk: Medium\n    verifymethod: Test\n  }\n\n  performanceRequirement reliable_delivery {\n    id: 8\n    text: Ensure Reliable Email Delivery.\n    risk: High\n    verifymethod: Test\n  }\n\n  performanceRequirement timely_delivery {\n    id: 9\n    text: Ensure Timely Email Delivery.\n    risk: Medium\n    verifymethod: Test\n  }\n\n  physicalRequirement secure_delivery {\n    id: 10\n    text: Protect Sensitive Data in Emails.\n    risk: High\n    verifymethod: Test\n  }\n\n  physicalRequirement customizable_content {\n    id: 11\n    text: Customizable Messages Content.\n    risk: Low\n    verifymethod: Test\n  }\n\n  auto_email - contains -> send_new_ticket\n  auto_email - contains -> send_update_ticket\n  auto_email - contains -> send_assignment_ticket\n  auto_email - contains -> send_resolution_ticket\n  auto_email - contains -> manage_templates\n  auto_email - contains -> track_delivery\n  auto_email - contains -> reliable_delivery\n  auto_email - contains -> timely_delivery\n  auto_email - contains -> secure_delivery\n  auto_email - contains -> customizable_content\n\n  customer - satisfies -> auto_email\n  support_agent - satisfies -> auto_email\n  administrator - satisfies -> auto_email"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Outline a requirementDiagram that shows the hierarchical requirements for implementing user roles and permissions in an academic library management system.",
        "planning": "*   **Top-Level Requirement:** \"Academic Library Management System with User Roles and Permissions\"\n*   **Child Requirements:** (connected via \"contains\" or \"refines\" relationships)\n    *   \"User Role Management\"\n    *   \"Permission Management\"\n*   **User Role Management Breakdown:**\n    *   \"Define User Roles\" (e.g., Librarian, Student, Professor, Admin)\n    *   \"Assign Users to Roles\"\n    *   \"Modify User Roles\"\n*   **Permission Management Breakdown:**\n    *   \"Define Permissions\" (e.g., Borrow Books, Add Books, Manage Users, Access Reports)\n    *   \"Associate Permissions with Roles\" (crucial interaction)\n    *   \"Enforce Permissions\" (system behavior reflecting role assignments).\n*   **Relationship:** \"Associate Permissions with Roles\" is related to \"Define User Roles\" and \"Define Permissions\" via \"allocates\" or \"satisfies\". The permission management satisfies role definitions\n*   **Elements:**\n    *   Requirements: rectangles with stereotypes like \"Requirement\"\n    *   Relationships: lines with arrowheads showing hierarchy (\"contains\", \"refines\"), allocation (\"allocates\", \"satisfies\")",
        "output": "requirementDiagram\n\n    requirement top_req { # Top-Level Requirement\n        id: 1\n        text: Academic Library Management System with User Roles and Permissions\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement user_role_req { # Child Requirement 1\n        id: 1.1\n        text: User Role Management\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement permission_req { # Child Requirement 2\n        id: 1.2\n        text: Permission Management\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement define_roles_req { # User Role Management Breakdown 1\n        id: 1.1.1\n        text: Define User Roles Librarian Student Professor Admin\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement assign_roles_req { # User Role Management Breakdown 2\n        id: 1.1.2\n        text: Assign Users to Roles\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement modify_roles_req { # User Role Management Breakdown 3\n        id: 1.1.3\n        text: Modify User Roles\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement define_permissions_req { # Permission Management Breakdown 1\n        id: 1.2.1\n        text: Define Permissions Borrow Books Add Books Manage Users Access Reports\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement associate_permissions_req { # Permission Management Breakdown 2\n        id: 1.2.2\n        text: Associate Permissions with Roles\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement enforce_permissions_req { # Permission Management Breakdown 3\n        id: 1.2.3\n        text: Enforce Permissions\n        risk: Low\n        verifymethod: Test\n    }\n\n\n    top_req - contains -> user_role_req\n    top_req - contains -> permission_req\n\n    user_role_req - contains -> define_roles_req\n    user_role_req - contains -> assign_roles_req\n    user_role_req - contains -> modify_roles_req\n\n    permission_req - contains -> define_permissions_req\n    permission_req - contains -> associate_permissions_req\n    permission_req - contains -> enforce_permissions_req\n\n    associate_permissions_req - satisfies -> define_roles_req\n    associate_permissions_req - satisfies -> define_permissions_req"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Create a requirementDiagram for the requirement breakdown of an order tracking feature in an online food ordering application.",
        "planning": "*   **Top-Level Requirement:** Order Tracking Feature (Overall goal).\n\n*   **Child Requirements (Breakdown):**\n\n    *   Real-time Order Status Updates: (Needs \"Order Information\").\n    *   Estimated Delivery Time (ETA): (Needs \"Order Information\", \"Driver Location\", and \"Restaurant Prep Time\").\n    *   Order History: (Needs \"User Authentication\" and \"Order Information\").\n    *   Driver Tracking (Map View): (Needs \"Driver Location\" and \"Order Information\").\n    *   Push Notifications: (Needs \"Order Status\" changes).\n\n*   **Elements that Support the Requirements:**\n\n    *   Order Information: (Data element, used by most child requirements, contains order ID, items, address, etc.).\n    *   Driver Location: (Data element, used by ETA and Driver Tracking).\n    *   Restaurant Prep Time: (Data element, used by ETA).\n    *   User Authentication: (Ensures only the user can access their order history).\n    *   Order Status: (Triggers push notifications).\n\n*   **Relationships:**\n\n    *   `Containment`: Top-level requirement *contains* all child requirements.\n    *   `DeriveReqt`: Child requirements *derive from* the top-level requirement.\n    *   `Satisfy`: Data elements *satisfy* the information needs of the requirements.\n    *   `Trace`: Relationships to link specific data elements to the specific requirements they support.",
        "output": "requirementDiagram\n\n    requirement orderTracking {\n        id: OT1\n        text: Order Tracking Feature\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement realTimeUpdates {\n        id: RTU1\n        text: Real-time Order Status Updates\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement estimatedETA {\n        id: ETA1\n        text: Estimated Delivery Time\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement orderHistory {\n        id: OH1\n        text: Order History\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement driverTracking {\n        id: DT1\n        text: Driver Tracking Map View\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement pushNotifications {\n        id: PN1\n        text: Push Notifications\n        risk: Low\n        verifymethod: Test\n    }\n\n    element orderInfo {\n        type: Data\n    }\n\n    element driverLoc {\n        type: Data\n    }\n\n    element restaurantPrep {\n        type: Data\n    }\n\n    element userAuth {\n        type: System\n    }\n\n    element orderStatus {\n        type: Data\n    }\n\n\n    orderTracking - contains -> realTimeUpdates\n    orderTracking - contains -> estimatedETA\n    orderTracking - contains -> orderHistory\n    orderTracking - contains -> driverTracking\n    orderTracking - contains -> pushNotifications\n\n    realTimeUpdates - derives -> orderTracking\n    estimatedETA - derives -> orderTracking\n    orderHistory - derives -> orderTracking\n    driverTracking - derives -> orderTracking\n    pushNotifications - derives -> orderTracking\n\n    orderInfo - satisfies -> realTimeUpdates\n    orderInfo - satisfies -> estimatedETA\n    driverLoc - satisfies -> estimatedETA\n    restaurantPrep - satisfies -> estimatedETA\n    userAuth - satisfies -> orderHistory\n    driverLoc - satisfies -> driverTracking\n    orderInfo - satisfies -> driverTracking\n    orderStatus - satisfies -> pushNotifications\n\n    orderInfo - traces -> realTimeUpdates\n    orderInfo - traces -> estimatedETA\n    driverLoc - traces -> estimatedETA\n    restaurantPrep - traces -> estimatedETA\n    userAuth - traces -> orderHistory\n    driverLoc - traces -> driverTracking\n    orderInfo - traces -> driverTracking\n    orderStatus - traces -> pushNotifications"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Design a requirementDiagram illustrating the requirements for an IoT-enabled home automation system focusing on lighting control.",
        "planning": "**Components:**\n\n*   **User:** Initiates actions, provides input.\n*   **Mobile App:** User interface for control and monitoring.\n*   **Central Hub:** Processes commands, communicates with devices.\n*   **Smart Lights:** Receives commands, adjusts brightness/color.\n*   **Sensors (Motion, Light):** Detects environmental changes, provides input.\n*   **Cloud Platform (Optional):** Remote access, data storage, analytics.\n\n**Interactions:**\n\n1.  **User -> Mobile App:** User sends commands (e.g., turn on lights).\n2.  **Mobile App -> Central Hub:** App transmits commands to the hub.\n3.  **Central Hub -> Smart Lights:** Hub sends instructions to specific lights.\n4.  **Sensors -> Central Hub:** Sensors send data readings (e.g., motion detected).\n5.  **Central Hub -> Smart Lights (based on sensor data):** Hub triggers actions based on sensor input (e.g., turn on lights when motion detected).\n6.  **Central Hub <-> Cloud Platform (Optional):** Hub sends/receives data from the cloud.\n7.  **Cloud Platform -> Mobile App (Optional):** Cloud pushes notifications/updates to the app.",
        "output": "requirementDiagram\n\n    element user {\n        type: User\n    }\n\n    element mobile_app {\n        type: Mobile App\n    }\n\n    element central_hub {\n        type: Central Hub\n    }\n\n    element smart_lights {\n        type: Smart Lights\n    }\n\n    element motion_sensor {\n        type: Motion Sensor\n    }\n\n    element light_sensor {\n        type: Light Sensor\n    }\n\n    requirement req_lighting_control {\n        id: LC1\n        text: \"Control lighting remotely\"\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement req_motion_detection {\n        id: MD1\n        text: \"Turn on lights upon motion detection\"\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement req_light_level_adjustment {\n        id: LLA1\n        text: \"Adjust lights based on ambient light\"\n        risk: Low\n        verifymethod: Test\n    }\n\n    user - satisfies -> req_lighting_control\n    mobile_app - satisfies -> req_lighting_control\n    central_hub - satisfies -> req_lighting_control\n    smart_lights - satisfies -> req_lighting_control\n\n    motion_sensor - satisfies -> req_motion_detection\n    central_hub - satisfies -> req_motion_detection\n    smart_lights - satisfies -> req_motion_detection\n\n    light_sensor - satisfies -> req_light_level_adjustment\n    central_hub - satisfies -> req_light_level_adjustment\n    smart_lights - satisfies -> req_light_level_adjustment\n\n    user - refines -> mobile_app\n    mobile_app - refines -> central_hub\n    central_hub - refines -> smart_lights\n    motion_sensor - refines -> central_hub\n    light_sensor - refines -> central_hub"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Generate a requirementDiagram detailing the requirements structure for a basic passenger information system in public transit scheduling.",
        "planning": "**Components:**\n\n*   **User Requirements:** (Top Level - High-Level Needs)\n    *   Search for Routes: Find optimal routes between two locations.\n    *   View Schedules: Display departure and arrival times.\n    *   Real-time Updates: Receive notifications about delays and disruptions.\n    *   Fare Information: Display ticket prices and payment options.\n\n*   **System Requirements:** (Decomposition of User Needs)\n    *   Route Calculation: Algorithm to determine best routes. (Refines \"Search for Routes\")\n    *   Schedule Storage: Database to store timetable data. (Enables \"View Schedules\")\n    *   Real-time Data Feed: Integration with transit provider's API. (Enables \"Real-time Updates\")\n    *   Payment Gateway Integration: Securely process payments. (Enables \"Fare Information\")\n    *   User Interface (UI): User-friendly application or website. (Supports all user requirements)\n\n*   **Functional Requirements:** (Detailed technical specifications)\n    *   Route Search Algorithm Efficiency: Specifies performance requirements for the algorithm. (Refines \"Route Calculation\")\n    *   Data Validation: Ensures accuracy of schedule data. (Supports \"Schedule Storage\" and \"Real-time Data Feed\")\n    *   Notification System: Sends alerts to users. (Refines \"Real-time Data Feed\")\n    *   Secure Transaction Handling: Compliance with security standards. (Refines \"Payment Gateway Integration\")\n\n*   **Quality Requirements:** (Non-functional requirements)\n    *   Performance: System responsiveness and speed. (Affects all System Requirements)\n    *   Security: Protection of user data. (Affects \"Payment Gateway Integration\" and \"User Interface\")\n    *   Usability: Ease of use for passengers. (Affects \"User Interface\")\n    *   Reliability: System uptime and availability. (Affects all System Requirements)\n\n**Interactions:**\n\n*   User Requirements are *satisfied by* System Requirements.\n*   System Requirements are *refined by* Functional Requirements.\n*   Quality Requirements *constrain* System and Functional Requirements.\n*   UI *supports* all User Requirements\n*   Functional Requirements *enable* System Requirements.",
        "output": "requirementDiagram\n\n    requirement search_routes {\n        id: UR1\n        text: Search for Routes\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement view_schedules {\n        id: UR2\n        text: View Schedules\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement real_time_updates {\n        id: UR3\n        text: Real-time Updates\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement fare_information {\n        id: UR4\n        text: Fare Information\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement route_calculation {\n        id: SR1\n        text: Route Calculation\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement schedule_storage {\n        id: SR2\n        text: Schedule Storage\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement real_time_data_feed {\n        id: SR3\n        text: Real-time Data Feed\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement payment_gateway {\n        id: SR4\n        text: Payment Gateway Integration\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement user_interface {\n        id: SR5\n        text: User Interface UI\n        risk: Low\n        verifymethod: Test\n    }\n\n    requirement route_algorithm_efficiency {\n        id: FR1\n        text: Route Search Algorithm Efficiency\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement data_validation {\n        id: FR2\n        text: Data Validation\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement notification_system {\n        id: FR3\n        text: Notification System\n        risk: Medium\n        verifymethod: Test\n    }\n\n    requirement secure_transaction {\n        id: FR4\n        text: Secure Transaction Handling\n        risk: High\n        verifymethod: Test\n    }\n\n    requirement performance {\n        id: QR1\n        text: Performance\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement security {\n        id: QR2\n        text: Security\n        risk: High\n        verifymethod: Analysis\n    }\n\n    requirement usability {\n        id: QR3\n        text: Usability\n        risk: Low\n        verifymethod: Analysis\n    }\n\n    requirement reliability {\n        id: QR4\n        text: Reliability\n        risk: Medium\n        verifymethod: Analysis\n    }\n\n    search_routes - satisfies -> route_calculation\n    search_routes - satisfies -> user_interface\n    view_schedules - satisfies -> schedule_storage\n    view_schedules - satisfies -> user_interface\n    real_time_updates - satisfies -> real_time_data_feed\n    real_time_updates - satisfies -> user_interface\n    fare_information - satisfies -> payment_gateway\n    fare_information - satisfies -> user_interface\n\n    route_calculation - refines -> route_algorithm_efficiency\n    schedule_storage - refines -> data_validation\n    real_time_data_feed - refines -> data_validation\n    real_time_data_feed - refines -> notification_system\n    payment_gateway - refines -> secure_transaction\n\n    performance - traces -> route_calculation\n    performance - traces -> schedule_storage\n    performance - traces -> real_time_data_feed\n    performance - traces -> payment_gateway\n\n    security - traces -> payment_gateway\n    security - traces -> user_interface\n\n    usability - traces -> user_interface\n\n    reliability - traces -> route_calculation\n    reliability - traces -> schedule_storage\n    reliability - traces -> real_time_data_feed\n    reliability - traces -> payment_gateway"
    },
    {
        "diagram_type": "requirementDiagram",
        "prompt": "Construct a requirementDiagram for the essential requirements of a simplified Remote Assistance Gadget (RAG) application.",
        "planning": "**Plan:**\n\n1.  **Actors:**\n    *   *Requester:* User needing assistance.\n    *   *Assistant:* User providing assistance.\n\n2.  **Requirements:**\n    *   *RAG shall initiate a remote assistance session.* (Satisfies: Requester, Assistant)\n    *   *RAG shall establish secure connection.* (Satisfies: Requester, Assistant, Refines: \"initiate a remote assistance session\")\n    *   *RAG shall provide screen sharing.* (Satisfies: Assistant, Refines: \"initiate a remote assistance session\")\n    *   *RAG shall provide remote control.* (Satisfies: Assistant, Refines: \"initiate a remote assistance session\")\n    *   *RAG shall enable communication (text/voice).* (Satisfies: Requester, Assistant, Refines: \"initiate a remote assistance session\")\n    *   *RAG shall terminate the remote assistance session.* (Satisfies: Requester, Assistant)\n\n3.  **Rationale (Optional):**\n    *   Briefly explain the importance of each requirement (e.g., \"Secure connection ensures data privacy.\").\n\n4.  **Relationships:**\n    *   *Satisfies:* Connects requirements to actors.\n    *   *Refines:* Connects high-level requirements to more detailed ones.",
        "output": "requirementDiagram\n\n  requirement initiate_session {\n    id: 1\n    text: RAG shall initiate a remote assistance session.\n    risk: Low\n    verifymethod: Test\n  }\n\n  requirement secure_connection {\n    id: 2\n    text: RAG shall establish secure connection.\n    risk: High\n    verifymethod: Analysis\n  }\n\n  requirement screen_sharing {\n    id: 3\n    text: RAG shall provide screen sharing.\n    risk: Low\n    verifymethod: Test\n  }\n\n  requirement remote_control {\n    id: 4\n    text: RAG shall provide remote control.\n    risk: Medium\n    verifymethod: Test\n  }\n\n  requirement communication {\n    id: 5\n    text: RAG shall enable communication text/voice.\n    risk: Low\n    verifymethod: Test\n  }\n\n  requirement terminate_session {\n    id: 6\n    text: RAG shall terminate the remote assistance session.\n    risk: Low\n    verifymethod: Test\n  }\n\n  element requester {\n    type: User\n  }\n\n  element assistant {\n    type: User\n  }\n\n  requester - satisfies -> initiate_session\n  assistant - satisfies -> initiate_session\n\n  requester - satisfies -> secure_connection\n  assistant - satisfies -> secure_connection\n  initiate_session - refines -> secure_connection\n\n  assistant - satisfies -> screen_sharing\n  initiate_session - refines -> screen_sharing\n\n  assistant - satisfies -> remote_control\n  initiate_session - refines -> remote_control\n\n  requester - satisfies -> communication\n  assistant - satisfies -> communication\n  initiate_session - refines -> communication\n\n  requester - satisfies -> terminate_session\n  assistant - satisfies -> terminate_session"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram illustrating how data flows in a simple chat application from message creation to delivery.",
        "planning": "*   **User Input:** Start of the data flow. User types a message.\n*   **Client Application:** Sends the message data to the server.\n*   **Server:** Receives the message, processes it (e.g., stores, identifies recipient).\n*   **Database (Optional):** Stores the message persistently. Flow may skip for temporary messages.\n*   **Server (Delivery):** Sends the message data to the recipient's client application.\n*   **Recipient Client Application:** Receives the message and displays it to the recipient.",
        "output": "sankey-beta\n\nUser_Input,Client_App,100\n\nClient_App,Server,100\n\nServer,Database,70\n\nServer,Recipient_Server,30\n\nDatabase,Recipient_Server,70\n\nRecipient_Server,Recipient_Client,100\n\nRecipient_Client,User_Display,100"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram showing the steps of user authentication in an E-commerce website, from login request to successful authentication.",
        "planning": "*   **Login Request:** User initiates login (e.g., enters credentials on login page).\n*   **Authentication Server:** Receives login request from the e-commerce website.\n*   **Credential Validation:** Authentication server validates the provided credentials (username/password) against stored user data.\n*   **Successful Authentication:** Credentials are valid; user is authenticated.\n*   **Failed Authentication:** Credentials are invalid; authentication fails (sends back failure/error).\n*   **Session Creation:** Upon successful authentication, a user session is created on the server.\n*   **Authentication Token/Cookie Issuance:** Authentication server issues a token or sets a cookie in the user's browser to maintain the authenticated session.\n*   **Authorized Access:** User is granted access to authorized resources and functionalities on the e-commerce website.\n*   **Rejection/Redirect:** The user is rejected, redirected, or required to attempt the login again.",
        "output": "sankey-beta\n\nLoginRequest ECommerceWebsite 100\nECommerceWebsite AuthenticationServer 100\n\nAuthenticationServer CredentialValidation 100\n\nCredentialValidation SuccessfulAuthentication 70\nCredentialValidation FailedAuthentication 30\n\nSuccessfulAuthentication SessionCreation 70\n\nSessionCreation AuthenticationTokenIssuance 70\n\nAuthenticationTokenIssuance AuthorizedAccess 70\n\nFailedAuthentication RejectionRedirect 30"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram depicting the OAuth 2.0 authentication flow in a mobile banking application.",
        "planning": "**Components:**\n\n*   **User:** Initiates the authentication request.\n*   **Mobile Banking App:** Requests authorization.\n*   **Authorization Server:** Authenticates the user, obtains consent, and issues authorization code.\n*   **Resource Server:** Hosts the protected bank data/APIs.\n*   **Token Endpoint:** Part of authorization server, exchanges authorization code for access token and refresh token.\n\n**Interactions (Flows):**\n\n1.  **User** initiates action in **Mobile Banking App**.\n2.  **Mobile Banking App** redirects to **Authorization Server** (with client ID, redirect URI, etc.).\n3.  **Authorization Server** authenticates **User** and requests consent.\n4.  **Authorization Server** redirects **Mobile Banking App** with authorization code.\n5.  **Mobile Banking App** sends authorization code to **Token Endpoint**.\n6.  **Token Endpoint** validates the code and returns access token (and refresh token) to **Mobile Banking App**.\n7.  **Mobile Banking App** uses access token to access protected resources on **Resource Server**.\n8.  **Resource Server** validates access token and returns requested data to **Mobile Banking App**.",
        "output": "sankey-beta\n\nUser,MobileApp,10\nMobileApp,AuthServerRedirect,10\n\nAuthServerRedirect,UserAuth,10\nUserAuth,AuthServerConsent,10\n\nAuthServerConsent,MobileAppCode,10\nMobileAppCode,TokenEndpoint,10\n\nTokenEndpoint,MobileAppToken,10\nMobileAppToken,ResourceServer,10\n\nResourceServer,MobileAppData,10\nMobileAppData,MobileApp,10\n\nMobileApp,User,10"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram illustrating the flow of data packets during a TCP-based file transfer session.",
        "planning": "*   **Sender Application:** Initiates the file transfer.\n*   **Sender TCP:** Segments the data, adds headers, manages connection.\n*   **Network:** Represents the path the packets travel (simplified, not detailed).\n*   **Receiver TCP:** Reassembles the data, acknowledges packets, manages connection.\n*   **Receiver Application:** Receives and reconstructs the file.\n*   **Data Flow:** Main flow representing data packets.\n*   **ACK Flow:** Return flow representing acknowledgment packets.\n*   **SYN Flow:** Initial connection request packet flow.\n*   **SYN-ACK Flow:** Connection acceptance packet flow.\n*   **FIN Flow:** Connection termination request packet flow.\n*   **FIN-ACK Flow:** Connection termination confirmation packet flow.",
        "output": "sankey-beta\n\nSenderApp,SenderTCP,100\nSenderTCP,Network,100\nNetwork,ReceiverTCP,100\nReceiverTCP,ReceiverApp,100\n\nSenderTCP,NetworkACK,10\nNetworkACK,SenderTCPACK,10\n\nSenderApp,SenderTCPSYN,1\nSenderTCPSYN,NetworkSYN,1\nNetworkSYN,ReceiverTCPSYN,1\n\nReceiverTCP,NetworkSYNACK,1\nNetworkSYNACK,SenderTCPSYNACK,1\n\nSenderApp,SenderTCPFIN,1\nSenderTCPFIN,NetworkFIN,1\nNetworkFIN,ReceiverTCPFIN,1\n\nReceiverTCP,NetworkFINACK,1\nNetworkFINACK,SenderTCPFINACK,1"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram demonstrating the client-server login process in a social media application.",
        "planning": "*   **Client (Social Media App):** Initiates the login request.\n*   **User Input:** Represents the username/email and password entered by the user on the client.\n*   **Client-Side Validation:** Checks for basic input errors (e.g., empty fields).\n*   **Network Request (Login Request):** The validated login data is sent over the network to the server.\n*   **Server (Social Media Server):** Receives the login request.\n*   **Server-Side Validation:** Validates the username/email and password format.\n*   **Authentication:** Verifies the user's credentials against stored data (database).\n*   **Database:** Stores user credentials.\n*   **Authorization:** Determines what the user is allowed to access.\n*   **Session Creation:** If authentication is successful, a session is created for the user.\n*   **Response (Authentication Result):** The server sends a response back to the client indicating success or failure.\n*   **Client (Social Media App):** Receives the server's response.\n*   **UI Update:** Updates the user interface based on the authentication result (e.g., navigates to the home screen or displays an error message).",
        "output": "sankey-beta\n\nClient,UserInput,100\nUserInput,ClientSideValidation,100\nClientSideValidation,NetworkRequest,95\nClientSideValidation,UIUpdate,5\n\nNetworkRequest,Server,95\nServer,ServerSideValidation,95\nServerSideValidation,Authentication,90\nServerSideValidation,Response,5\n\nAuthentication,Database,90\nDatabase,Authentication,90\nAuthentication,Authorization,85\nAuthentication,Response,5\n\nAuthorization,SessionCreation,85\nSessionCreation,Response,85\n\nResponse,Client,85\nResponse,UIUpdate,85\n\nClient,UIUpdate,85"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram visualizing the RSA encryption process from plaintext input to ciphertext output in a secure messaging app.",
        "planning": "*   **Plaintext:** Input message before encryption. Flows into \"Encryption\".\n*   **Encryption:** RSA encryption algorithm. Receives Plaintext and Public Key, outputs Ciphertext.\n*   **Public Key:** Key used for encryption. Separate input to \"Encryption\".\n*   **Ciphertext:** Encrypted message. Output from \"Encryption\", flows to \"Transmission/Storage\".\n*   **Transmission/Storage:** Represents sending the ciphertext.\n*   **Decryption:** RSA decryption algorithm. Receives Ciphertext and Private Key, outputs Plaintext.\n*   **Private Key:** Key used for decryption. Separate input to \"Decryption\".",
        "output": "sankey-beta\n\nPlaintext,Encryption,100\nPublic Key,Encryption,100\nEncryption,Ciphertext,100\nCiphertext,Transmission,100\nTransmission,Decryption,100\nPrivate Key,Decryption,100\nDecryption,PlaintextOutput,100"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram showing the flow of messages in a peer-to-peer file sharing system.",
        "planning": "*   **Peers (Nodes):** Multiple nodes representing individual users/computers in the P2P network. Represent at least three peers: Peer A, Peer B, Peer C.\n\n*   **File Request:** Flow from a requesting peer (e.g., Peer A) to other peers (e.g., Peer B, Peer C).\n\n*   **File Query:** Peers (e.g., Peer B, Peer C) search their local files to see if they have the requested file or parts.\n\n*   **File Availability Response:** Flow from peers with the file (or parts) (e.g., Peer B) back to the requesting peer (e.g., Peer A). Indicates availability.\n\n*   **File Transfer (Chunks):** Flow of actual file data/chunks from providing peers (e.g., Peer B) to the requesting peer (e.g., Peer A).\n\n*   **Aggregation:** Show the aggregation of chunks from different peers leading to the completed file at the requesting peer.",
        "output": "sankey-beta\n\nPeerA,FileRequest,100\n\nFileRequest,PeerB,40\nFileRequest,PeerC,60\n\nPeerB,FileQuery,40\nPeerC,FileQuery,60\n\nFileQuery,FileAvailabilityResponse,100\n\nFileAvailabilityResponse,PeerB,40\nFileAvailabilityResponse,PeerC,60\n\nPeerB,FileTransferChunks,40\nPeerC,FileTransferChunks,60\n\nFileTransferChunks,PeerA,100"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram representing the data flow within a rule-based recommendation (RAG) system for a news aggregator.",
        "planning": "*   **User Query:** User's initial request (input).\n*   **News Articles Database:** Source of news content.\n*   **Retrieval:** Process of fetching relevant articles based on the query. Input: User Query. Output: Relevant Articles.\n*   **Rule Engine:** Applies predefined rules to the retrieved articles. Input: Relevant Articles. Output: Filtered Articles.\n*   **Ranking/Scoring:** Ranks filtered articles based on rule application. Input: Filtered Articles. Output: Ranked Articles.\n*   **Recommendation Output:** Presents the ranked articles to the user. Input: Ranked Articles. Output: Recommendation.",
        "output": "sankey-beta\n\nUserQuery,Retrieval,100\n\nRetrieval,RelevantArticles,100\n\nNewsArticlesDatabase,Retrieval,100\n\nRelevantArticles,RuleEngine,90\n\nRuleEngine,FilteredArticles,90\n\nFilteredArticles,RankingScoring,80\n\nRankingScoring,RankedArticles,80\n\nRankedArticles,RecommendationOutput,70\n\nRecommendationOutput,Recommendation,70"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram illustrating resource allocation between microservices in a containerized cloud deployment.",
        "planning": "*   **Microservices:** Identify 3-5 core microservices (e.g., Authentication, Product Catalog, Order Management, Payment Processing, Recommendation Engine).\n*   **Resources:** Focus on CPU, Memory (RAM), and Network Bandwidth as primary resources.\n*   **Containers:** Each microservice resides within one or more containers.\n*   **Cloud Platform:** Consider a high-level platform like Kubernetes or AWS ECS (not shown, but implies resource management).\n*   **Resource Allocation:** Show the flow of CPU, Memory, and Network Bandwidth from the \"Cloud Platform\" (implied) to each containerized microservice. Use Sankey flow thickness to represent the quantity of each resource allocated.\n*   **Inter-Service Communication:** Illustrate network bandwidth consumption *between* microservices. Thicker flows indicate greater communication (e.g., Order Management requesting data from Product Catalog).\n*   **External Requests:** Include a node representing \"External Requests\" (e.g., from users) flowing into the Authentication microservice (and potentially others). Show network bandwidth usage for these requests.",
        "output": "sankey-beta\n\nCloud Platform CPU,Authentication CPU,10\nCloud Platform CPU,Product Catalog CPU,15\nCloud Platform CPU,Order Management CPU,20\nCloud Platform CPU,Payment Processing CPU,5\nCloud Platform CPU,Recommendation Engine CPU,10\n\nCloud Platform Memory,Authentication Memory,20\nCloud Platform Memory,Product Catalog Memory,30\nCloud Platform Memory,Order Management Memory,40\nCloud Platform Memory,Payment Processing Memory,10\nCloud Platform Memory,Recommendation Engine Memory,20\n\nCloud Platform Network,Authentication Network,5\nCloud Platform Network,Product Catalog Network,5\nCloud Platform Network,Order Management Network,5\nCloud Platform Network,Payment Processing Network,5\nCloud Platform Network,Recommendation Engine Network,5\n\nExternal Requests,Authentication Network,10\n\nAuthentication Network,Order Management Network,2\nAuthentication CPU,Order Management CPU, 2\nAuthentication Memory,Order Management Memory, 2\n\nOrder Management Network,Product Catalog Network,8\nOrder Management CPU,Product Catalog CPU, 8\nOrder Management Memory,Product Catalog Memory, 8\n\nOrder Management Network,Payment Processing Network,3\nOrder Management CPU,Payment Processing CPU, 3\nOrder Management Memory,Payment Processing Memory, 3\n\nOrder Management Network,Recommendation Engine Network,5\nOrder Management CPU,Recommendation Engine CPU, 5\nOrder Management Memory,Recommendation Engine Memory, 5\n\nProduct Catalog Network,Recommendation Engine Network,2\nProduct Catalog CPU,Recommendation Engine CPU, 2\nProduct Catalog Memory,Recommendation Engine Memory, 2"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram demonstrating the execution and data flow in a multi-threaded process scheduling scenario.",
        "planning": "*   **Components:**\n    *   Threads (Thread 1, Thread 2, etc.)\n    *   Scheduler\n    *   CPU\n    *   Ready Queue\n    *   Waiting Queue (e.g., I/O, Lock)\n    *   Data (Data A, Data B, etc.)\n\n*   **Interactions/Flows:**\n    *   Threads enter Ready Queue.\n    *   Scheduler selects a Thread from Ready Queue.\n    *   Selected Thread is dispatched to the CPU.\n    *   Thread executes on CPU, processing/generating data.\n    *   Thread can transition to Waiting Queue (I/O, Lock acquisition).\n    *   Thread can transition back to Ready Queue (timeslice expired, I/O completion).\n    *   Data flow between Threads (if shared memory/communication exists). Show the flow of data A to thread 1, thread 1 doing something and flowing to thread 2.\n    *   Scheduler re-evaluates and dispatches another Thread to CPU.\n    *   Thread completes execution.\n\n*   **Sankey Representation:**\n    *   Width of flow lines represents proportion of time/data.\n    *   Nodes are components listed above.\n    *   Flows show transitions/data movement between components.",
        "output": "sankey-beta\n\nReadyQueue,Thread1,25\nReadyQueue,Thread2,15\nReadyQueue,Thread3,10\n\nScheduler,Thread1,25\nScheduler,Thread2,15\nScheduler,Thread3,10\n\nThread1,CPU,25\nThread2,CPU,15\nThread3,CPU,10\n\nCPU,Thread1Execution,25\nCPU,Thread2Execution,15\nCPU,Thread3Execution,10\n\nThread1Execution,DataA,10\nThread1Execution,WaitingQueueIO,5\nThread1Execution,ReadyQueue,10\n\nThread2Execution,DataB,7\nThread2Execution,WaitingQueueLock,3\nThread2Execution,ReadyQueue,5\n\nThread3Execution,DataC,5\nThread3Execution,ReadyQueue,5\n\nWaitingQueueIO,ReadyQueue,5\nWaitingQueueLock,ReadyQueue,3\n\nDataA,Thread2,10\nDataB,Completion,7\nDataC,Completion,5"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram depicting a simplified blockchain transaction flow in a cryptocurrency wallet application.",
        "planning": "*   **Wallet Balance:** Starting point, represents user's available funds.\n\n*   **Transaction Initiation:** User action, specifying recipient and amount.\n\n*   **Transaction Fee Calculation:** Cost associated with network processing.\n\n*   **Funds Transfer:** Movement of cryptocurrency amount to recipient.\n\n*   **Blockchain Network:** Where transaction is broadcast for verification.\n\n*   **Transaction Confirmation:** Confirmation of transaction.\n\n*   **Recipient Wallet:** Endpoint, showing increased balance.\n\n*   **Remaining Balance:** New wallet balance after transaction.\n\n**Interactions:**\n\n*   Wallet Balance flows into Transaction Initiation and Transaction Fee Calculation.\n*   Transaction Initiation and Transaction Fee Calculation flows into Funds Transfer.\n*   Funds Transfer flows into Blockchain Network.\n*   Blockchain Network flows to Transaction Confirmation.\n*   Transaction Confirmation flows to Recipient Wallet and Remaining Balance.",
        "output": "sankey-beta\n\nWalletBalance,TransactionInitiation,50\nWalletBalance,TransactionFeeCalculation,5\n\nTransactionInitiation,FundsTransfer,50\nTransactionFeeCalculation,FundsTransfer,5\n\nFundsTransfer,BlockchainNetwork,55\n\nBlockchainNetwork,TransactionConfirmation,55\n\nTransactionConfirmation,RecipientWallet,50\nTransactionConfirmation,RemainingBalance,5"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram representing data flows between the presentation, business, and data layers in a three-tier web application.",
        "planning": "*   **Layers as Nodes:** Presentation Layer, Business Layer, Data Layer.\n\n*   **User Input:** Flow from Presentation Layer to Business Layer (e.g., \"Request Data\", \"Submit Order\").\n\n*   **Data Processing:** Flow within the Business Layer (consider omitting this internal detail for simplicity).\n\n*   **Data Request:** Flow from Business Layer to Data Layer (e.g., \"Database Query\").\n\n*   **Data Response:** Flow from Data Layer to Business Layer (e.g., \"Query Results\").\n\n*   **Processed Data:** Flow from Business Layer to Presentation Layer (e.g., \"Rendered View\").\n\n*   **Direction:** Flows should generally proceed from Presentation to Data Layer, and then back up to Presentation, with the Business Layer acting as the intermediary.",
        "output": "sankey-beta\n\nPresentation Layer,Business Layer,RequestData\nBusiness Layer,Data Layer,DatabaseQuery\nData Layer,Business Layer,QueryResults\nBusiness Layer,Presentation Layer,RenderedView\nPresentation Layer,Business Layer,SubmitOrder"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram showing data flow in a serverless architecture used for image processing tasks.",
        "planning": "*   **Input Source:**\n    *   Represents where images originate (e.g., User Upload, Object Storage like AWS S3, API Gateway).\n    *   Flows *into* the triggering mechanism.\n\n*   **Trigger (Event Source):**\n    *   Initiates the image processing workflow (e.g., S3 event trigger, API Gateway).\n    *   Flows *into* the function(s).\n\n*   **Function(s) (Compute):**\n    *   Serverless compute service performs image processing (e.g., AWS Lambda, Azure Functions, Google Cloud Functions).\n    *   Can represent multiple functions in a sequence/parallel.\n    *   Flows *into* storage/further processing/output.\n\n*   **Storage (Data Store):**\n    *   Stores processed images (e.g., S3, Cloud Storage, Azure Blob Storage).\n    *   May flow *into* other functions/services if further processing is needed.\n\n*   **Output/Downstream Services:**\n    *   Where processed images are consumed (e.g., CDN, Website, Database, Notification Service).\n    *   Represents the end of the data flow.\n\n*   **API Gateway (Optional):**\n    *   If directly triggering function via HTTP.\n    *   Flows between Input Source and Function.",
        "output": "sankey-beta\n\nUserUpload,S3Trigger,100\nAPIGateway,LambdaFunction,80\nS3,LambdaFunction,60\n\nS3Trigger,LambdaFunction,90\n\nLambdaFunction,ProcessedS3,90\nLambdaFunction,ImageAnalysisService,20\n\nImageAnalysisService,Database,20\n\nProcessedS3,CDN,70\nProcessedS3,Website,20\n\n\nS3Trigger,FunctionRetry,5\nFunctionRetry,LambdaFunction,5"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram illustrating the request flow and response cycle in a RESTful API for a ride-sharing app.",
        "planning": "*   **User App:** Initiates requests (e.g., request ride, get ETA).\n*   **API Gateway:** Entry point; routes requests to appropriate services.\n*   **Authentication/Authorization Service:** Verifies user identity and permissions.\n*   **Ride Matching Service:** Finds suitable drivers based on location and availability.\n*   **Driver App:** Receives ride requests, updates location.\n*   **Location Service:** Tracks user and driver locations.\n*   **Payment Service:** Handles payment processing.\n*   **Notification Service:** Sends notifications to users and drivers.\n*   **Database:** Stores user, driver, ride, and location data.\n*   **Request Flow:** User App -> API Gateway -> Authentication -> Ride Matching -> Driver App/Location/Payment Services.\n*   **Response Flow:** Services -> API Gateway -> User App (with ride details, ETA, cost, etc.) or error messages.",
        "output": "sankey-beta\n\nUserApp,APIGateway,100\n\nAPIGateway,AuthenticationService,20\nAPIGateway,RideMatchingService,30\nAPIGateway,OtherServices,50\n\nAuthenticationService,RideMatchingService,15\nAuthenticationService,UserAppResponse,5\n\nRideMatchingService,DriverApp,25\nRideMatchingService,LocationService,30\nRideMatchingService,PaymentService,15\n\nDriverApp,LocationService,10\n\nLocationService,Database,30\n\nPaymentService,Database,15\n\nDatabase,APIGatewayResponse,55\n\nOtherServices,NotificationService,40\nOtherServices,Database,10\n\nNotificationService,APIGatewayResponse,40\n\nAPIGatewayResponse,UserAppResponse,95\n\nUserAppResponse,UserApp,95"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram visualizing the user registration process, from form submission to account activation in an online forum.",
        "planning": "*   **Input:** Form Submission (Total number of submissions).\n*   **Step 1: Validation:**\n    *   Valid Submission (Passes validation checks).\n    *   Invalid Submission (Fails validation, returns to form).\n*   **Step 2: Account Creation:**\n    *   Account Created (Successful account creation).\n    *   Account Creation Failed (e.g., duplicate username, returns to form with error message).\n*   **Step 3: Email Verification:**\n    *   Email Sent (Verification email successfully dispatched).\n    *   Email Failed to Send (Error sending email, potentially triggers retry or support interaction).\n*   **Step 4: Account Activation:**\n    *   Account Activated (User clicks link in email).\n    *   Account Not Activated (User doesn't click link, account remains inactive).\n*   **Output:**\n    *   Active Accounts (Successfully registered and activated users).\n    *   Inactive Accounts (Registered but not activated users).\n    *   Abandoned Submissions (Invalid submissions or account creation failures. Optionally include returns to form).",
        "output": "sankey-beta\n\nFormSubmission,ValidSubmission,800\nFormSubmission,InvalidSubmission,200\n\nValidSubmission,AccountCreated,750\nValidSubmission,AccountCreationFailed,50\n\nAccountCreated,EmailSent,750\n\nEmailSent,AccountActivated,700\nEmailSent,AccountNotActivated,50\n\nInvalidSubmission,AbandonedSubmissions,200\nAccountCreationFailed,AbandonedSubmissions,50\n\nAccountActivated,ActiveAccounts,700\nAccountNotActivated,InactiveAccounts,50"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram showing the sequential stages of a simple ETL (Extract, Transform, Load) data pipeline.",
        "planning": "*   **Source Data:** Initial data source(s). Flows *into* Extraction.\n*   **Extraction:** Pulling data from the source. Flows *into* Transformation.\n*   **Transformation:** Cleaning, shaping, and enriching data. Flows *into* Loading.\n*   **Loading:** Inserting transformed data into the target destination. Flows *into* Target Data.\n*   **Target Data:** Final data warehouse or destination.\n\nThe width of the flow lines in the Sankey diagram represents the volume of data at each stage (e.g., how much data is extracted, transformed, loaded).",
        "output": "sankey-beta\n\nSourceData,Extraction,100\n\nExtraction,Transformation,95\n\nTransformation,Loading,90\n\nLoading,TargetData,85"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram representing data processing flows in a real-time monitoring system for IoT devices.",
        "planning": "*   **IoT Devices:** Source, generating raw sensor data. Flows *into* Data Ingestion.\n*   **Data Ingestion:** Receives data from IoT Devices. Flows *into* Data Preprocessing.\n*   **Data Preprocessing:** Cleans, transforms, and validates the data. Flows *into* both Real-time Analysis and Storage.\n*   **Real-time Analysis:** Analyzes the preprocessed data for immediate insights. Flows *into* Alerting and Visualization.\n*   **Storage:** Stores the preprocessed data for later use. Flows *into* Historical Analysis.\n*   **Alerting:** Generates alerts based on real-time analysis. End point.\n*   **Visualization:** Displays real-time data insights. End point.\n*   **Historical Analysis:** Analyzes data from storage for long-term trends. Flows *into* Reporting.\n*   **Reporting:** Generates reports based on historical analysis. End point.",
        "output": "sankey-beta\n\nIoT_Devices,Data_Ingestion,100\n\nData_Ingestion,Data_Preprocessing,100\n\nData_Preprocessing,Real_time_Analysis,60\nData_Preprocessing,Storage,40\n\nReal_time_Analysis,Alerting,30\nReal_time_Analysis,Visualization,30\n\nStorage,Historical_Analysis,40\n\nHistorical_Analysis,Reporting,40"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram illustrating the flow of video packets in a UDP-based video streaming service.",
        "planning": "*   **Video Source:** Generates the video stream. Interaction: Output video frames.\n*   **Video Encoder:** Encodes the video frames into compressed video packets. Interaction: Receives frames, outputs encoded packets.\n*   **UDP Packetizer:** Encapsulates encoded video data into UDP packets. Interaction: Receives encoded video data, outputs UDP packets.\n*   **Network (UDP):** Represents the network transporting UDP packets. Interaction: Receives UDP packets, transmits UDP packets.\n*   **UDP Receiver:** Receives UDP packets from the network. Interaction: Receives UDP packets, outputs video data.\n*   **Video Decoder:** Decodes UDP packets to reconstruct video frames. Interaction: Receives decoded video packets, outputs video frames.\n*   **Video Player/Display:** Renders the video frames for viewing. Interaction: Receives video frames, displays video.\n*   **Packet Loss (Network):** A branch off the 'Network' node representing lost packets during transmission, terminating without reaching the 'UDP Receiver'.\n*   **Feedback Channel (optional):** From Video Player/Decoder back to Video Source/Encoder showing (e.g. NACKs, ACK, or bandwidth estimation) to influence the source rate.",
        "output": "sankey-beta\n\nVideoSource,VideoEncoder,100\nVideoEncoder,UDPPacketizer,100\nUDPPacketizer,Network,100\nNetwork,UDPReceiver,90\nNetwork,PacketLoss,10\nUDPReceiver,VideoDecoder,90\nVideoDecoder,VideoPlayer,90\nVideoPlayer,FeedbackChannel,10\nFeedbackChannel,VideoSource,10"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram demonstrating the flow of tasks and status transitions in a Kanban board for software development.",
        "planning": "*   **Tasks (Source Nodes):** Represent individual tasks or stories entering the Kanban system.\n*   **Initial Task States:** Examples: \"Backlog,\" \"Ideas,\" \"Requirements Gathering.\" Arrows flow from these initial task states to the subsequent stage.\n*   **Workflow Stages (Intermediate Nodes):** Columns on the Kanban board. Examples: \"To Do,\" \"In Development,\" \"Code Review,\" \"Testing,\" \"Blocked.\" Tasks flow sequentially through these stages.\n*   **Transitions (Flows/Links):** Indicate movement of tasks between states. Thickness represents the number of tasks transitioning.\n*   **Final Task States (Sink Nodes):** Represent the completion of a task. Examples: \"Done,\" \"Deployed,\" \"Rejected.\"\n*   **Flow Direction:** Left to right (generally) indicating progression.\n*   **Branching/Merging:** Tasks can branch if a task needs to go back to a previous stage. Tasks can merge if they combine into another task.\n*   **Task Count/Volume:** Flow thickness represents the volume of tasks in each stage/transition.",
        "output": "sankey-beta\n\nBacklog,To Do,15\nIdeas,To Do,5\nRequirements Gathering,To Do,3\n\nTo Do,In Development,12\nTo Do,Rejected,2\nTo Do,Backlog,9\n\nIn Development,Code Review,10\nIn Development,Testing,2\nIn Development,Blocked,3\n\nCode Review,Testing,9\nCode Review,In Development,1\n\nTesting,Done,8\nTesting,In Development,1\n\nBlocked,In Development,3\n\nDone,Deployed,8"
    },
    {
        "diagram_type": "sankey",
        "prompt": "Create a sankey diagram representing energy and power flow within a simplified CPU power management system.",
        "planning": "*   **Power Source:** Input, represents total power entering the system (e.g., PSU).\n*   **Voltage Regulator (VRM):** Converts input voltage to CPU core voltage. Power loss due to inefficiency.\n*   **CPU Core:** Receives power from VRM. Power used for computation. Heat generated (power loss).\n*   **CPU Cache:** Receives power from VRM (or separate VRM). Power used for data storage and retrieval. Heat generated.\n*   **Integrated GPU (iGPU):** Receives power from VRM (or separate VRM). Power used for graphics processing. Heat generated.\n*   **Uncore/System Agent:** Receives power from VRM (or separate VRM). Power used for memory controller, PCIe, etc. Heat generated.\n*   **Heat Dissipation:** Output, Represents power lost as heat from CPU Core, Cache, iGPU, and Uncore. Shows where most heat is generated.\n*   **Useful Work (Computation/Graphics):** Output, Represents actual computational or graphical work done by CPU Core and iGPU.\n\n**Interactions/Flows:**\n\n*   Power flows from Power Source to VRM.\n*   VRM distributes power to CPU Core, Cache, iGPU, and Uncore.\n*   Each component (Core, Cache, iGPU, Uncore) dissipates power as heat.\n*   CPU Core and iGPU perform useful work.",
        "output": "sankey-beta\n\nPower_Source Input,VRM,100\n\nVRM,CPU_Core,30\nVRM,CPU_Cache,15\nVRM,iGPU,25\nVRM,Uncore_System Agent,20\nVRM,VRM_Losses,10\n\nCPU_Core,Useful_Work Computation,25\nCPU_Core,Heat_Dissipation Core_Heat,5\n\nCPU_Cache,Heat_Dissipation Cache_Heat,15\n\niGPU,Useful_Work Graphics,20\niGPU,Heat_Dissipation iGPU_Heat,5\n\nUncore_System Agent,Heat_Dissipation Uncore_Heat,20\n\nHeat_Dissipation Core_Heat,Heat Dissipation,5\nHeat_Dissipation Cache_Heat,Heat Dissipation,15\nHeat_Dissipation iGPU_Heat,Heat Dissipation,5\nHeat_Dissipation Uncore_Heat,Heat Dissipation,20\n\nUseful_Work Computation,Useful Work Computation Graphics,25\nUseful_Work Graphics,Useful Work Computation Graphics,20\n\nVRM_Losses,Heat Dissipation,10"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Produce a sequence diagram detailing the process of establishing a TCP connection.",
        "planning": "*   **Client:** Initiates the connection.\n*   **Server:** Listens for connection requests.\n*   **Client -> Server:** SYN (Synchronization) - Client sends a SYN packet to the server.\n*   **Server -> Client:** SYN-ACK (Synchronization-Acknowledgment) - Server responds with SYN-ACK, acknowledging the SYN and sending its own SYN.\n*   **Client -> Server:** ACK (Acknowledgment) - Client sends an ACK, acknowledging the server's SYN, completing the three-way handshake.\n*   **Connection Established:** Data transfer can begin.",
        "output": "sequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: SYN\n    activate Server\n    Server-->>Client: SYN-ACK\n    deactivate Server\n    Client->>Server: ACK\n    Note over Client,Server: Connection Established"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Illustrate with a sequence diagram how a client logs into an E-commerce platform.",
        "planning": "*   **Client (User):** Initiates the login process.\n\n*   **Web Browser/App:** Sends login requests and receives responses.\n\n*   **Load Balancer (Optional):** Distributes requests.\n\n*   **Web Server:** Receives login requests, forwards to Authentication Service.\n\n*   **Authentication Service:** Validates user credentials.\n\n*   **User Database:** Stores user credentials (username/password).\n\n*   **Session Management:** Creates and manages user sessions.\n\n**Interactions:**\n\n1.  Client enters credentials and requests login.\n2.  Web Browser sends login request to Web Server.\n3.  Web Server forwards request to Authentication Service.\n4.  Authentication Service queries User Database for credentials.\n5.  User Database returns credentials.\n6.  Authentication Service validates credentials.\n7.  Authentication Service creates a session in Session Management.\n8.  Authentication Service returns success/failure to Web Server.\n9.  Web Server forwards response to Web Browser.\n10. Web Browser informs client of login status and redirects to the e-commerce platform.\n11. Web Browser sends the session ID with each subsequent request to the Web Server.",
        "output": "sequenceDiagram\n    participant Client\n    participant WebBrowser as Web Browser/App\n    participant WebServer as Web Server\n    participant AuthService as Authentication Service\n    participant UserDB as User Database\n    participant SessionMgmt as Session Management\n\n    Client->>WebBrowser: Enters credentials and requests login\n    WebBrowser->>WebServer: Sends login request\n    WebServer->>AuthService: Forwards request\n    AuthService->>UserDB: Queries for credentials\n    UserDB-->>AuthService: Returns credentials\n    AuthService->>AuthService: Validates credentials\n    alt Successful Login\n        AuthService->>+SessionMgmt: Creates a session\n        SessionMgmt-->>-AuthService: Returns session ID\n        AuthService-->>WebServer: Returns success and session ID\n        WebServer-->>WebBrowser: Returns success and session ID\n        WebBrowser->>Client: Informs client of login success\n        WebBrowser->>WebServer: Sends session ID with subsequent requests\n    else Failed Login\n        AuthService-->>WebServer: Returns failure\n        WebServer-->>WebBrowser: Returns failure\n        WebBrowser->>Client: Informs client of login failure\n    end"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Generate a sequence diagram demonstrating the sequence of interactions in a basic OAuth login flow.",
        "planning": "*   **User:** Initiates login via client application.\n*   **Client Application:** Redirects User to Authorization Server.\n*   **Authorization Server:**\n    *   Presents login prompt to User.\n    *   Authenticates User.\n    *   Requests User consent.\n    *   Redirects User back to Client Application with Authorization Code.\n*   **Client Application:**\n    *   Exchanges Authorization Code for Access Token (with Client Credentials).\n*   **Resource Server:** Receives request from Client Application using Access Token.\n*   **Client Application:** Accesses protected resource using Access Token from Resource Server.\n*   **Database (Optional):** Authorization Server may need to consult a database to validate the user's credentials or persist consent.",
        "output": "sequenceDiagram\n    participant User\n    participant ClientApp as Client Application\n    participant AuthServer as Authorization Server\n    participant ResourceServer as Resource Server\n\n    User->>ClientApp: Initiates Login\n    ClientApp->>AuthServer: Redirects User to Authorization Server\n    activate AuthServer\n    AuthServer->>User: Presents Login Prompt\n    User->>AuthServer: Authenticates User\n    AuthServer->>User: Requests User Consent\n    User->>AuthServer: Grants Consent\n    AuthServer-->>ClientApp: Redirects with Authorization Code\n    deactivate AuthServer\n    ClientApp->>AuthServer: Exchanges Code for Access Token\n    AuthServer-->>ClientApp: Returns Access Token\n    ClientApp->>ResourceServer: Accesses Protected Resource with Access Token\n    ResourceServer-->>ClientApp: Returns Resource"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Draw a sequence diagram for a user sending a message in a chat app.",
        "planning": "*   **User:** Initiates the message sending.\n*   **Chat App Client:** Receives the user's message, prepares it for sending.\n*   **Server:** Receives the message from the client, processes it.\n*   **Database:** Stores the message (optional, but good practice).\n*   **Other Chat App Clients:** Receive the message from the server.\n*   **Interactions:** User -> Chat App Client (send message), Chat App Client -> Server (send message), Server -> Database (store message), Server -> Other Chat App Clients (send message), Server -> Chat App Client (acknowledgment), Other Chat App Clients -> User (view message).",
        "output": "sequenceDiagram\n    participant User\n    participant Client\n    participant Server\n    participant Database\n    participant OtherClients\n\n    User->>Client: Send Message\n    activate Client\n    Client->>Server: Send Message Data\n    deactivate Client\n    activate Server\n    Server->>Database: Store Message\n    activate Database\n    Database-->>Server: Acknowledge Storage\n    deactivate Database\n    Server->>OtherClients: Send Message to Recipients\n    OtherClients->>User: Display Message\n    Server-->>Client: Acknowledge Delivery\n    deactivate Server"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Provide a sequence diagram representing the interaction between user, web server, and database during data retrieval.",
        "planning": "*   **User:** Initiates the request.\n*   **Web Server:** Receives request, processes logic, communicates with DB.\n*   **Database:** Stores and retrieves data.\n\n**Interactions:**\n\n1.  **User -> Web Server:** User sends a data retrieval request (e.g., via a web form).\n2.  **Web Server -> Database:** Web server queries the database for the requested data.\n3.  **Database -> Web Server:** Database returns the requested data to the web server.\n4.  **Web Server -> User:** Web server formats and sends the retrieved data back to the user.",
        "output": "sequenceDiagram\n    participant User\n    participant \"Web Server\"\n    participant Database\n\n    User->>\"Web Server\": Data retrieval request\n    activate \"Web Server\"\n    \"Web Server\"->>Database: Query for requested data\n    activate Database\n    Database-->>\"Web Server\": Requested data\n    deactivate Database\n    \"Web Server\"-->>User: Formatted data response\n    deactivate \"Web Server\""
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Create a sequence diagram showing the data flow in a RESTful API call.",
        "planning": "**Components:**\n\n*   **Client:** Initiates the API call.\n*   **API Gateway (Optional):** Entry point, handles routing, authentication, rate limiting.\n*   **Server/Application:** Processes the request and interacts with data sources.\n*   **Database (Optional):** Stores and retrieves data.\n\n**Interactions:**\n\n1.  **Client -> API Gateway (or Server):** Client sends HTTP Request (e.g., GET, POST) to the API endpoint.\n2.  **API Gateway -> Server:** API Gateway forwards the request to the appropriate Server (if API Gateway is present).\n3.  **Server -> Database:** Server queries or updates the Database (if necessary).\n4.  **Database -> Server:** Database returns data to the Server (if applicable).\n5.  **Server -> API Gateway (or Client):** Server constructs and sends HTTP Response (e.g., JSON data, status code) to API Gateway or directly to the client.\n6.  **API Gateway -> Client:** API Gateway forwards the HTTP Response to the Client (if API Gateway is present).",
        "output": "sequenceDiagram\n    participant Client\n    participant API_Gateway\n    participant Server\n    participant Database\n\n    Client->>API_Gateway: HTTP Request\n    activate API_Gateway\n    API_Gateway->>Server: Request forwarded\n    activate Server\n    Server->>Database: Query/Update\n    activate Database\n    Database-->>Server: Data Response\n    deactivate Database\n    Server-->>API_Gateway: HTTP Response\n    deactivate Server\n    API_Gateway-->>Client: Response forwarded\n    deactivate API_Gateway"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Design a sequence diagram for an admin approving a new user sign-up on a forum platform.",
        "planning": "*   **User:** Initiates sign-up.\n    *   Interaction: Submits sign-up form.\n*   **System:** Receives user sign-up request, saves the information (with \"pending\" status).\n    *   Interaction: Stores user data (pending approval), sends notification to admin.\n*   **Admin:** Receives notification of new user sign-up, views user details, approves or rejects.\n    *   Interaction: Receives notification, views user details, clicks \"Approve\" button.\n*   **Database:** Stores and updates user information.\n    *   Interaction: Receives store and update data request from System.\n*   **System:** Updates user status to \"approved\", sends welcome email to user.\n    *   Interaction: Updates user status in DB, sends confirmation email to user.\n*   **User:** Receives welcome email.\n    *   Interaction: Receives email from System.",
        "output": "sequenceDiagram\n    participant User\n    participant System\n    participant Admin\n    participant Database\n\n    User->>System: Submits Sign-Up Form\n    activate System\n    System->>Database: Store User Data Status Pending\n    activate Database\n    Database-->>System: Confirmation\n    deactivate Database\n    System->>Admin: Notify Admin New User Sign-Up\n    deactivate System\n\n    Admin->>System: Views User Details\n    Admin->>System: Clicks Approve Button\n    activate System\n    System->>Database: Update User Status to Approved\n    activate Database\n    Database-->>System: Confirmation\n    deactivate Database\n    System->>User: Send Welcome Email\n    deactivate System\n\n    User-->>System: Receives Welcome Email"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Depict a sequence diagram of a file upload process in a cloud storage application.",
        "planning": "*   **User:** Initiates the upload.\n*   **Client Application:** Handles user interaction and upload preparation.\n*   **Load Balancer (Optional):** Distributes upload requests.\n*   **API Gateway:** Authenticates and routes requests.\n*   **Upload Service:** Manages upload process (chunking, metadata).\n*   **Storage Service:** Stores file chunks.\n*   **Metadata Service:** Stores file metadata.\n*   **Notification Service (Optional):** Sends upload completion notifications.\n\n**Interactions:**\n\n1.  **User** -> **Client Application:** User selects file, initiates upload.\n2.  **Client Application** -> **API Gateway:** Sends upload request (authenticated).\n3.  **API Gateway** -> **Upload Service:** Routes request to upload service.\n4.  **Upload Service** -> **Storage Service:** Uploads file chunks. (repeated)\n5.  **Upload Service** -> **Metadata Service:** Saves file metadata upon completion.\n6.  **Upload Service** -> **Notification Service (Optional):** Sends notification of completion.\n7.  **Upload Service** -> **Client Application:** Sends upload confirmation.\n8.  **Client Application** -> **User:** Notifies user of successful upload.",
        "output": "sequenceDiagram\n    participant User\n    participant ClientApp as Client Application\n    participant APIGateway as API Gateway\n    participant UploadService as Upload Service\n    participant StorageService as Storage Service\n    participant MetadataService as Metadata Service\n    participant NotificationService as Notification Service\n\n    User->>ClientApp: Selects file initiates upload\n    ClientApp->>APIGateway: Sends upload request authenticated\n    APIGateway->>UploadService: Routes request to upload service\n\n    loop Uploading File Chunks\n        UploadService->>StorageService: Uploads file chunks\n    end\n\n    UploadService->>MetadataService: Saves file metadata\n    UploadService->>NotificationService: Sends notification of completion\n    UploadService->>ClientApp: Sends upload confirmation\n    ClientApp->>User: Notifies user of successful upload"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Show a sequence diagram for online payment authentication in a banking app.",
        "planning": "**Components:**\n\n*   User (on the Banking App)\n*   Banking App\n*   Authentication Server (Bank's Server)\n*   Payment Gateway\n*   Bank Account (Data Store)\n\n**Interactions:**\n\n1.  User initiates payment in Banking App.\n2.  Banking App sends authentication request to Authentication Server.\n3.  Authentication Server challenges user (e.g., via OTP, biometric).\n4.  User provides authentication credentials to Banking App.\n5.  Banking App forwards credentials to Authentication Server.\n6.  Authentication Server verifies credentials.\n7.  Authentication Server authorizes payment to Banking App.\n8.  Banking App sends payment request to Payment Gateway.\n9.  Payment Gateway communicates with Bank Account to process payment.\n10. Bank Account confirms payment success to Payment Gateway.\n11. Payment Gateway confirms payment success to Banking App.\n12. Banking App notifies User of payment success.",
        "output": "sequenceDiagram\n    participant User as Banking App User\n    participant App as Banking App\n    participant AuthServer as Authentication Server\n    participant PaymentGateway\n    participant BankAccount as Bank Account\n\n    User->>App: Initiate Payment\n    App->>AuthServer: Authentication Request\n    AuthServer->>User: Challenge User\n    User->>App: Provide Credentials\n    App->>AuthServer: Forward Credentials\n    AuthServer->>AuthServer: Verify Credentials\n    alt Authentication Successful\n        AuthServer->>App: Authorize Payment\n        App->>PaymentGateway: Payment Request\n        PaymentGateway->>BankAccount: Process Payment\n        BankAccount->>PaymentGateway: Payment Success\n        PaymentGateway->>App: Payment Confirmation\n        App->>User: Notify Payment Success\n    else Authentication Failed\n        AuthServer->>App: Authentication Failed\n        App->>User: Notify Payment Failure\n    end"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Illustrate a sequence diagram for adding an item to the cart in an E-commerce app.",
        "planning": "*   **User:** Initiates the process.\n    *   Clicks \"Add to Cart\" on the product page.\n\n*   **Browser/Client:** Handles user interface and requests.\n    *   Sends \"addToCart\" request to the server.\n\n*   **Server/API:** Processes the request.\n    *   Receives \"addToCart\" request.\n\n*   **Cart Service:** Manages cart data.\n    *   Receives request to add item to cart.\n    *   Retrieves cart data (if exists) or creates new cart.\n    *   Adds item to cart data.\n    *   Persists cart data (e.g., to database).\n\n*   **Database:** Stores cart information.\n    *   Stores or updates the cart data.\n\n*   **Server/API:** Responds to the client.\n    *   Sends success/failure response back to the browser.\n\n*   **Browser/Client:** Updates the UI.\n    *   Displays confirmation message or error message.\n    *   Updates cart count (if applicable).",
        "output": "sequenceDiagram\n    participant User\n    participant Browser\n    participant Server\n    participant CartService\n    participant Database\n\n    User->>Browser: Click 'Add to Cart'\n    Browser->>Server: addToCart request\n    activate Server\n    Server->>CartService: Add item to cart\n    activate CartService\n    CartService->>Database: Retrieve/Create cart data\n    activate Database\n    Database-->>CartService: Cart data\n    deactivate Database\n    CartService->>CartService: Add item to cart data\n    CartService->>Database: Persist cart data\n    activate Database\n    Database-->>CartService: Success\n    deactivate Database\n    CartService-->>Server: Success\n    deactivate CartService\n    Server-->>Browser: Success response\n    deactivate Server\n    Browser->>User: Display confirmation/Update cart count"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Provide a sequence diagram for the password recovery process in a web application.",
        "planning": "*   **User:** Initiates the password recovery process.\n*   **Web Browser:** Sends requests and receives responses.\n*   **Web Application:** Handles user requests, interacts with the database, and sends emails.\n*   **Database:** Stores user credentials and recovery information.\n*   **Email Service:** Sends the password reset link/code to the user.\n\n**Interactions:**\n\n1.  User requests password reset.\n2.  Web Browser sends request to Web Application.\n3.  Web Application verifies user's email in Database.\n4.  Web Application generates a unique reset token and saves it in Database (linked to the user).\n5.  Web Application requests Email Service to send reset link (containing token) to user.\n6.  Email Service sends email to user.\n7.  User clicks the reset link in email.\n8.  Web Browser sends reset request (with token) to Web Application.\n9.  Web Application validates the token against the Database.\n10. If valid, Web Application presents reset password form.\n11. User enters a new password.\n12. Web Browser sends new password to Web Application.\n13. Web Application updates the password in Database (after hashing/salting).\n14. Web Application informs user of successful password reset.\n15. Web Browser displays confirmation.",
        "output": "sequenceDiagram\n    participant User\n    participant \"Web Browser\"\n    participant \"Web Application\"\n    participant Database\n    participant \"Email Service\"\n\n    User->>\"Web Browser\": Requests password reset\n    \"Web Browser\"->>\"Web Application\": Sends request\n    \"Web Application\"->>Database: Verifies user's email\n    Database-->>\"Web Application\": Returns email verification result\n    alt Email found\n        \"Web Application\"->>Database: Generates & saves reset token\n        \"Web Application\"->>\"Email Service\": Requests reset link with token\n        \"Email Service\"->>User: Sends email with reset link\n        User->>\"Web Browser\": Clicks reset link\n        \"Web Browser\"->>\"Web Application\": Sends reset request with token\n        \"Web Application\"->>Database: Validates token\n        Database-->>\"Web Application\": Returns token validation result\n        alt Token valid\n            \"Web Application\"->>\"Web Browser\": Presents reset password form\n            User->>\"Web Browser\": Enters new password\n            \"Web Browser\"->>\"Web Application\": Sends new password\n            \"Web Application\"->>Database: Updates password\n            Database-->>\"Web Application\": Password updated\n            \"Web Application\"->>\"Web Browser\": Informs user of successful reset\n            \"Web Browser\"->>User: Displays confirmation\n        else Token invalid\n            \"Web Application\"->>\"Web Browser\": Shows error message\n            \"Web Browser\"->>User: Displays error message\n        end\n    else Email not found\n     \"Web Application\"->>\"Web Browser\": Shows error message\n            \"Web Browser\"->>User: Displays error message\n    end"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Generate a sequence diagram representing the flow of sending an email notification in a social networking site.",
        "planning": "*   **User:** Initiates action triggering the notification (e.g., posting, commenting).\n\n*   **Social Networking Site (SNS):** Receives user action.\n\n*   **Notification Service:** Component responsible for generating and sending notifications.\n\n*   **Email Service:** Handles the actual sending of emails.\n\n*   **Database:** Stores user data, notification preferences, and potentially notification history.\n\n**Interactions:**\n\n1.  **User** -> **SNS:** Performs action (e.g., post).\n2.  **SNS** -> **Notification Service:** Triggers notification creation (e.g., \"New post\").\n3.  **Notification Service** -> **Database:** Retrieves user email and notification preferences.\n4.  **Notification Service** -> **Email Service:** Sends email request with content.\n5.  **Email Service** -> **User:** Sends email.\n6.  **Notification Service** -> **Database:** (Optional) Logs notification sent.",
        "output": "sequenceDiagram\n    participant User\n    participant SNS as Social Networking Site\n    participant NotificationService as Notification Service\n    participant EmailService as Email Service\n    participant Database\n\n    User->>SNS: Performs Action e.g. Post\n    SNS->>NotificationService: Triggers Notification Creation\n    NotificationService->>Database: Retrieves User Email and Preferences\n    NotificationService->>EmailService: Sends Email Request with Content\n    EmailService->>User: Sends Email\n    NotificationService->>Database: Logs Notification Sent"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Draw a sequence diagram for processing an order in an E-commerce system.",
        "planning": "*   **User:** Initiates the order process.\n*   **Web Browser/App:** User interface for interacting with the system.\n*   **Web Server:** Receives requests from the browser and forwards them.\n*   **Order Service:** Handles order creation, modification, and retrieval.\n*   **Product Catalog Service:** Manages product information (availability, price).\n*   **Inventory Service:** Tracks product stock levels.\n*   **Payment Service:** Processes payments using various methods.\n*   **Shipping Service:** Handles order shipment and tracking.\n*   **Database:** Stores order, product, user, and other related data.\n\n**Interaction Flow:**\n\n1.  **User** adds items to cart via **Web Browser/App**.\n2.  **Web Browser/App** sends cart details to **Web Server**.\n3.  **Web Server** forwards request to **Order Service**.\n4.  **Order Service** retrieves product details from **Product Catalog Service**.\n5.  **Product Catalog Service** returns product information.\n6.  **Order Service** checks inventory with **Inventory Service**.\n7.  **Inventory Service** returns availability.\n8.  **Order Service** creates order and sends payment request to **Payment Service**.\n9.  **Payment Service** processes payment (potentially interacting with external payment gateway, not explicitly in the core sequence).\n10. **Payment Service** confirms payment to **Order Service**.\n11. **Order Service** updates order status in the **Database**.\n12. **Order Service** notifies **Shipping Service**.\n13. **Shipping Service** initiates shipment.\n14. **Order Service** sends confirmation to **Web Server**.\n15. **Web Server** sends confirmation to **Web Browser/App**.\n16. **Web Browser/App** displays order confirmation to **User**.",
        "output": "sequenceDiagram\n    participant User\n    participant WebBrowser as Web Browser/App\n    participant WebServer as Web Server\n    participant OrderService as Order Service\n    participant ProductCatalog as Product Catalog Service\n    participant InventoryService as Inventory Service\n    participant PaymentService as Payment Service\n    participant ShippingService as Shipping Service\n    participant Database\n\n    User->>WebBrowser: Add items to cart\n    WebBrowser->>WebServer: Send cart details\n    WebServer->>OrderService: Forward request\n    OrderService->>ProductCatalog: Retrieve product details\n    ProductCatalog-->>OrderService: Return product information\n    OrderService->>InventoryService: Check inventory\n    InventoryService-->>OrderService: Return availability\n    OrderService->>PaymentService: Send payment request\n    PaymentService-->>OrderService: Confirm payment\n    OrderService->>Database: Update order status\n    OrderService->>ShippingService: Notify shipment\n    ShippingService->>ShippingService: Initiate shipment\n    OrderService->>WebServer: Send confirmation\n    WebServer->>WebBrowser: Send confirmation\n    WebBrowser->>User: Display order confirmation"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Outline a sequence diagram showing interactions during a user session in an online forum.",
        "planning": "*   **User:** The actor initiating actions.\n*   **Web Browser:** The user interface displaying the forum.\n*   **Web Server:** Handles requests and responses.\n*   **Forum Application:** The logic managing forum data.\n*   **Database:** Stores forum data (posts, users, etc.).\n\n**Interactions:**\n\n1.  **User** -> **Web Browser:** User enters credentials (login).\n2.  **Web Browser** -> **Web Server:** Sends login request.\n3.  **Web Server** -> **Forum Application:** Validates user credentials.\n4.  **Forum Application** -> **Database:** Queries user data.\n5.  **Database** -> **Forum Application:** Returns user data.\n6.  **Forum Application** -> **Web Server:** Sends authentication response.\n7.  **Web Server** -> **Web Browser:** Sends authentication confirmation.\n8.  **User** -> **Web Browser:** User navigates to a forum thread.\n9.  **Web Browser** -> **Web Server:** Sends thread request.\n10. **Web Server** -> **Forum Application:** Fetches thread data.\n11. **Forum Application** -> **Database:** Queries thread posts.\n12. **Database** -> **Forum Application:** Returns thread posts.\n13. **Forum Application** -> **Web Server:** Sends thread data.\n14. **Web Server** -> **Web Browser:** Sends thread content.\n15. **User** -> **Web Browser:** User creates a new post.\n16. **Web Browser** -> **Web Server:** Sends new post request.\n17. **Web Server** -> **Forum Application:** Saves the new post.\n18. **Forum Application** -> **Database:** Inserts the new post.\n19. **Database** -> **Forum Application:** Confirms post insertion.\n20. **Forum Application** -> **Web Server:** Sends confirmation.\n21. **Web Server** -> **Web Browser:** Sends post confirmation and updates the thread.\n22. **User** -> **Web Browser:** User logs out.\n23. **Web Browser** -> **Web Server:** Sends logout request.\n24. **Web Server** -> **Forum Application:** Invalidates user session.\n25. **Forum Application** -> **Web Server:** Confirms logout.\n26. **Web Server** -> **Web Browser:** Redirects to login page.",
        "output": "sequenceDiagram\n    participant User\n    participant \"Web Browser\"\n    participant \"Web Server\"\n    participant \"Forum Application\"\n    participant Database\n\n    User->>\"Web Browser\": Enters credentials\n    \"Web Browser\"->>\"Web Server\": Sends login request\n    \"Web Server\"->>\"Forum Application\": Validates user credentials\n    \"Forum Application\"->>Database: Queries user data\n    Database-->>\"Forum Application\": Returns user data\n    \"Forum Application\"->>\"Web Server\": Sends authentication response\n    \"Web Server\"->>\"Web Browser\": Sends authentication confirmation\n\n    User->>\"Web Browser\": Navigates to a forum thread\n    \"Web Browser\"->>\"Web Server\": Sends thread request\n    \"Web Server\"->>\"Forum Application\": Fetches thread data\n    \"Forum Application\"->>Database: Queries thread posts\n    Database-->>\"Forum Application\": Returns thread posts\n    \"Forum Application\"->>\"Web Server\": Sends thread data\n    \"Web Server\"->>\"Web Browser\": Sends thread content\n\n    User->>\"Web Browser\": Creates a new post\n    \"Web Browser\"->>\"Web Server\": Sends new post request\n    \"Web Server\"->>\"Forum Application\": Saves the new post\n    \"Forum Application\"->>Database: Inserts the new post\n    Database-->>\"Forum Application\": Confirms post insertion\n    \"Forum Application\"->>\"Web Server\": Sends confirmation\n    \"Web Server\"->>\"Web Browser\": Sends post confirmation and updates the thread\n\n    User->>\"Web Browser\": Logs out\n    \"Web Browser\"->>\"Web Server\": Sends logout request\n    \"Web Server\"->>\"Forum Application\": Invalidates user session\n    \"Forum Application\"->>\"Web Server\": Confirms logout\n    \"Web Server\"->>\"Web Browser\": Redirects to login page"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Provide a sequence diagram displaying the flow of activities in a customer support ticket system.",
        "planning": "**Components:**\n\n*   **Customer:** Initiates the support request.\n*   **Support Ticket System (UI):** Interface for customers and agents.\n*   **Support Ticket System (Logic):** Handles ticket processing, storage, and notifications.\n*   **Support Agent:** Resolves customer issues.\n*   **Knowledge Base (Optional):** Provides self-service information.\n\n**Interactions:**\n\n1.  **Customer -> Support Ticket System (UI):** Submits ticket (description, issue).\n2.  **Support Ticket System (UI) -> Support Ticket System (Logic):** Sends ticket details.\n3.  **Support Ticket System (Logic):** Creates ticket, assigns ID, notifies agent.\n4.  **Support Ticket System (Logic) -> Support Agent:** Sends new ticket notification.\n5.  **Support Agent -> Support Ticket System (UI):** Views ticket details.\n6.  **Support Agent -> Knowledge Base (Optional):** Searches for solution.\n7.  **Support Agent -> Support Ticket System (UI):** Updates ticket (comments, status).\n8.  **Support Ticket System (UI) -> Support Ticket System (Logic):** Sends updates.\n9.  **Support Ticket System (Logic) -> Customer:** Sends notification of update.\n10. **Customer -> Support Ticket System (UI):** Reviews update, provides feedback (if needed).\n11. **Support Agent -> Support Ticket System (UI):** Resolves the ticket (sets status to closed).\n12. **Support Ticket System (Logic) -> Customer:** Sends confirmation of ticket resolution.",
        "output": "sequenceDiagram\n    participant Customer\n    participant \"Support Ticket System UI\" as UI\n    participant \"Support Ticket System Logic\" as Logic\n    participant \"Support Agent\" as Agent\n    participant \"Knowledge Base\" as KB\n\n    Customer->>UI: Submits ticket\n    UI->>Logic: Sends ticket details\n    Logic->>Logic: Creates ticket assigns ID notifies Agent\n    Logic->>Agent: Sends new ticket notification\n    Agent->>UI: Views ticket details\n    Agent->>KB: Searches for solution\n    Agent->>UI: Updates ticket\n    UI->>Logic: Sends updates\n    Logic->>Customer: Sends notification of update\n    Customer->>UI: Reviews update provides feedback\n    Agent->>UI: Resolves ticket\n    Logic->>Customer: Sends confirmation of ticket resolution"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Generate a sequence diagram illustrating the handoff between microservices during order processing.",
        "planning": "*   **Components:**\n    *   Client (e.g., User Interface)\n    *   Order Service\n    *   Payment Service\n    *   Inventory Service\n    *   Notification Service\n\n*   **Interactions:**\n    1.  Client -> Order Service: Place Order (Request).\n    2.  Order Service -> Payment Service: Initiate Payment (Request).\n    3.  Payment Service -> Order Service: Payment Confirmation (Response).\n    4.  Order Service -> Inventory Service: Reserve Inventory (Request).\n    5.  Inventory Service -> Order Service: Inventory Confirmation (Response).\n    6.  Order Service -> Notification Service: Send Order Confirmation (Request).\n    7.  Order Service -> Client: Order Confirmation (Response).",
        "output": "sequenceDiagram\n    participant Client\n    participant OrderService as Order Service\n    participant PaymentService as Payment Service\n    participant InventoryService as Inventory Service\n    participant NotificationService as Notification Service\n\n    Client->>OrderService: Place Order\n    activate OrderService\n    OrderService->>PaymentService: Initiate Payment\n    activate PaymentService\n    PaymentService-->>OrderService: Payment Confirmation\n    deactivate PaymentService\n    OrderService->>InventoryService: Reserve Inventory\n    activate InventoryService\n    InventoryService-->>OrderService: Inventory Confirmation\n    deactivate InventoryService\n    OrderService->>NotificationService: Send Order Confirmation\n    OrderService-->>Client: Order Confirmation\n    deactivate OrderService"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Show a sequence diagram for the handshake process in a secure communication protocol.",
        "planning": "*   **Participants:**\n    *   Client: Initiates the secure communication.\n    *   Server: Provides the requested service securely.\n*   **Messages/Interactions:**\n    1.  Client Hello: Client sends supported ciphersuites, TLS version, and a random number.\n    2.  Server Hello: Server selects a ciphersuite, TLS version, and sends its own random number and possibly a session ID.\n    3.  Server Certificate: Server sends its digital certificate to the client.\n    4.  Server Key Exchange (Conditional): Server might send additional key exchange information if needed by the chosen ciphersuite.\n    5.  Certificate Request (Conditional): Server may request a client certificate for mutual authentication.\n    6.  Server Hello Done: Server signals the end of the hello messages.\n    7.  Client Certificate (Conditional): Client sends its certificate if requested.\n    8.  Client Key Exchange: Client sends pre-master secret encrypted with the server's public key (or other key exchange method).\n    9.  Change Cipher Spec: Client informs the server that subsequent messages will be encrypted with the negotiated key.\n    10. Finished: Client sends an encrypted message confirming the handshake.\n    11. Change Cipher Spec: Server informs the client that subsequent messages will be encrypted.\n    12. Finished: Server sends an encrypted message confirming the handshake.\n    13. Application Data: Secure communication begins.",
        "output": "sequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: Client Hello (Ciphersuites, TLS Version, Random)\n    Server->>Client: Server Hello (Ciphersuite, TLS Version, Random, Session ID)\n    Server->>Client: Server Certificate\n    Server->>Client: Server Key Exchange (Conditional)\n    Server->>Client: Certificate Request (Conditional)\n    Server->>Client: Server Hello Done\n\n    Client->>Server: Client Certificate (Conditional)\n    Client->>Server: Client Key Exchange\n    Client->>Server: Change Cipher Spec\n    Client->>Server: Finished (Encrypted Handshake Message)\n\n    Server->>Client: Change Cipher Spec\n    Server->>Client: Finished (Encrypted Handshake Message)\n\n    Client->>Server: Application Data (Secure Communication)"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Illustrate a sequence diagram for user registration and email verification in a community web platform.",
        "planning": "*   **User:** Initiates registration.\n*   **Web Browser:** Displays registration form, sends registration data to the web server.\n*   **Web Server:** Receives registration request, validates data, interacts with the database and email service.\n*   **Database:** Stores user data (initially unverified).\n*   **Email Service:** Sends verification email to the user.\n*   **User:** Clicks verification link in the email.\n*   **Web Browser:** Sends verification request (with token) to the web server.\n*   **Web Server:** Receives verification request, validates token, updates user status in the database.\n*   **Database:** User status updated to \"verified\".\n*   **Web Browser:** Displays verification success message to User.",
        "output": "sequenceDiagram\n    participant User\n    participant WebBrowser\n    participant WebServer\n    participant Database\n    participant EmailService\n\n    User->>WebBrowser: Initiates registration\n    WebBrowser->>WebServer: Sends registration data\n    activate WebServer\n    WebServer->>Database: Validates data & Stores (unverified)\n    Database-->>WebServer: Confirmation\n    WebServer->>EmailService: Sends verification email\n    EmailService-->>WebServer: Confirmation\n    deactivate WebServer\n    EmailService-->>User: Verification Email\n\n    User->>WebBrowser: Clicks verification link\n    WebBrowser->>WebServer: Sends verification request with token\n    activate WebServer\n    WebServer->>Database: Validates token & Updates user status\n    Database-->>WebServer: Confirmation of update\n    deactivate WebServer\n    WebServer->>WebBrowser: Verification Success\n    WebBrowser->>User: Displays verification success message"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Create a sequence diagram for a client accessing a weather API service.",
        "planning": "*   **Client:** Initiates the request for weather data.\n*   **Weather App (Optional):** Acts as an intermediary, handling UI and formatting the request.\n*   **API Gateway (Optional):** Manages and routes requests to the Weather API service.\n*   **Weather API Service:** Processes the request and retrieves weather data.\n*   **Weather Data Source:** Holds the actual weather data.\n\n**Interactions:**\n\n1.  **Client -> Weather App (Optional):** Client requests weather data (e.g., for a specific location).\n2.  **Weather App (Optional) -> API Gateway (Optional) / Weather API Service:** Weather App/Client sends API request (location, parameters).\n3.  **API Gateway (Optional) -> Weather API Service:** API Gateway forwards the request.\n4.  **Weather API Service -> Weather Data Source:** API Service requests weather data from data source.\n5.  **Weather Data Source -> Weather API Service:** Data source returns weather data.\n6.  **Weather API Service -> API Gateway (Optional) / Weather App (Optional) / Client:** API Service returns weather data.\n7.  **API Gateway (Optional) -> Weather App (Optional):** API Gateway forwards the data to the Weather App.\n8.  **Weather App (Optional) -> Client:** Weather App displays weather data to the client.",
        "output": "sequenceDiagram\n    participant Client\n    participant WeatherApp as Weather App\n    participant APIGateway as API Gateway\n    participant WeatherAPI as Weather API Service\n    participant DataSource as Weather Data Source\n\n    Client->>WeatherApp: Request weather data\n    WeatherApp->>APIGateway: API Request location parameters\n    APIGateway->>WeatherAPI: Forward request\n    WeatherAPI->>DataSource: Request weather data\n    DataSource-->>WeatherAPI: Return weather data\n    WeatherAPI-->>APIGateway: Return weather data\n    APIGateway-->>WeatherApp: Forward data to Weather App\n    WeatherApp-->>Client: Display weather data"
    },
    {
        "diagram_type": "sequenceDiagram",
        "prompt": "Design a sequence diagram representing the flow of a login process with multi-factor authentication in an online banking system.",
        "planning": "*   **User:** Initiates the login process.\n*   **Browser/Client:** Captures user input and displays the interface.\n*   **Web Server:** Handles initial login request, validates credentials, initiates MFA.\n*   **Authentication Server:** Authenticates user credentials, manages MFA process.\n*   **Database:** Stores user credentials and MFA settings.\n*   **MFA Provider:** Generates and delivers the MFA token (e.g., SMS, authenticator app).\n*   **Interaction Flow:**\n    1.  User enters login credentials in the Browser.\n    2.  Browser sends credentials to Web Server.\n    3.  Web Server forwards credentials to Authentication Server.\n    4.  Authentication Server queries the Database to verify credentials.\n    5.  Database returns credential verification to Authentication Server.\n    6.  Authentication Server requests MFA from MFA Provider (if enabled).\n    7.  MFA Provider sends MFA token to User.\n    8.  User enters MFA token in Browser.\n    9.  Browser sends MFA token to Web Server.\n    10. Web Server forwards MFA token to Authentication Server.\n    11. Authentication Server validates MFA token with MFA Provider.\n    12. MFA Provider confirms token validity to Authentication Server.\n    13. Authentication Server grants access to Web Server.\n    14. Web Server grants access to the User.\n    15. Browser displays the online banking dashboard.",
        "output": "sequenceDiagram\n    participant User\n    participant Browser\n    participant WebServer\n    participant AuthServer\n    participant Database\n    participant MFAProvider\n\n    User->>Browser: Enters login credentials\n    Browser->>WebServer: Sends credentials\n    WebServer->>AuthServer: Forwards credentials\n    AuthServer->>Database: Verify credentials\n    Database-->>AuthServer: Credential verification\n    AuthServer->>MFAProvider: Request MFA token\n    MFAProvider->>User: Sends MFA token\n    User->>Browser: Enters MFA token\n    Browser->>WebServer: Sends MFA token\n    WebServer->>AuthServer: Forwards MFA token\n    AuthServer->>MFAProvider: Validates MFA token\n    MFAProvider-->>AuthServer: Token validity confirmation\n    AuthServer->>WebServer: Grants access\n    WebServer->>User: Grants access\n    Browser->>User: Displays online banking dashboard"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Give a state diagram in Mermaid that illustrates the process of establishing a TCP connection including SYN, SYN-ACK, and ACK transitions.",
        "planning": "*   **Components:**\n    *   Client (Initiator)\n    *   Server (Listener)\n\n*   **States:**\n    *   Client: CLOSED, SYN_SENT, ESTABLISHED\n    *   Server: LISTEN, SYN_RECEIVED, ESTABLISHED\n\n*   **Interactions/Transitions:**\n    *   Client sends SYN to Server. (CLOSED -> SYN_SENT)\n    *   Server receives SYN, sends SYN-ACK to Client. (LISTEN -> SYN_RECEIVED)\n    *   Client receives SYN-ACK, sends ACK to Server. (SYN_SENT -> ESTABLISHED)\n    *   Server receives ACK. (SYN_RECEIVED -> ESTABLISHED)",
        "output": "stateDiagram-v2\n    state Client {\n        [*] --> CLOSED\n        CLOSED --> SYN_SENT : SYN\n        SYN_SENT --> ESTABLISHED : ACK\n    }\n\n    state Server {\n        [*] --> LISTEN\n        LISTEN --> SYN_RECEIVED : SYN\n        SYN_RECEIVED --> ESTABLISHED : ACK\n    }\n\n    SYN_SENT --> SYN_RECEIVED : SYN-ACK"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Generate a state diagram in Mermaid that shows the progression of an e-commerce checkout process with states like Cart, Payment, Confirmation, and Completed.",
        "planning": "*   **States:** Cart, Payment, Confirmation, Completed.\n*   **Transitions:**\n    *   Cart --> Payment: \"Proceed to Checkout\"\n    *   Payment --> Confirmation: \"Payment Successful\" OR \"Payment Failed\" (back to Payment)\n    *   Confirmation --> Completed: \"Order Placed\"\n*   **Error Handling:** Include a \"Payment Failed\" transition back from Payment to Payment.",
        "output": "stateDiagram-v2\n    [*] --> Cart\n\n    Cart --> Payment : Proceed to Checkout\n\n    Payment --> Confirmation : Payment Successful\n    Payment --> Payment : Payment Failed\n\n    Confirmation --> Completed : Order Placed\n\n    Completed --> [*]"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Provide a state diagram in Mermaid depicting the user login workflow for a banking application, including states such as Entering Credentials, Verification, Logged In, and Error.",
        "planning": "*   **Entering Credentials:** Initial state where the user inputs username/password.\n*   **Verification:** Transition from Entering Credentials; system validates credentials.\n*   **Logged In:** Success state; access granted.\n*   **Error:** Error state; invalid credentials or other issues.\n*   **Transitions:**\n    *   Entering Credentials --> Verification (on submission).\n    *   Verification --> Logged In (if successful).\n    *   Verification --> Error (if failed).\n    *   Error --> Entering Credentials (user tries again).\n    *   Logged In --> Entering Credentials (Logout).",
        "output": "stateDiagram-v2\n    [*] --> EnteringCredentials\n    EnteringCredentials --> Verification: Submit\n    Verification --> LoggedIn: Success\n    Verification --> Error: Failure\n    Error --> EnteringCredentials: Retry\n    LoggedIn --> EnteringCredentials: Logout\n\n    state EnteringCredentials {\n        EC_Info : Enter Username/Password\n    }\n\n    state Verification {\n        V_Info : Validating Credentials\n    }\n\n    state LoggedIn {\n        LI_Info : Access Granted\n    }\n\n    state Error {\n        E_Info : Authentication Failed\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Design a state diagram in Mermaid representing the lifecycle of an IoT sensor device with states like Idle, Active, Error, and Maintenance.",
        "planning": "*   **States:** Idle, Active, Error, Maintenance.\n\n*   **Transitions:**\n    *   Idle -> Active: \"Data Request\", \"Scheduled Wake-up\"\n    *   Active -> Idle: \"Data Sent\", \"Timeout\"\n    *   Active -> Error: \"Sensor Failure\", \"Connection Loss\"\n    *   Error -> Maintenance: \"Admin Intervention\", \"Automatic Repair Attempt Failed\"\n    *   Maintenance -> Idle: \"Repair Complete\"\n    *   Maintenance -> Error: \"Repair Failed\"\n    *   Idle -> Maintenance: \"Scheduled Maintenance\"\n    *   Active -> Maintenance: \"Admin Override\"\n    *   Error -> Idle: \"Automatic Recovery\"\n*   **Interactions:**\n    *   Data Request/Wake-up: External trigger activating the sensor.\n    *   Data Sent: Successful data transmission, returning to idle.\n    *   Sensor Failure/Connection Loss: Internal events causing error.\n    *   Admin Intervention/Override: Manual control for maintenance or error handling.\n    *   Automatic Repair/Recovery: Attempt to resolve errors automatically.\n    *   Timeout: Occurs in active state if no data sent within given time.\n    *   Scheduled Maintenance: Periodic maintenance activity\n    *   Repair Complete/Failed: Outcome of maintenance procedure.",
        "output": "stateDiagram-v2\n    [*] --> Idle\n    Idle --> Active: Data Request\\nScheduled Wake-up\n    Active --> Idle: Data Sent\\nTimeout\n    Active --> Error: Sensor Failure\\nConnection Loss\n    Error --> Maintenance: Admin Intervention\\nAutomatic Repair Failed\n    Maintenance --> Idle: Repair Complete\n    Maintenance --> Error: Repair Failed\n    Idle --> Maintenance: Scheduled Maintenance\n    Active --> Maintenance: Admin Override\n    Error --> Idle: Automatic Recovery"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Show a state diagram in Mermaid that visualizes the operation of a chat application with states: Offline, Connecting, Online, Disconnected, and Reconnecting.",
        "planning": "*   **States:** Offline, Connecting, Online, Disconnected, Reconnecting.\n\n*   **Transitions:**\n\n    *   Offline -> Connecting: User initiates connection.\n    *   Connecting -> Online: Successful connection.\n    *   Connecting -> Disconnected: Connection failed.\n    *   Online -> Disconnected: Connection lost (e.g., network issue).\n    *   Disconnected -> Reconnecting: Application attempts reconnection.\n    *   Reconnecting -> Online: Successful reconnection.\n    *   Reconnecting -> Disconnected: Reconnection failed after retries.\n    *   Online -> Offline: User logs out/exits.\n    *   Disconnected -> Offline: User explicitly disconnects/exits.",
        "output": "stateDiagram-v2\n    [*] --> Offline\n\n    Offline --> Connecting: User initiates connection\n\n    Connecting --> Online: Successful connection\n    Connecting --> Disconnected: Connection failed\n\n    Online --> Disconnected: Connection lost\n    Online --> Offline: User logs out/exits\n\n    Disconnected --> Reconnecting: Application attempts reconnection\n    Disconnected --> Offline: User explicitly disconnects/exits\n\n    Reconnecting --> Online: Successful reconnection\n    Reconnecting --> Disconnected: Reconnection failed after retries"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Illustrate a state diagram in Mermaid for a ticket booking system (e.g., movie ticket booking) with states: Available, Reserving, Booked, and Cancelled.",
        "planning": "*   **States:** Available, Reserving, Booked, Cancelled.\n*   **Transitions:**\n    *   Available -> Reserving: `select_seats` event.\n    *   Reserving -> Booked: `payment_successful` event.\n    *   Reserving -> Available: `reservation_timeout`, `user_cancelled` event.\n    *   Booked -> Cancelled: `cancel_ticket` event.\n    *   Booked -> Available: `refund_successful` event (optional, shows full flow).\n    *   Cancelled -> Available: Possible state for re-listing of cancelled tickets.\n*   **Interactions:**\n    *   User selects seats (Available -> Reserving).\n    *   System waits for payment (Reserving state).\n    *   Payment success leads to booking (Reserving -> Booked).\n    *   Cancellation allowed from Booked state.\n    *   Timeouts or user cancellation return to Available.",
        "output": "stateDiagram-v2\n    [*] --> Available\n    Available --> Reserving: select_seats\n    Reserving --> Booked: payment_successful\n    Reserving --> Available: reservation_timeout\n    Reserving --> Available: user_cancelled\n    Booked --> Cancelled: cancel_ticket\n    Booked --> Available: refund_successful\n    Cancelled --> Available"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Develop a state diagram in Mermaid that models the online order process for a food delivery app including states such as Order Received, Preparing, Out for Delivery, Delivered, and Cancelled.",
        "planning": "*   **States:** Order Received, Preparing, Out for Delivery, Delivered, Cancelled.\n*   **Initial State:** Order Received.\n*   **Transitions:**\n    *   Order Received --> Preparing (Event: Restaurant Accepts Order)\n    *   Preparing --> Out for Delivery (Event: Order Ready)\n    *   Out for Delivery --> Delivered (Event: Order Delivered)\n    *   Order Received --> Cancelled (Event: User/Restaurant Cancels - Before Preparation)\n    *   Preparing --> Cancelled (Event: User/Restaurant Cancels - During Preparation)\n    *   Out for Delivery --> Cancelled (Event: Order Cancelled)\n*   **Termination States:** Delivered, Cancelled.",
        "output": "stateDiagram-v2\n    [*] --> OrderReceived\n    OrderReceived --> Preparing: Restaurant Accepts Order\n    Preparing --> OutForDelivery: Order Ready\n    OutForDelivery --> Delivered: Order Delivered\n    OrderReceived --> Cancelled: User/Restaurant Cancels - Before Preparation\n    Preparing --> Cancelled: User/Restaurant Cancels - During Preparation\n    OutForDelivery --> Cancelled: Order Cancelled\n    Delivered --> [*]\n    Cancelled --> [*]"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Generate a state diagram in Mermaid that outlines the OAuth2 authorization process with states like Requesting Authorization, Authorized, Denied, and Token Exchange.",
        "planning": "*   **Client:** Initiates authorization request.\n*   **Authorization Server:** Handles authorization and token issuance.\n*   **Resource Owner:** Grants or denies authorization.\n*   **Resource Server:** Hosts the protected resource.\n\n**Interactions:**\n\n1.  **Client -> Authorization Server:** Authorization Request (User redirected).\n2.  **Authorization Server -> Resource Owner:** Authentication/Consent.\n3.  **Resource Owner -> Authorization Server:** Grant/Deny Authorization.\n4.  **Authorization Server -> Client:** Redirect with Authorization Code (if granted).\n5.  **Client -> Authorization Server:** Token Request (with Authorization Code).\n6.  **Authorization Server -> Client:** Token Response (Access Token, Refresh Token).\n7.  **Client -> Resource Server:** Access Protected Resource (using Access Token).",
        "output": "stateDiagram-v2\n    [*] --> RequestingAuthorization\n    RequestingAuthorization --> Authorized : User Grants Access\n    RequestingAuthorization --> Denied : User Denies Access\n    Authorized --> TokenExchange : Auth Code Received\n    TokenExchange --> AccessingResource : Token Obtained\n    Denied --> [*]\n    AccessingResource --> [*] : Resource Accessed\n\n    state RequestingAuthorization {\n        Client -->> AuthorizationServer : 1. Auth Request\n        AuthorizationServer -->> ResourceOwner : 2. Authenticate/Consent\n    }\n\n    state Authorized {\n        ResourceOwner -->> AuthorizationServer : 3. Grant\n        AuthorizationServer -->> Client : 4. Redirect with Auth Code\n    }\n\n    state Denied {\n        ResourceOwner -->> AuthorizationServer : 3. Deny\n    }\n\n    state TokenExchange {\n        Client -->> AuthorizationServer : 5. Token Request\n        AuthorizationServer -->> Client : 6. Token Response\n    }\n\n    state AccessingResource {\n        Client -->> ResourceServer : 7. Access Resource\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Provide a state diagram in Mermaid representing the user registration workflow with states: Data Entry, Verification, Confirmed, and Locked.",
        "planning": "*   **States:** Data Entry, Verification, Confirmed, Locked.\n*   **Initial State:** Data Entry.\n*   **Transitions:**\n    *   Data Entry -> Verification: On submitting registration data.\n    *   Verification -> Confirmed: On successful verification (e.g., email/SMS).\n    *   Verification -> Data Entry: On verification failure/data correction needed.\n    *   Confirmed -> Locked: On multiple failed login attempts or admin action.\n    *   Locked -> Data Entry: On password reset request/admin unlock.",
        "output": "stateDiagram-v2\n    [*] --> DataEntry\n    DataEntry --> Verification: Submit Registration\n    Verification --> Confirmed: Verification Success\n    Verification --> DataEntry: Verification Failed\n    Confirmed --> Locked: Multiple Failed Logins\n    Locked --> DataEntry: Password Reset\n\n    state DataEntry {\n        DataEntry : Enter User Data\n    }\n\n    state Verification {\n        Verification : Verify User Identity\n    }\n\n    state Confirmed {\n        Confirmed : Account Activated\n    }\n\n    state Locked {\n        Locked : Account Temporarily Disabled\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Construct a state diagram in Mermaid to model an email client's behavior with states like Inbox, Drafting, Sending, Sent, and Failed Delivery.",
        "planning": "*   **States:** Inbox, Drafting, Sending, Sent, Failed Delivery.\n*   **Inbox:** Initial state, receives emails.\n*   **Drafting:** Composing a new email.\n*   **Transitions:**\n    *   Inbox -> Drafting: \"Compose\"\n    *   Drafting -> Sending: \"Send\"\n    *   Sending -> Sent: \"Success\"\n    *   Sending -> Failed Delivery: \"Failure\"\n    *   Failed Delivery -> Drafting: \"Retry\"\n    *   Drafting -> Inbox: \"Discard\", \"Save Draft\"\n    *   Inbox -> Inbox: \"Receive Email\" (Self-loop)\n*   **Interactions:** User actions (Compose, Send, Retry, Discard), System events (Success, Failure, Receive Email).",
        "output": "stateDiagram-v2\n    [*] --> Inbox\n\n    Inbox --> Drafting : Compose\n    Drafting --> Sending : Send\n    Sending --> Sent : Success\n    Sending --> FailedDelivery : Failure\n    FailedDelivery --> Drafting : Retry\n    Drafting --> Inbox : Discard\n    Drafting --> Inbox : SaveDraft\n    Inbox --> Inbox : ReceiveEmail\n\n    state Inbox{\n    }\n    state Drafting{\n    }\n    state Sending{\n    }\n    state Sent{\n    }\n    state FailedDelivery{\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Create a state diagram in Mermaid illustrating the lifecycle of a file in a document management system with states: New, In Use, Archived, and Deleted.",
        "planning": "*   **States:** New, In Use, Archived, Deleted.\n*   **Transitions:**\n    *   New -> In Use (On Open/Edit)\n    *   In Use -> Archived (On Close/Save & Archive)\n    *   In Use -> New (On Save as New Version)\n    *   Archived -> In Use (On Restore & Open/Edit)\n    *   Any State -> Deleted (On Delete)\n    *   New -> Archived (On Archive without Opening)",
        "output": "stateDiagram-v2\n    [*] --> New\n\n    New --> InUse : On Open Edit\n    New --> Archived : On Archive\n\n    InUse --> Archived : On Close Save Archive\n    InUse --> New : On Save as New Version\n\n    Archived --> InUse : On Restore Open Edit\n\n    New --> Deleted : On Delete\n    InUse --> Deleted : On Delete\n    Archived --> Deleted : On Delete\n\n    state New {\n        New : File Created\n    }\n\n    state InUse {\n        InUse : File Opened Edited\n    }\n\n    state Archived {\n        Archived : File Archived\n    }\n\n    state Deleted {\n        Deleted : File Deleted\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Build a state diagram in Mermaid that depicts session management in a web application with states such as New Session, Active, Expired, and Terminated.",
        "planning": "*   **States:** New Session, Active, Expired, Terminated.\n*   **Transitions:**\n    *   New Session -> Active (User Login/Activity)\n    *   Active -> Active (User Activity/Keep-Alive)\n    *   Active -> Expired (Session Timeout)\n    *   Expired -> Terminated (Cleanup/Garbage Collection)\n    *   Active -> Terminated (User Logout/Admin Termination)\n    *   New Session -> Terminated (Session limit reached/failure to authenticate)\n*   **Triggers/Events:** User Login, User Activity, Session Timeout, User Logout, Admin Termination, Authentication Failure, Session Limit.\n*   **Direction:** From creation to termination.",
        "output": "stateDiagram-v2\n    [*] --> NewSession\n    NewSession --> Active : User Login / Activity\n    Active --> Active : User Activity / Keep-Alive\n    Active --> Expired : Session Timeout\n    Expired --> Terminated : Cleanup / Garbage Collection\n    Active --> Terminated : User Logout / Admin Termination\n    NewSession --> Terminated : Session Limit / Auth Failure\n\n    state NewSession {\n        labelNewSession: New Session\n    }\n\n    state Active {\n        labelActive: Active\n    }\n\n    state Expired {\n        labelExpired: Expired\n    }\n\n    state Terminated {\n        labelTerminated: Terminated\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Formulate a state diagram in Mermaid for a simplified blockchain transaction lifecycle with states: Initiated, Validated, Confirmed, and Completed.",
        "planning": "*   **States:** Initiated, Validated, Confirmed, Completed.\n*   **Transitions/Arrows:**\n    *   Initiated --> Validated: Representing the transaction undergoing validation.\n    *   Validated --> Confirmed: Representing the transaction being added to a block.\n    *   Confirmed --> Completed: Representing the transaction's immutability.\n    *   Validated --> Initiated: (Optional) Representing rejection due to invalidity, looping back for resubmission/correction.\n*   **Descriptions (inline):**\n    *   (Initiated): Transaction created and broadcast.\n    *   (Validated): Transaction checked for validity (signatures, sufficient funds, etc.).\n    *   (Confirmed): Transaction included in a block on the blockchain.\n    *   (Completed): Transaction is final and immutable.",
        "output": "stateDiagram-v2\n    [*] --> Initiated\n    Initiated : Transaction created and broadcast\n\n    Initiated --> Validated : Undergoing validation\n    Validated : Transaction checked for validity\n\n    Validated --> Confirmed : Added to a block\n    Confirmed : Included in a block\n\n    Confirmed --> Completed : Immutable\n    Completed : Transaction is final\n\n    Validated --> Initiated : Rejected due to invalidity"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Outline a state diagram in Mermaid for an elevator control system showing states like Idle, Moving Up, Moving Down, and Maintenance.",
        "planning": "*   **States:** Idle, Moving Up, Moving Down, Maintenance.\n*   **Events/Transitions:**\n    *   `Call Up`: Transition from Idle to Moving Up.\n    *   `Call Down`: Transition from Idle to Moving Down.\n    *   `Reached Floor`: Transition from Moving Up/Down to Idle (if no further calls).\n    *   `Maintenance Start`: Transition from any state to Maintenance.\n    *   `Maintenance End`: Transition from Maintenance to Idle.\n    *   `Obstacle Detected`: Transition from Moving Up/Down to Idle\n*   **Interactions:** Events trigger transitions between states. Reached floor needs to handle direction and remaining calls.",
        "output": "stateDiagram-v2\n    [*] --> Idle\n\n    Idle --> MovingUp : Call Up\n    Idle --> MovingDown : Call Down\n    Idle --> Maintenance : Maintenance Start\n\n    MovingUp --> Idle : Reached Floor\n    MovingUp --> Maintenance : Maintenance Start\n    MovingUp --> Idle : Obstacle Detected\n\n    MovingDown --> Idle : Reached Floor\n    MovingDown --> Maintenance : Maintenance Start\n    MovingDown --> Idle : Obstacle Detected\n\n    Maintenance --> Idle : Maintenance End"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Represent a state diagram in Mermaid depicting a basic vending machine operation with states: Idle, Selection, Process Payment, Dispensing, and Out of Service.",
        "planning": "*   **States:** Idle, Selection, Process Payment, Dispensing, Out of Service.\n*   **Transitions:**\n    *   Idle -> Selection: \"Coin Inserted\"\n    *   Selection -> Process Payment: \"Item Selected\"\n    *   Process Payment -> Dispensing: \"Payment Successful\"\n    *   Process Payment -> Idle: \"Payment Failed/Cancelled\"\n    *   Dispensing -> Idle: \"Item Dispensed\"\n    *   Any State -> Out of Service: \"Maintenance Required\"\n    *   Out of Service -> Idle: \"Service Completed\"\n    *   Selection -> Idle: \"Cancel Selection\"",
        "output": "stateDiagram-v2\n    [*] --> Idle\n\n    Idle --> Selection: Coin Inserted\n\n    Selection --> ProcessPayment: Item Selected\n    Selection --> Idle: Cancel Selection\n\n    ProcessPayment --> Dispensing: Payment Successful\n    ProcessPayment --> Idle: Payment Failed or Cancelled\n\n    Dispensing --> Idle: Item Dispensed\n\n    Idle --> OutOfService: Maintenance Required\n    Selection --> OutOfService: Maintenance Required\n    ProcessPayment --> OutOfService: Maintenance Required\n    Dispensing --> OutOfService: Maintenance Required\n\n    OutOfService --> Idle: Service Completed\n\n    state Idle {\n        Idle : Idle State\n    }\n\n    state Selection {\n        Selection : Selection State\n    }\n\n    state ProcessPayment {\n        ProcessPayment : Process Payment State\n    }\n\n    state Dispensing {\n        Dispensing : Dispensing State\n    }\n\n    state OutOfService {\n        OutOfService : Out of Service State\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Draft a state diagram in Mermaid for a postal system's package delivery process with states: Collected, In Transit, Out for Delivery, Delivered, and Returned.",
        "planning": "*   **States:** Collected, In Transit, Out for Delivery, Delivered, Returned (These are the nodes in your diagram).\n\n*   **Transitions:**\n    *   Collected --> In Transit (Trigger: Package dispatched from origin)\n    *   In Transit --> Out for Delivery (Trigger: Package arrives at local delivery hub)\n    *   Out for Delivery --> Delivered (Trigger: Package successfully delivered to recipient)\n    *   Out for Delivery --> Returned (Trigger: Delivery failed after multiple attempts)\n    *   In Transit --> Returned (Trigger: Package damaged/undeliverable before reaching delivery hub)\n\n*   **Start State:** Collected (This is where the process begins)\n\n*   **End States:** Delivered, Returned (These represent the successful or unsuccessful completion of the delivery process)",
        "output": "stateDiagram-v2\n    [*] --> Collected\n    Collected --> InTransit: Dispatched\n    InTransit --> OutforDelivery: Arrived at Hub\n    InTransit --> Returned: Damaged\n    OutforDelivery --> Delivered: Successful\n    OutforDelivery --> Returned: Failed Attempts\n    Delivered --> [*]\n    Returned --> [*]"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Generate a state diagram in Mermaid illustrating the game state flow in a simple turn-based game including states: Player Turn, NPC Turn, Game Over, and Victory.",
        "planning": "*   **States:** Player Turn, NPC Turn, Game Over, Victory.\n*   **Initial State:** Player Turn (where the game starts).\n*   **Transitions:**\n    *   Player Turn -> NPC Turn (after the player's action).\n    *   NPC Turn -> Player Turn (after the NPC's action).\n    *   Player Turn -> Game Over (if player loses).\n    *   NPC Turn -> Game Over (if NPC loses, unlikely but possible).\n    *   Player Turn -> Victory (if player achieves victory condition).\n    *   NPC Turn -> Victory (impossible, included for completeness and edge cases).\n*   **Direction:** Use a standard top-to-bottom or left-to-right flow for readability.",
        "output": "stateDiagram-v2\n    [*] --> PlayerTurn\n    PlayerTurn --> NPCTurn: Player Action\n    NPCTurn --> PlayerTurn: NPC Action\n    PlayerTurn --> GameOver: Player Loses\n    NPCTurn --> GameOver: NPC Loses\n    PlayerTurn --> Victory: Victory Condition\n    NPCTurn --> Victory: Impossible\n\n    state PlayerTurn {\n    }\n\n    state NPCTurn {\n    }\n\n    state GameOver {\n    }\n\n    state Victory {\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Produce a state diagram in Mermaid that models the lifecycle of cryptocurrency minting with states such as Mining, Verification, Block Addition, and Confirmation.",
        "planning": "*   **States:**\n    *   `Mining`: Initial state, cryptocurrency generation.\n    *   `Verification`: Validating the mined block.\n    *   `Block Addition`: Adding the verified block to the blockchain.\n    *   `Confirmation`: Block confirmed by the network.\n\n*   **Transitions/Interactions:**\n    *   `Mining` --> `Verification`: Mining success triggers verification.\n    *   `Verification` --> `Block Addition`: Successful verification adds the block.\n    *   `Block Addition` --> `Confirmation`: Adding block leads to network confirmation.\n    *   `Verification` --> `Mining`: Failed verification returns to mining state.",
        "output": "stateDiagram-v2\n    [*] --> Mining\n    Mining --> Verification: Mining Success\n    Verification --> BlockAddition: Verification Success\n    BlockAddition --> Confirmation: Block Added\n    Verification --> Mining: Verification Failed\n\n    state Mining {\n        Mining : Generating Cryptocurrency\n    }\n\n    state Verification {\n        Verification : Validating Mined Block\n    }\n\n    state BlockAddition {\n        BlockAddition : Adding to Blockchain\n    }\n\n    state Confirmation {\n        Confirmation : Network Confirmation\n    }"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Illustrate a state diagram in Mermaid that shows the process transitions in a customer support ticket system with states: Open, In Progress, Resolved, and Closed.",
        "planning": "*   **States:**\n    *   Open: Initial state when a ticket is created.\n    *   In Progress: Ticket being actively worked on.\n    *   Resolved: Issue is believed to be fixed, awaiting customer confirmation.\n    *   Closed: Ticket is finalized and no further action is needed.\n\n*   **Transitions:**\n    *   Open to In Progress: Agent starts working on the ticket.\n    *   In Progress to Resolved: Agent believes the issue is resolved.\n    *   Resolved to Closed: Customer confirms the solution and closes the ticket.\n    *   Resolved to In Progress: Customer reopens the ticket due to unresolved issue.\n    *   Open to Closed: (Optional) Ticket is invalid or a duplicate and closed directly.",
        "output": "stateDiagram-v2\n    [*] --> Open\n\n    Open --> InProgress : Agent Assigns\n    InProgress --> Resolved : Issue Resolved\n\n    Resolved --> Closed : Customer Confirms\n    Resolved --> InProgress : Customer Reopens\n    Open --> Closed : Invalid or Duplicate"
    },
    {
        "diagram_type": "stateDiagram",
        "prompt": "Present a state diagram in Mermaid representing the document review workflow with states: Draft, Under Review, Approved, Rejected, and Finalized.",
        "planning": "*   **States:** Draft, Under Review, Approved, Rejected, Finalized.\n*   **Initial State:** Draft.\n*   **Transitions:**\n    *   Draft --> Under Review (Submit for Review)\n    *   Under Review --> Approved (Approve)\n    *   Under Review --> Rejected (Reject)\n    *   Approved --> Finalized (Publish/Finalize)\n    *   Rejected --> Draft (Revise)\n    *   Finalized --> Finalized (No Change)",
        "output": "stateDiagram-v2\n    [*] --> Draft\n\n    Draft --> Under_Review: Submit for Review\n    Under_Review --> Approved: Approve\n    Under_Review --> Rejected: Reject\n    Approved --> Finalized: Publish/Finalize\n    Rejected --> Draft: Revise\n    Finalized --> Finalized: No Change"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Generate a timeline diagram showing the major milestones in the development of the TCP/IP protocol.",
        "planning": "**Timeline Diagram Plan: TCP/IP Protocol Development**\n\n**I. Components (Timeline Milestones):**\n\n*   **1969: ARPANET established:** (Foundation - Packet Switching)\n*   **1973: TCP Specification (RFC 675):** (Conceptualization - Basic TCP)\n*   **1974: TCP/IP Specification (RFC 675):** (Conceptualization - First mention of TCP/IP)\n*   **1981: IP Specification (RFC 791):** (IP Defined)\n*   **1981: TCP Specification (RFC 793):** (TCP Defined)\n*   **1983: TCP/IP Protocol Suite Standardization:** (Formalization - TCP/IP becomes standard)\n*   **1983: ARPANET switches to TCP/IP:** (Adoption - Real-world implementation)\n*   **1989: World Wide Web invented (using TCP/IP):** (Application - Impactful use case)\n*   **1990s: Internet Boom:** (Expansion - Widespread adoption, driving further development)\n*   **Present: Ongoing Development (e.g., IPv6):** (Evolution - Continuous updates and improvements)\n\n**II. Interactions (Implicit in Timeline Progression):**\n\n*   Earlier milestones provide the foundation for later milestones.\n*   Specifications drive implementations and adoption.\n*   Adoption leads to further development and standardization.\n*   Real-world use cases (WWW) demonstrate the protocol's value and spur innovation.\n*   Evolving needs (IPv4 address exhaustion) prompt new protocol versions (IPv6).",
        "output": "timeline\n    1969 : ARPANET Established\n    1973 : TCP Specification RFC 675\n    1974 : TCP/IP Specification RFC 675\n    1981 : IP Specification RFC 791\n         : TCP Specification RFC 793\n    1983 : TCP/IP Standardization\n         : ARPANET switches to TCP/IP\n    1989 : World Wide Web Invented\n    1990s : Internet Boom\n    Present : Ongoing Development IPv6"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Create a timeline diagram illustrating the evolution of the Unix operating system and its key release versions.",
        "planning": "*   **Timeline Axis:** Represents chronological order.\n*   **Key Unix Versions:** (e.g., Unix Time-Sharing System, V6, V7, System III, System V, BSD releases, etc.) - Major releases marked as points/nodes on the timeline.\n*   **Branches/Derivatives:** Lines branching off from major releases to show the forks and development of different Unix lineages (e.g., BSD, System V).\n*   **Influential Individuals/Groups:** (e.g., Dennis Ritchie, Ken Thompson, Berkeley CSRG, AT&T) - Associated with the release they contributed to, shown through connection line or annotations to versions.\n*   **Key Features Introduced:** (e.g., virtual memory, TCP/IP support, C programming language, etc.) - Brief labels/annotations near relevant releases.\n*   **Major Milestones/Events:** (e.g., the Unix license changes, the POSIX standard development) - Events shown as point on timeline with description, affecting multiple branches potentially.\n*   **Interactions:**\n    *   Branches show inheritance and divergence.\n    *   Annotations link features/people to their releases.\n    *   Timeline itself shows temporal relationship.\n    *   Milestones/Events might affect all branches appearing at that point of the timeline.",
        "output": "timeline\n    section Early Unix\n        1969 : Unix Time-Sharing System (UTSS) : Ken Thompson & Dennis Ritchie\n        1973 : Unix V4 : C Language\n    section AT&T Unix\n        1977 : Unix V6\n        1979 : Unix V7\n        1982 : System III\n        1983 : System V\n    section BSD Unix\n        1978 : 1BSD\n        1979 : 2BSD\n        1980 : 3BSD : Virtual Memory\n        1981 : 4BSD\n        1983 : 4.2BSD : TCP/IP\n        1986 : 4.3BSD\n    section POSIX and Modern Unix\n        1988 : POSIX Standard\n        1990s : Open Source Unix-like systems : Linux\n        2000s : macOS : Based on BSD"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Provide a timeline diagram that outlines the progression of major programming languages from the 1960s to the 2020s, including languages like Fortran, C, Java, Python, and Go.",
        "planning": "*   **Timeline:** Horizontal axis representing time (1960s-2020s). Clearly marked decades.\n*   **Programming Languages:** Represented as horizontal bars or points along the timeline, indicating their initial release year. (Fortran, C, Java, Python, Go, others where space allows).\n*   **Language Names:** Clearly labeled alongside their respective bars/points.\n*   **Dependencies/Influences (Optional):** Arrows (dashed or solid) connecting languages to show influence. E.g., C influencing C++, Java, etc.\n*   **Brief Descriptors (Optional):** Very short (1-2 words) descriptors near each language indicating their primary purpose/paradigm (e.g., \"Scientific,\" \"Systems,\" \"Object-Oriented,\" \"Scripting\").\n*   **Interaction:** Timeline defines the temporal order. Arrows show how earlier languages influenced the design or adoption of later ones. Descriptors provide context.",
        "output": "timeline\n    1957 : Fortran\n    1972 : C\n    1983 : C++\n    1991 : Python\n    1995 : Java\n    2009 : Go"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Construct a timeline diagram representing the development phases of a chat messaging application, from concept creation to deployment.",
        "planning": "*   **Concept & Ideation:** (Start)\n    *   *Elements:* Market Research, User Personas, Core Feature Definition.\n    *   *Interaction:* Feeds into Requirements Gathering.\n*   **Requirements Gathering & Analysis:**\n    *   *Elements:* Functional Requirements, Non-Functional Requirements, Use Cases.\n    *   *Interaction:* Drives Design & Planning.\n*   **Design & Prototyping:**\n    *   *Elements:* UI/UX Design, Database Schema, System Architecture, Mockups.\n    *   *Interaction:* Informs Development; Prototypes tested for feedback.\n*   **Development:**\n    *   *Elements:* Front-end Development, Back-end Development, API Integration.\n    *   *Interaction:* Builds application based on design; integrated modules tested.\n*   **Testing & Quality Assurance:**\n    *   *Elements:* Unit Testing, Integration Testing, User Acceptance Testing (UAT).\n    *   *Interaction:* Identifies and reports bugs; sends feedback to development for fixes.\n*   **Deployment:**\n    *   *Elements:* Infrastructure Setup, Code Deployment, Database Migration.\n    *   *Interaction:* Puts application live; monitors for stability. (End)",
        "output": "timeline\n    section Concept & Ideation\n        Start : Market Research\n              : User Personas\n              : Core Feature Definition\n\n    section Requirements Gathering & Analysis\n        Requirements : Functional Requirements\n                     : Non-Functional Requirements\n                     : Use Cases\n\n    section Design & Prototyping\n        Design : UI/UX Design\n               : Database Schema\n               : System Architecture\n               : Mockups\n\n    section Development\n        Dev : Front-end Development\n            : Back-end Development\n            : API Integration\n\n    section Testing & Quality Assurance\n        Testing : Unit Testing\n                : Integration Testing\n                : User Acceptance Testing UAT\n\n    section Deployment\n        End : Infrastructure Setup\n            : Code Deployment\n            : Database Migration"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Generate a timeline diagram depicting the key phases in implementing RSA cryptography within a secure communication system.",
        "planning": "**Timeline Diagram Plan: RSA Implementation**\n\n*   **Phase 1: Key Generation (Bob - Receiver)**\n    *   Component: Bob (User/System)\n    *   Action: Generates RSA key pair (Private Key & Public Key)\n    *   Interaction: Uses a key generation algorithm (e.g., selecting primes, calculating modulus, exponents).\n\n*   **Phase 2: Public Key Distribution (Bob to Alice - Sender)**\n    *   Component: Bob, Alice\n    *   Action: Bob shares his Public Key with Alice (secure or insecure channel).\n    *   Interaction: Public key needs to be accessible to Alice, integrity is important for secure communication.\n\n*   **Phase 3: Encryption (Alice - Sender)**\n    *   Component: Alice\n    *   Action: Alice encrypts the message using Bob's Public Key.\n    *   Interaction: Public key used to transform the plaintext message into ciphertext.\n\n*   **Phase 4: Transmission (Alice to Bob - Receiver)**\n    *   Component: Alice, Bob, Communication Channel\n    *   Action: Alice sends the encrypted message (ciphertext) to Bob.\n    *   Interaction: Transmission channel can be insecure, confidentiality is protected by encryption.\n\n*   **Phase 5: Decryption (Bob - Receiver)**\n    *   Component: Bob\n    *   Action: Bob decrypts the ciphertext using his Private Key.\n    *   Interaction: Private key is used to transform the ciphertext back into the original plaintext message.\n\n*   **Phase 6: Secure Communication Established (Bob and Alice)**\n    *   Component: Bob, Alice\n    *   Action: Secure messages now can be sent between Bob and Alice\n    *   Interaction: Communication channel is protected from eavesdropping using encryption.",
        "output": "timeline\n    section RSA Implementation Phases\n\n    KeyGen : Bob generates RSA key pair  Private Key Public Key\n\n    PubKeyDist : Bob shares Public Key with Alice\n\n    Encryption : Alice encrypts message using Bob's Public Key\n\n    Transmission : Alice sends ciphertext to Bob\n\n    Decryption : Bob decrypts ciphertext using Private Key\n\n    SecureComm : Secure communication established between Bob and Alice"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Create a timeline diagram visualizing the history of the Internet, from the ARPANET era to the rise of modern social media.",
        "planning": "*   **Timeline Axis:** Represents time, from ~1969 (ARPANET) to present day.\n\n*   **Key Events (Nodes):**\n    *   ARPANET Creation: First network, TCP/IP protocol birth.\n    *   Email Development: @ symbol, basic email functionality.\n    *   Usenet: Early discussion forum.\n    *   DNS Introduction: Easier naming system.\n    *   World Wide Web (WWW) Invention: HTML, HTTP, URLs; Tim Berners-Lee.\n    *   First Web Browser (Mosaic): Graphical interface.\n    *   Dot-com Boom: Commercialization of the Internet.\n    *   Search Engines (Google): Organize and access information.\n    *   Broadband Adoption: Faster internet access.\n    *   Web 2.0: Interactive web, user-generated content.\n    *   Social Media Platforms (Facebook, Twitter, etc.): Connecting people.\n    *   Mobile Internet: Smartphones, always-on connectivity.\n\n*   **Connections (Arrows/Lines):**\n    *   Linear progression showing chronological order.\n    *   Connections between related events (e.g., TCP/IP protocol influencing the WWW).\n    *   Arrows indicating influence or building upon previous technologies.\n\n*   **Labels:** Concise descriptions for each event node. Dates are important.\n\n*   **Categories (Optional):**\n    *   Color-coding or visual grouping for technological advancements, social impact, and commercialization.",
        "output": "timeline\n    section Early Internet\n        1969 : ARPANET Creation : TCP/IP protocol\n        1972 : Email Development : @ symbol\n        1979 : Usenet : Discussion forum\n    section The Web Emerges\n        1983 : DNS Introduction : Naming system\n        1989 : World Wide Web : HTML HTTP URLs\n        1993 : Mosaic Browser : Graphical interface\n    section Rise of the Modern Internet\n        1995 : Dot-com Boom : Commercialization\n        1998 : Google : Search engine\n    section Broadband and Web 2.0\n        2000 : Broadband Adoption : Faster access\n        2004 : Web 2.0 : User content\n    section Social Media and Mobile\n        2004 : Facebook : Social media\n        2006 : Twitter : Microblogging\n        2007 : Mobile Internet : Smartphones"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Produce a timeline diagram showing the evolution of computer graphics, highlighting major innovations such as early animations, raster graphics, and modern GPU advancements.",
        "planning": "*   **Timeline:** A horizontal axis representing time (years/decades).\n\n*   **Major Innovations (Nodes/Events):** Key advancements as points on the timeline.\n    *   Early Animation (e.g., Zoetrope, Thaumatrope).\n    *   Vector Graphics (e.g., Sketchpad).\n    *   Raster Graphics.\n    *   3D Graphics.\n    *   Texture Mapping.\n    *   Z-buffering.\n    *   Shading Models (e.g., Gouraud, Phong).\n    *   GPU Development.\n    *   Ray Tracing.\n    *   Modern Rendering Techniques (e.g., Path Tracing, Neural Rendering).\n\n*   **Connecting Lines/Arrows:** Show the flow of development and dependencies between innovations. Early techniques influence later ones.\n\n*   **Descriptions (Labels):** Brief text describing each innovation and its significance.\n\n*   **Categories/Sub-timelines (Optional):** Separate lines for hardware and software advancements if detail is desired.",
        "output": "timeline\n    section Early Era\n        1820 : Thaumatrope\n        1834 : Zoetrope\n\n    section Mid 20th Century\n        1963 : Sketchpad\n\n    section Rasterization Era\n        1970s : Raster Graphics\n               : 3D Graphics\n               : Texture Mapping\n               : Z-buffering\n\n    section Shading Era\n        1970s : Gouraud Shading\n        1975 : Phong Shading\n\n    section GPU Era\n        1999 : GPU Development\n               : Ray Tracing\n\n    section Modern Era\n        2000s : Path Tracing\n               : Neural Rendering"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Generate a timeline diagram that outlines the stages of a modern Agile software development cycle, from planning to release.",
        "planning": "**Timeline Diagram Components & Interactions:**\n\n*   **X-Axis:** Time (e.g., weeks, sprints, iterations).\n*   **Stages (Horizontal Bars/Sections):**\n    *   **Planning:**\n        *   **Elements:** Product Backlog creation/refinement, Sprint Planning (defining Sprint Goal, selecting User Stories).\n        *   **Interaction:** Input to Sprint Backlog.\n    *   **Development (Sprints):**\n        *   **Elements:** Development (coding, testing), Daily Stand-ups, Code Reviews.\n        *   **Interaction:** Creates potentially shippable increment.\n    *   **Testing:**\n        *   **Elements:** Unit Testing, Integration Testing, System Testing, User Acceptance Testing (UAT).\n        *   **Interaction:** Provides feedback loop to Development for bug fixes.\n    *   **Review/Demo:**\n        *   **Elements:** Sprint Review (demonstrating increment), Retrospective (team improvement).\n        *   **Interaction:** Feedback informs future Planning and Development.\n    *   **Release:**\n        *   **Elements:** Deployment to production, Release Notes, Monitoring.\n        *   **Interaction:** Makes software available to users.\n*   **Overlapping/Recurring Elements:** Daily Stand-ups (occur throughout Development).\n*   **Arrows:** Illustrate the flow of information/work between stages (e.g., Planning -> Development, Testing -> Development).\n*   **Iterations/Sprints:** Clearly defined sprints of time.",
        "output": "timeline\n    section Planning\n        Week 1 : Product Backlog Refinement\n               : Sprint Planning - Goal Definition\n               : User Story Selection\n    section Development Sprints\n        Week 2-4 : Development - Coding\n                 : Development - Testing\n                 : Daily Stand-ups\n                 : Code Reviews\n    section Testing\n        Week 5 : Unit Testing\n               : Integration Testing\n               : System Testing\n               : User Acceptance Testing UAT\n    section Review/Demo\n        Week 6 : Sprint Review - Increment Demo\n               : Retrospective - Team Improvement\n    section Release\n        Week 7 : Deployment to Production\n               : Release Notes\n               : Monitoring"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Construct a timeline diagram depicting the growth and evolution of an E-commerce platform, from early online stores to current high-tech marketplaces.",
        "planning": "*   **Early Online Stores (1990s):**\n    *   Component: Static HTML Websites, Simple Payment Gateways (e.g., basic credit card processing).\n    *   Interaction: Limited product catalogs, manual order processing.\n\n*   **E-commerce Platforms Emerge (Early 2000s):**\n    *   Component: Shopping Cart Software (e.g., Magento, osCommerce), Basic CRM, Improved Payment Security (SSL).\n    *   Interaction: Dynamic product displays, customer accounts, order tracking.\n\n*   **Mobile Commerce & Social Media (Late 2000s - Early 2010s):**\n    *   Component: Mobile-optimized Websites/Apps, Social Media Integration, User Reviews.\n    *   Interaction: Mobile payments, product sharing on social platforms, influence of user reviews.\n\n*   **Data-Driven Personalization (Mid 2010s):**\n    *   Component: Recommendation Engines, Data Analytics, Targeted Advertising.\n    *   Interaction: Personalized product suggestions, targeted marketing campaigns based on customer behavior.\n\n*   **AI & Advanced Technologies (Late 2010s - Present):**\n    *   Component: AI-powered Chatbots, Voice Commerce, Augmented Reality (AR), Blockchain (for security/transparency).\n    *   Interaction: Automated customer service, voice-activated shopping, virtual product try-ons, secure transactions.\n\n*   **Future Trends:**\n    *   Component: Metaverse Integration, Hyper-personalization, Sustainable E-commerce Solutions.\n    *   Interaction: Immersive shopping experiences, highly individualized product recommendations, eco-friendly practices.",
        "output": "timeline\n    section Early Online Stores (1990s)\n        1990 : Static HTML Websites\n             : Simple Payment Gateways\n             : Limited product catalogs\n             : Manual order processing\n\n    section E-commerce Platforms Emerge (Early 2000s)\n        2000 : Shopping Cart Software\n             : Basic CRM\n             : Improved Payment Security\n             : Dynamic product displays\n             : Customer accounts\n             : Order tracking\n\n    section Mobile Commerce & Social Media (Late 2000s - Early 2010s)\n        2008 : Mobile-optimized Websites/Apps\n             : Social Media Integration\n             : User Reviews\n             : Mobile payments\n             : Product sharing\n             : User review influence\n\n    section Data-Driven Personalization (Mid 2010s)\n        2015 : Recommendation Engines\n             : Data Analytics\n             : Targeted Advertising\n             : Personalized product suggestions\n             : Targeted marketing campaigns\n\n    section AI & Advanced Technologies (Late 2010s - Present)\n        2018 : AI-powered Chatbots\n             : Voice Commerce\n             : Augmented Reality\n             : Blockchain\n             : Automated customer service\n             : Voice-activated shopping\n             : Virtual product try-ons\n             : Secure transactions\n\n    section Future Trends\n        2024 : Metaverse Integration\n             : Hyper-personalization\n             : Sustainable E-commerce Solutions\n             : Immersive shopping experiences\n             : Highly individualized product recommendations\n             : Eco-friendly practices"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Create a timeline diagram that charts the progression of cybersecurity measures, such as the introduction of firewalls, intrusion detection systems, and advanced encryption techniques.",
        "planning": "*   **Timeline Axis:** Represents the passage of time, with clearly marked years or decades.\n\n*   **Cybersecurity Measures (Events):** Specific technologies/practices placed along the timeline.\n    *   Firewalls: Mark the year of introduction/widespread adoption.\n    *   Intrusion Detection Systems (IDS): Mark the year of introduction/widespread adoption.\n    *   Advanced Encryption Techniques (AES, RSA): Mark key advancements/implementation years.\n    *   Antivirus Software: First appearance and significant updates.\n    *   Security Information and Event Management (SIEM): Introduction and evolution.\n    *   Two-Factor Authentication (2FA): Mark its broader adoption.\n    *   Endpoint Detection and Response (EDR): Introduction and development.\n    *   Cloud Security: Emergence of security solutions specific to cloud environments.\n    *   AI in Cybersecurity: Initial implementations and growth.\n    *   Zero Trust Architecture: Introduction and adoption.\n\n*   **Threat Landscape (Context):** Briefly note major cyber threats that drove the development of these measures.\n    *   Viruses/Worms: (Early Internet era) Driving need for antivirus/firewalls.\n    *   Data Breaches (Increasing): Driving the need for encryption, IDS/IPS, SIEM.\n    *   Ransomware: (More recent) Impacting EDR, backup/recovery strategies.\n    *   Nation-State Attacks: Influencing advanced threat detection, zero trust.\n\n*   **Interaction Arrows/Lines:** To show relationships between events.\n    *   A threat (e.g., increased data breaches) *drives* the development/adoption of a countermeasure (e.g., better encryption, SIEM).\n    *   One measure builds upon another (e.g., Firewalls paved the way for more complex network security like IDS).\n\n*   **Labels/Descriptions:** Concise descriptions of each measure/threat.",
        "output": "timeline\n    section Early Era\n        1980s : Antivirus Software\n        1990s : Firewalls : Viruses/Worms drive need for protection\n\n    section Expanding Threats\n        2000s : Intrusion Detection Systems IDS\n             : Data Breaches increase need for security\n        2005 : Advanced Encryption Standard AES\n        2010 : Security Information and Event Management SIEM\n             : Two-Factor Authentication 2FA\n\n    section Modern Security\n        2013 : Endpoint Detection and Response EDR\n             : Ransomware impacts security strategies\n        2015 : Cloud Security\n             : Solutions specific to cloud environments emerge\n        2017 : AI in Cybersecurity\n             : Initial implementations and growth\n        2020 : Zero Trust Architecture\n             : Nation-State Attacks influence threat detection"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Generate a timeline diagram outlining the historical milestones of artificial intelligence research, from early neural networks to contemporary deep learning models.",
        "planning": "*   **Timeline Axis:** Horizontal line representing time, with clearly marked years or decades.\n\n*   **Milestone Markers:** Points on the timeline indicating specific breakthroughs or significant events.\n\n*   **Milestone Labels:** Text descriptions associated with each marker, summarizing the milestone (e.g., \"Perceptron Invented,\" \"Expert Systems Boom,\" \"ImageNet Breakthrough\").\n\n*   **Categories (Optional):** Color-coding or grouping milestones by AI subfield (e.g., Neural Networks, Symbolic AI, Machine Learning). This helps visualize the evolution of different approaches.\n\n*   **Connections/Relationships (Optional):** Arrows or lines linking related milestones, illustrating how one development led to another (e.g., \"Backpropagation\" leading to \"Deep Learning\").\n\n*   **Visual Hierarchy:** Use font sizes or visual prominence to emphasize particularly important milestones.",
        "output": "timeline\n    section 1940s-1960s: The Birth of AI\n        1943 : McCulloch-Pitts Neuron : First conceptual model of artificial neurons\n        1950 : Turing Test Proposed : A test for machine intelligence\n        1956 : Dartmouth Workshop : The term \"Artificial Intelligence\" is coined\n        1957 : Perceptron Invented : Early neural network model\n\n    section 1970s-1980s: Expert Systems and AI Winter\n        1972 : MYCIN : Rule-based expert system for medical diagnosis\n        1980s : Expert Systems Boom : AI becomes commercially viable\n        1987 : AI Winter Begins : Funding and interest in AI decline\n\n    section 1990s-2000s: Statistical AI and Machine Learning\n        1997 : Deep Blue Beats Kasparov : AI wins at chess\n        1998 : LeNet-5 : Convolutional Neural Network for digit recognition\n        2000s : Statistical ML Emerges : Focus on data-driven approaches\n\n    section 2010s-Present: Deep Learning Revolution\n        2012 : ImageNet Breakthrough : Deep learning revolutionizes image recognition\n        2014 : Seq2Seq Models : Neural machine translation advances\n        2015 : AlphaGo Beats Lee Sedol : AI masters the game of Go\n        2018 : BERT : Pre-trained language model transforms NLP\n        2020s : Large Language Models : GPT family and other models"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Construct a timeline diagram illustrating the key events in the development of the World Wide Web, emphasizing significant inventions and regulatory changes.",
        "planning": "*   **Timeline:** Horizontal axis representing years/decades.\n\n*   **Key Events (Nodes):** Points along the timeline marking inventions/changes.\n\n*   **Inventions:**\n    *   **HTTP, HTML, URL (Tim Berners-Lee):** Foundation. Enable linking, formatting, addressing.\n    *   **Web Browsers (Mosaic, Netscape):** User interface to access web content. Increased accessibility.\n    *   **Search Engines (Google):** Discovery of information. Centralized access.\n\n*   **Regulatory Changes:**\n    *   **Section 230 (US):** Protects online platforms. Encouraged platform growth.\n    *   **GDPR (EU):** Data privacy regulation. Impacts data collection, usage, and user consent.\n    *   **Net Neutrality Debates:** Regulations concerning equal access and speed. Affects ISP behavior.\n\n*   **Interactions (Arrows/Connections):**\n    *   **Invention -> Browser:** An invention makes browsing possible.\n    *   **Browser -> Search Engine:** Browsers provided interfaces for accessing search.\n    *   **Search Engine -> Growth/Expansion:** Search engines accelerate web adoption and content creation.\n    *   **Growth/Expansion -> Regulatory Change:** Increased web usage drives need for regulation (privacy, etc.).",
        "output": "timeline\n    section Early Web\n        1989 : HTTP HTML URL\n        1993 : Mosaic Web Browser\n    section Web Evolution\n        1998 : Google Search Engine\n    section Regulatory Landscape\n        1996 : Section 230 US\n        2018 : GDPR EU\n        2010s : Net Neutrality Debates"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Produce a timeline diagram visualizing the transformation of computing services, from mainframe-based systems to modern cloud computing and hybrid solutions.",
        "planning": "**Timeline Components & Interactions Plan:**\n\n1.  **Time Axis:**\n    *   Horizontal line representing the passage of time.\n    *   Clearly marked years/decades at intervals.\n\n2.  **Major Eras (Vertical Blocks):**\n    *   Mainframe Computing (Early years - 1970s): Centralized processing, batch jobs.\n    *   Personal Computing/Client-Server (1980s - 1990s): Decentralized processing, PCs interact with servers.\n    *   Internet/Web-based Computing (1990s - 2000s): Web applications, increased network reliance.\n    *   Cloud Computing (2000s - Present): Virtualized resources, on-demand services.\n    *   Hybrid Computing (Present - Future): Mix of on-premises and cloud resources.\n\n3.  **Key Technologies/Concepts (Within Eras):**\n    *   Mainframe: Batch processing, time-sharing.\n    *   Client-Server: LANs, file servers, database servers.\n    *   Internet: TCP/IP, HTTP, web browsers, e-commerce.\n    *   Cloud: Virtualization, IaaS, PaaS, SaaS, scalability.\n    *   Hybrid: APIs, containerization, orchestration tools (Kubernetes).\n\n4.  **Interactions (Arrows/Lines):**\n    *   Progression: Arrows indicating how one era led to the next (e.g., Client-Server -> Internet).\n    *   Dependencies: Lines showing how technologies are built upon previous ones (e.g., Internet relies on TCP/IP).\n    *   Hybrid Relationships: Arrows showing data/application flow between on-premises and cloud.\n\n5.  **Data/Application Flow:**\n    *   Illustrate how data/applications move between components within each era.\n    *   Simple icons representing data, applications, and users.\n\n6.  **Key Vendors/Companies (Optional):**\n    *   Placement along the timeline to indicate their influence during specific eras (e.g., IBM in mainframe, Microsoft in client-server, Amazon/Google in cloud). Keep this minimal if space is limited.",
        "output": "timeline\n    section Mainframe Computing\n        Early years - 1970s : Centralized Processing\n                      : Batch Jobs\n                      : IBM Influence\n    section Personal Computing / Client-Server\n        1980s - 1990s : Decentralized Processing\n                      : PCs interact with Servers\n                      : LANs\n                      : File Servers\n                      : Database Servers\n                      : Microsoft Influence\n    section Internet / Web-based Computing\n        1990s - 2000s : Web Applications\n                      : Increased Network Reliance\n                      : TCP/IP\n                      : HTTP\n                      : Web Browsers\n                      : E-commerce\n    section Cloud Computing\n        2000s - Present : Virtualized Resources\n                      : On-Demand Services\n                      : IaaS\n                      : PaaS\n                      : SaaS\n                      : Scalability\n                      : Amazon / Google Influence\n    section Hybrid Computing\n        Present - Future : Mix of On-Premises and Cloud\n                      : APIs\n                      : Containerization\n                      : Orchestration Tools  Kubernetes"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Create a timeline diagram showing the evolution of computer hardware, focusing on major advancements like the invention of microprocessors and significant storage technologies.",
        "planning": "**Timeline Components:**\n\n*   **Timeline Axis:** Represents chronological order (years/decades).\n*   **Key Hardware Advancements (Nodes):** Labeled with specific inventions/developments (e.g., Vacuum Tubes, Transistors, Integrated Circuits, Microprocessors, Magnetic Tape, Hard Disk Drives, SSDs).\n*   **Brief Descriptions (Node Annotations):** Short phrases describing each advancement's impact (e.g., \"Smaller, faster,\" \"Increased storage capacity\").\n*   **Categories (Optional):** Group nodes by category (e.g., Processing, Memory, Storage) for visual organization.\n\n**Interactions (Implicit through Timeline Order):**\n\n*   **Chronological Sequence:** Nodes are ordered left-to-right (or top-to-bottom) based on their invention/introduction year, illustrating how one advancement led to the next.\n*   **Implied Influence:** Earlier nodes lay the foundation for later ones (e.g., Transistors enable Integrated Circuits). No explicit interaction arrows are needed; the timeline itself conveys this.",
        "output": "timeline\n    section Processing\n        1947 : Transistors : Smaller faster\n\n        1958 : Integrated Circuits : Miniaturization\n\n        1971 : Microprocessors : Computing power\n\n    section Storage\n        1951 : Magnetic Tape : Data storage\n\n        1956 : Hard Disk Drives : Mass storage\n\n        2000 : SSDs : Faster access times"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Generate a timeline diagram representing the implementation phases of a RAG-based recommendation system deployed in an E-commerce application.",
        "planning": "**Timeline Diagram Components and Interactions:**\n\n1.  **Phase 1: Data Ingestion & Indexing:**\n    *   **E-commerce Data Source:** (Products, descriptions, reviews, metadata) \u2013 *Input to Data Ingestion*\n    *   **Data Ingestion:** (ETL process extracts, transforms, loads data) \u2013 *Outputs Clean Data to Vector Store Indexing*\n    *   **Vector Store Indexing:** (Embeds product data into vectors and indexes them) \u2013 *Creates Vector Index accessible for retrieval*\n    *   **Vector Database:** (Stores vector embeddings and metadata) \u2013 *Provides indexed data storage for semantic search*\n\n2.  **Phase 2: RAG Implementation & Testing:**\n    *   **User Query:** (Customer's search or browsing input) \u2013 *Input to Query Processing*\n    *   **Query Processing:** (Transforms query for vector search) \u2013 *Outputs Processed Query to Vector Search*\n    *   **Vector Search:** (Searches Vector Database for relevant products) \u2013 *Retrieves Relevant Product Vectors to Context Augmentation*\n    *   **Context Augmentation:** (Combines retrieved product information with the user query) \u2013 *Outputs Augmented Prompt to LLM*\n    *   **LLM (Large Language Model):** (Generates recommendation based on augmented context) \u2013 *Generates Recommendation to Recommendation Filtering*\n    *   **Recommendation Filtering:** (Filters and ranks recommendations) \u2013 *Outputs Filtered Recommendations to User Interface*\n\n3.  **Phase 3: Deployment & Monitoring:**\n    *   **User Interface:** (Displays recommendations to the user) \u2013 *Receives Filtered Recommendations*\n    *   **Monitoring System:** (Tracks performance metrics like click-through rate, conversion rate) \u2013 *Monitors all components and data flow*\n    *   **Feedback Loop:** (User interactions (clicks, purchases) provide feedback for model improvement) \u2013 *Sends Data Back to Data Ingestion & Indexing for retraining or Vector Store Indexing for updates*",
        "output": "timeline\n    section Phase 1: Data Ingestion & Indexing\n        Data Source : E-commerce Data Products Descriptions Reviews Metadata\n                  : Data Ingestion ETL Process\n        Vector Store Indexing : Embeds Product Data into Vectors and Indexes\n        Vector Database : Stores Vector Embeddings and Metadata\n    section Phase 2: RAG Implementation & Testing\n        User Query : Customer's Search or Browsing Input\n                  : Query Processing Transforms Query\n        Vector Search : Searches Vector Database\n        Context Augmentation : Combines Product Information with User Query\n        LLM : Generates Recommendation\n        Recommendation Filtering : Filters and Ranks Recommendations\n    section Phase 3: Deployment & Monitoring\n        User Interface : Displays Recommendations\n        Monitoring System : Tracks Performance Metrics\n        Feedback Loop : User Interactions for Model Improvement"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Construct a timeline diagram outlining the phased development of a mobile banking application, detailing stages from requirements analysis through to deployment.",
        "planning": "**Timeline Diagram Plan: Mobile Banking Application Development**\n\n**I. Phases (Timeline Order):**\n\n1.  **Requirements Analysis:**\n    *   *Components:* Stakeholders (customers, bank staff), Business Analysts.\n    *   *Interaction:* Stakeholders provide input, Business Analysts gather and document requirements.\n2.  **Design & Prototyping:**\n    *   *Components:* UX/UI Designers, Architects.\n    *   *Interaction:* Designers create wireframes/mockups based on requirements; Architects design the system architecture. Prototypes are built for testing.\n3.  **Development:**\n    *   *Components:* Mobile Developers (iOS, Android), Backend Developers, Database Administrators.\n    *   *Interaction:* Mobile devs build front-end; backend devs create APIs and server-side logic; DBAs manage database. All code is integrated.\n4.  **Testing:**\n    *   *Components:* QA Testers, Security Testers.\n    *   *Interaction:* QA tests functionality, usability, and performance. Security testers assess vulnerabilities. Bugs are reported back to developers.\n5.  **Deployment:**\n    *   *Components:* DevOps Team, App Stores (Apple App Store, Google Play Store).\n    *   *Interaction:* DevOps deploys the application to production servers and app stores.\n6.  **Maintenance & Updates:**\n    *   *Components:* Support Team, Developers.\n    *   *Interaction:* Support team handles user issues. Developers address bugs, implement new features based on user feedback, and release updates.\n\n**II. Interactions (Cross-Phase):**\n\n*   **Feedback Loops:** Testing provides feedback to Development; User feedback (post-deployment) informs Maintenance & Updates and potentially triggers new Requirements Analysis cycles.\n*   **Dependency:** Each phase relies on the successful completion of the previous phase.\n\n**III. Visual Elements:**\n\n*   *Timeline:* Horizontal axis showing the progression of time/phases.\n*   *Boxes/Swimlanes:* Represent each phase.\n*   *Arrows:* Illustrate the flow of information and dependencies between phases.\n*   *Milestones:* Key deliverables or events (e.g., \"Prototype Complete,\" \"Beta Release\").",
        "output": "timeline\n    section Requirements Analysis\n        Phase 1 : Gather Requirements from Stakeholders\n               : Document Requirements\n    section Design & Prototyping\n        Phase 2 : UX/UI Design\n               : System Architecture Design\n               : Prototype Development\n    section Development\n        Phase 3 : Mobile App Development iOS/Android\n               : Backend API Development\n               : Database Implementation\n               : Code Integration\n    section Testing\n        Phase 4 : Functionality Testing\n               : Usability Testing\n               : Performance Testing\n               : Security Testing\n               : Bug Reporting\n    section Deployment\n        Phase 5 : Deploy to Production Servers\n               : App Store Submission Apple/Google\n    section Maintenance & Updates\n        Phase 6 : User Support\n               : Bug Fixes\n               : Feature Implementation\n               : Release Updates"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Create a timeline diagram depicting the progression of database management systems, from hierarchical models to relational databases and NoSQL systems.",
        "planning": "*   **Timeline Axis:** Represents the passage of time, labeled with key years/eras.\n*   **Hierarchical Model Section:**\n    *   Label: \"Hierarchical Databases\"\n    *   Key Years: Early DB development (e.g., 1960s)\n    *   Characteristics: Tree-like structure, parent-child relationships.\n    *   Representative System (optional): IBM's IMS.\n*   **Network Model Section:**\n    *   Label: \"Network Databases\"\n    *   Key Years: Transitioning after Hierarchical\n    *   Characteristics: More flexible relationships than Hierarchical.\n    *   Representative System (optional): IDS.\n*   **Relational Database Section:**\n    *   Label: \"Relational Databases\"\n    *   Key Years: 1970s onwards\n    *   Characteristics: Tables, rows, columns, SQL.\n    *   Representative System (optional): Oracle, MySQL, PostgreSQL.\n    *   Indicate the rise of SQL as a standard.\n*   **NoSQL Database Section:**\n    *   Label: \"NoSQL Databases\"\n    *   Key Years: Late 2000s onwards\n    *   Characteristics: Variety of data models (key-value, document, graph, column-family), scalability, eventual consistency.\n    *   Representative Systems (optional): MongoDB, Cassandra, Redis.\n*   **Arrows/Connectors:** Indicate the evolution from one model to the next.  Show relational and NoSQL as diverging paths.",
        "output": "timeline\n    section Early Databases\n        1960s : Hierarchical Databases\n              : Tree-like structure\n              : Parent-child relationships\n              : IMS\n\n        1970s : Network Databases\n              : More flexible relationships\n              : IDS\n\n    section Modern Databases\n        1970s onwards : Relational Databases\n                       : Tables rows columns SQL\n                       : SQL Standard\n                       : Oracle MySQL PostgreSQL\n\n        Late 2000s onwards : NoSQL Databases\n                             : Key-value document graph column-family\n                             : Scalability eventual consistency\n                             : MongoDB Cassandra Redis"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Generate a timeline diagram highlighting major milestones in the evolution of video game consoles, from early devices to modern multi-functional gaming systems.",
        "planning": "*   **Timeline Axis:** Represents chronological order from earliest to present.\n\n*   **Console Milestones:**\n    *   **Console Name & Launch Year:** Text labels identifying each significant console.\n    *   **Key Innovation/Feature:** Brief description of what made the console important (e.g., cartridge-based games, online multiplayer, motion controls, HD graphics, SSD storage).\n\n*   **Connecting Lines/Arrows:** Visually link consoles on the timeline.\n\n*   **Generational Groupings (Optional):** Use color-coding or visual separators to distinguish console generations.",
        "output": "timeline\n    section 1970s\n        1972 : Magnavox Odyssey<br>First Home Console\n\n    section 1977-1983<br>Golden Age\n        1977 : Atari VCS<br>Cartridge Based Games\n        1980 : Atari<br>Pac-Man\n\n    section 1983-1990<br>Crash & Revival\n        1985 : Nintendo NES<br>Revived Home Console Market\n        1989 : Nintendo<br>Game Boy<br>Handheld Gaming\n\n    section 1990-2000<br>16-bit & 3D\n        1991 : Super Nintendo<br>Mode 7 Graphics\n        1994 : Sony PlayStation<br>CD-ROM Gaming<br>3D Games\n        1996 : Nintendo 64<br>Analog Control<br>3D Worlds\n\n    section 2000-2010<br>DVD & Online\n        2000 : PlayStation 2<br>DVD Playback\n        2001 : Microsoft Xbox<br>Hard Drive<br>Xbox Live\n        2006 : Nintendo Wii<br>Motion Controls\n\n    section 2010-Present<br>HD & Digital\n        2013 : PlayStation 4 & Xbox One<br>HD Graphics<br>Digital Distribution\n        2017 : Nintendo Switch<br>Hybrid Console\n        2020 : PlayStation 5 & Xbox Series X/S<br>SSD Storage<br>Ray Tracing"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Construct a timeline diagram outlining the steps in establishing a DevOps pipeline for a web-based SaaS platform, from initial setup to full integration.",
        "planning": "**Timeline Diagram Components and Interactions**\n\n1.  **Planning & Setup:**\n    *   **Component:** Project kickoff, requirement gathering, tool selection (e.g., Git, Jenkins, Docker, Kubernetes, monitoring tools).\n    *   **Interaction:** Define scope, choose technologies, establish version control.\n\n2.  **Source Code Management (SCM):**\n    *   **Component:** Git repository (e.g., GitHub, GitLab, Bitbucket).\n    *   **Interaction:** Developers commit code, branching strategy defined.\n\n3.  **Continuous Integration (CI):**\n    *   **Component:** CI server (e.g., Jenkins, CircleCI, GitLab CI), build scripts.\n    *   **Interaction:** Automated builds triggered by code commits, unit testing, code analysis.\n\n4.  **Artifact Repository:**\n    *   **Component:** Artifact repository (e.g., Nexus, Artifactory).\n    *   **Interaction:** Successful builds packaged and stored as artifacts (e.g., Docker images).\n\n5.  **Continuous Delivery (CD):**\n    *   **Component:** CD pipeline stages (e.g., staging, pre-production, production).\n    *   **Interaction:** Artifacts automatically deployed to various environments, automated testing (integration, regression).\n\n6.  **Infrastructure as Code (IaC):**\n    *   **Component:** IaC tools (e.g., Terraform, Ansible, CloudFormation).\n    *   **Interaction:** Infrastructure provisioned and managed through code, ensuring consistency.\n\n7.  **Monitoring & Feedback:**\n    *   **Component:** Monitoring tools (e.g., Prometheus, Grafana, ELK stack), alerting systems.\n    *   **Interaction:** System performance monitored, alerts triggered for issues, feedback loop to development.\n\n8.  **Automation & Testing:**\n    *   **Component:** Automated test scripts (unit, integration, end-to-end, security, performance).\n    *   **Interaction:** Tests run automatically at various stages of the pipeline to ensure quality.\n\n9.  **Security Integration:**\n    *   **Component:** Security scanning tools (e.g., SAST, DAST), vulnerability management.\n    *   **Interaction:** Security checks integrated into the pipeline to identify and remediate vulnerabilities.\n\n10. **Release & Deployment:**\n    *   **Component:** Release management process, deployment scripts.\n    *   **Interaction:** Approved releases deployed to production environment.\n\n11. **Continuous Improvement:**\n    *   **Component:** Pipeline metrics, feedback loops, retrospective meetings.\n    *   **Interaction:** Analyze pipeline performance, identify bottlenecks, and implement improvements.",
        "output": "timeline\n    section Initial Setup\n        Planning : Project Kickoff\n                 : Requirement Gathering\n                 : Tool Selection\n        SCM      : Git Repository Setup\n                 : Branching Strategy\n\n    section Continuous Integration\n        CI Build : Automated Builds Triggered\n                 : Unit Testing\n                 : Code Analysis\n        Artifact : Packaging\n                 : Storing Artifacts\n\n    section Continuous Delivery\n        CD Stages: Staging Deployment\n                 : Pre-Production Deployment\n                 : Production Deployment\n        Automated: Integration Tests\n                 : Regression Tests\n\n    section Infrastructure & Monitoring\n        IaC      : Infrastructure Provisioning\n                 : Infrastructure Management\n        Monitor  : Performance Monitoring\n                 : Alerting Systems\n\n    section Testing & Security\n        Testing  : Automated Test Scripts\n                 : Performance Security\n        Security : Security Scanning\n                 : Vulnerability Management\n\n    section Release & Improvement\n        Release  : Release Process\n                 : Deployment Scripts\n        Improve  : Pipeline Metrics\n                 : Retrospective Meetings"
    },
    {
        "diagram_type": "timeline",
        "prompt": "Create a timeline diagram illustrating the evolution of programming paradigms in computer science, covering procedural, object-oriented, and functional approaches.",
        "planning": "**Components:**\n\n*   **Timeline Axis:** Horizontal line representing time progression.\n*   **Paradigms as Nodes:** \"Procedural,\" \"Object-Oriented,\" \"Functional\" placed along the timeline.\n*   **Start/End Dates (Approximate):**  Year ranges indicating emergence/peak influence of each paradigm.\n*   **Transition Arrows:** Arrows showing influence/overlap between paradigms (e.g., Procedural -> Object-Oriented).\n*   **Key Concepts/Languages:**  Brief labels under each paradigm node (e.g., Procedural: C, Fortran; Object-Oriented: Java, C++; Functional: Haskell, Lisp).\n\n**Interactions:**\n\n*   **Temporal Order:** Nodes are ordered chronologically on the timeline.\n*   **Influence Flow:** Arrows demonstrate how earlier paradigms influenced later ones. Object-Oriented built upon procedural ideas, and functional is gaining popularity as well.\n*   **Overlap:**  Show that paradigms can co-exist and are not mutually exclusive. For example Object-Oriented programming uses some aspects of procedural programming.",
        "output": "timeline\n    section Programming Paradigm Evolution\n        1950 : Procedural : Languages: Fortran C Pascal\n        1980 : Object-Oriented : Languages: Java C++ C#\n              : Influence from Procedural\n        2000 : Functional : Languages: Haskell Lisp Scala\n              : Growing Popularity"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Provide a userJourney diagram illustrating the registration and login process for an e-commerce website.",
        "planning": "**Registration:**\n\n*   **User:** Initiates registration (clicks \"Sign Up\" button).\n*   **Website (Registration Page):** Displays registration form (fields: email, password, etc.).\n*   **User:** Fills out the form and submits.\n*   **Website (Backend):** Validates input. If invalid, returns error message to registration page.\n*   **Website (Backend):** If valid, checks if email already exists.\n*   **Database:** Checks for email existence.\n*   **Website (Backend):** Creates new user account in database.\n*   **Database:** Stores user data.\n*   **Website (Backend):** Sends verification email.\n*   **User:** Receives verification email, clicks verification link.\n*   **Website (Backend):** Verifies email, activates account.\n*   **Website (Frontend):** Redirects user to login page or welcome page.\n\n**Login:**\n\n*   **User:** Navigates to login page.\n*   **Website (Login Page):** Displays login form (email, password).\n*   **User:** Enters credentials and submits.\n*   **Website (Backend):** Validates input.\n*   **Website (Backend):** Authenticates user against database.\n*   **Database:** Checks credentials.\n*   **Website (Backend):** If authentication fails, returns error message to login page.\n*   **Website (Backend):** If authentication succeeds, creates session/token.\n*   **Website (Frontend):** Redirects user to logged-in area (homepage, user dashboard).\n*   **Browser:** Stores session cookie/token.",
        "output": "journey\n    section Registration\n      SignUpClick: 1: User\n      RegFormDisplay: 1: Website\n      FormFillSubmit: 2: User\n      InputValidation: 1: WebsiteBackend\n      EmailCheck: 1: WebsiteBackend\n      DBEmailCheck: 1: Database\n      AccountCreation: 1: WebsiteBackend\n      DBStoreData: 1: Database\n      VerificationEmail: 1: WebsiteBackend\n      VerifyLinkClick: 2: User\n      EmailVerification: 1: WebsiteBackend\n      AccountActivation: 1: WebsiteBackend\n      RedirectToLogin: 1: WebsiteFrontend\n    section Login\n      LoginNav: 1: User\n      LoginFormDisplay: 1: Website\n      CredSubmit: 2: User\n      InputValidationLogin: 1: WebsiteBackend\n      UserAuth: 1: WebsiteBackend\n      DBCredCheck: 1: Database\n      SessionCreate: 1: WebsiteBackend\n      RedirectToHome: 1: WebsiteFrontend\n      StoreSession: 1: Browser"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Create a Mermaid userJourney diagram showing the process of adding items to a shopping cart and completing a purchase in an online store.",
        "planning": "**User:**\n\n*   Starts Journey: Initial interaction with the store.\n*   Browses Products: Navigates and views items.\n*   Adds to Cart: Selects item and adds it to cart.\n*   Views Cart: Checks cart contents.\n*   Proceeds to Checkout: Initiates checkout process.\n*   Enters Shipping Info: Provides delivery address.\n*   Enters Payment Info: Provides payment details.\n*   Confirms Order: Reviews and confirms the purchase.\n\n**System:**\n\n*   Displays Products: Shows available items.\n*   Updates Cart: Modifies cart content.\n*   Shows Cart: Display cart contents.\n*   Presents Checkout: Guides checkout process.\n*   Validates Info: Checks shipping/payment info.\n*   Processes Payment: Executes payment transaction.\n*   Confirms Purchase: Displays order confirmation.\n\n**Interactions:**\n\n*   User browsing triggers system display.\n*   User actions (add/view cart) trigger system updates.\n*   User proceeding to checkout triggers system to present the checkout process.\n*   User providing information triggers system validation.\n*   User confirming order triggers payment processing and confirmation display by system.",
        "output": "journey\n    section Browse Products\n      Browse Products: 5: User\n      Display Products: 3: System\n    section Add to Cart\n      Add Item to Cart: 5: User\n      Update Cart: 3: System\n    section View Cart\n      View Cart: 5: User\n      Show Cart: 3: System\n    section Checkout\n      Proceed to Checkout: 5: User\n      Present Checkout: 3: System\n    section Shipping Information\n      Enter Shipping Info: 5: User\n      Validate Shipping Info: 3: System\n    section Payment Information\n      Enter Payment Info: 5: User\n      Validate Payment Info: 3: System\n    section Confirm Order\n      Confirm Order: 5: User\n      Process Payment: 3: System\n      Confirm Purchase: 2: System"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Generate a userJourney diagram depicting the steps a user takes to reset their password in a banking app.",
        "planning": "*   **User:** Initiates the process. Interacts with the app.\n*   **Banking App (UI):** Presents screens, receives user input, displays messages.\n*   **Authentication Service:** Verifies user identity, generates/validates reset tokens.\n*   **Email Service:** Sends password reset email with a link/code.\n*   **Database:** Stores user information, password reset status.\n\n**Interaction Flow:**\n\n1.  **User** requests password reset in **Banking App (UI)**.\n2.  **Banking App (UI)** prompts for identifier (e.g., email, username).\n3.  **User** enters identifier in **Banking App (UI)**.\n4.  **Banking App (UI)** sends identifier to **Authentication Service**.\n5.  **Authentication Service** verifies identifier against **Database**.\n6.  **Authentication Service** generates reset token and requests **Email Service** to send email.\n7.  **Email Service** sends password reset email to **User**.\n8.  **User** clicks link/enters code in **Banking App (UI)** from email.\n9.  **Banking App (UI)** sends token/code to **Authentication Service**.\n10. **Authentication Service** validates token against **Database**.\n11. **Authentication Service** authorizes **Banking App (UI)** to prompt for new password.\n12. **User** enters new password in **Banking App (UI)**.\n13. **Banking App (UI)** sends new password to **Authentication Service**.\n14. **Authentication Service** updates password in **Database**.\n15. **Banking App (UI)** confirms successful password reset to **User**.",
        "output": "journey\n    section Request Reset\n      User: 1: User\n      Request Reset: 2: Banking App UI\n      Enter Identifier: 3: User\n      Send Identifier: 4: Banking App UI\n    section Verify Identifier\n      Verify ID: 5: Authentication Service\n      Check DB: 6: Authentication Service, Database\n    section Generate and Send Email\n      Generate Token: 7: Authentication Service\n      Request Email: 8: Authentication Service, Email Service\n      Send Email: 9: Email Service, User\n    section Validate Token\n      Click Link: 10: User, Banking App UI\n      Send Token: 11: Banking App UI, Authentication Service\n      Validate Token: 12: Authentication Service, Database\n    section Update Password\n      Authorize Reset: 13: Authentication Service, Banking App UI\n      Enter New Password: 14: User, Banking App UI\n      Update Password: 15: Banking App UI, Authentication Service\n      Update DB: 16: Authentication Service, Database\n    section Confirm Reset\n      Confirm Success: 17: Banking App UI, User"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Design a userJourney diagram for a chat application that includes user sign-up, messaging, and logout steps.",
        "planning": "*   **User:** The starting point and actor in the diagram.\n\n*   **Sign-Up:**\n    *   **Action:** User clicks \"Sign Up\".\n    *   **System:** Displays sign-up form.\n    *   **Action:** User enters details (email, password, etc.).\n    *   **System:** Validates input.\n    *   **System:** Creates account in database (if valid).\n    *   **System:** Sends verification email (optional).\n    *   **Action:** User verifies email (optional).\n    *   **Outcome:** Account created, user logged in (or prompted to log in).\n\n*   **Messaging:**\n    *   **Action:** User selects a contact/chat.\n    *   **System:** Displays chat window with existing messages.\n    *   **Action:** User types message.\n    *   **Action:** User sends message.\n    *   **System:** Sends message to recipient(s).\n    *   **System:** Message displayed in chat for both sender and recipient.\n    *   **Consider:** Real-time updates, read receipts (optional).\n\n*   **Logout:**\n    *   **Action:** User clicks \"Logout\".\n    *   **System:** Terminates user session.\n    *   **Outcome:** User redirected to login/home page.",
        "output": "journey\n    section User\n      Start: 1: User\n    section Sign-Up\n      Click Sign Up: 2: User\n      Display Form: 1: System\n      Enter Details: 3: User\n      Validate Input: 2: System\n      Create Account: 3: System\n      Verify Email: 2: System\n      Account Created: 1: System\n    section Messaging\n      Select Contact: 2: User\n      Display Chat: 2: System\n      Type Message: 3: User\n      Send Message: 2: User\n      Send to Recipient: 3: System\n      Display Message: 2: System\n    section Logout\n      Click Logout: 1: User\n      Terminate Session: 2: System\n      Redirect: 1: System\n    section End\n      End: 1: User"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Illustrate a userJourney diagram for a basic movie streaming application where users browse titles and select films to watch.",
        "planning": "**User:**\n\n*   **Action:** Opens App/Website\n*   **Action:** Browse Movies (Search, Genre, Trending)\n*   **Action:** Selects a Movie\n*   **Action:** Plays Movie\n*   **Action:** Pauses/Resumes/Stops Movie\n*   **Action:** Closes App/Website\n\n**Application:**\n\n*   **System:** Displays Home Screen (movies, categories)\n*   **System:** Returns Search Results\n*   **System:** Displays Movie Details (Synopsis, Cast, Reviews)\n*   **System:** Starts Movie Streaming\n*   **System:** Controls Playback (Pause, Resume, Stop)\n*   **System:** Ends Streaming\n\n**Interactions:**\n\n*   User browse triggers system to display movie titles.\n*   User selection triggers system to show details.\n*   User plays movie triggers streaming to start.\n*   Playback controls send commands to the streaming player.",
        "output": "journey\n    section Start\n      Open App/Website: 5: User\n      Display Home Screen: 3: Application\n    section Browse Movies\n      Browse Movies: 5: User\n      Return Search Results: 3: Application\n    section Select Movie\n      Select a Movie: 5: User\n      Display Movie Details: 3: Application\n    section Play Movie\n      Plays Movie: 5: User\n      Start Movie Streaming: 3: Application\n    section Control Playback\n      Pauses/Resumes/Stops Movie: 5: User\n      Controls Playback: 3: Application\n    section End\n      Closes App/Website: 5: User\n      Ends Streaming: 3: Application"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Draw a userJourney diagram for a food delivery app showing the order placement, tracking, and delivery confirmation process.",
        "planning": "**Components:**\n\n*   **User:** The customer using the app.\n*   **Food Delivery App:** The application interface.\n*   **Restaurant:** Prepares the food order.\n*   **Delivery Driver:** Picks up and delivers the order.\n*   **Server/Database:** Backend system managing order and app data.\n\n**Interactions:**\n\n1.  **Order Placement:**\n    *   User browses menu in App.\n    *   User adds items to cart in App.\n    *   User proceeds to checkout in App.\n    *   User enters delivery address & payment details in App.\n    *   User confirms order in App.\n    *   App sends order details to Server/Database.\n    *   Server/Database notifies Restaurant.\n\n2.  **Tracking:**\n    *   Restaurant confirms order with Server/Database.\n    *   Server/Database updates order status in App.\n    *   App displays \"Order Confirmed\" to User.\n    *   Restaurant prepares food.\n    *   Delivery Driver is assigned via Server/Database.\n    *   Server/Database updates delivery driver location.\n    *   App displays driver location & estimated arrival time to User.\n\n3.  **Delivery Confirmation:**\n    *   Delivery Driver picks up order from Restaurant.\n    *   Delivery Driver delivers order to User.\n    *   Delivery Driver marks order as delivered in App.\n    *   Server/Database updates order status.\n    *   App notifies User of delivery completion.\n    *   User confirms delivery in App (optional).\n    *   User rates & reviews order/driver in App (optional).",
        "output": "journey\n    section Order Placement\n      Browse Menu: 2: User, Food Delivery App\n      Add Items to Cart: 3: User, Food Delivery App\n      Checkout: 2: User, Food Delivery App\n      Enter Address & Payment: 3: User, Food Delivery App\n      Confirm Order: 2: User, Food Delivery App\n      Send Order to Server: 3: Food Delivery App, ServerDatabase\n      Notify Restaurant: 4: ServerDatabase, Restaurant\n    section Tracking\n      Confirm Order: 3: Restaurant, ServerDatabase\n      Update Order Status: 2: ServerDatabase, Food Delivery App\n      Order Confirmed Display: 3: Food Delivery App, User\n      Prepare Food: 5: Restaurant\n      Assign Driver: 4: ServerDatabase, Delivery Driver\n      Update Driver Location: 3: ServerDatabase, Food Delivery App\n      Display Driver Location: 3: Food Delivery App, User\n    section Delivery Confirmation\n      Pickup Order: 4: Delivery Driver, Restaurant\n      Deliver Order: 5: Delivery Driver, User\n      Mark Order Delivered: 3: Delivery Driver, Food Delivery App\n      Update Order Status Server: 2: ServerDatabase, Food Delivery App\n      Notify Delivery Completion: 3: Food Delivery App, User\n      Confirm Delivery Option: 2: User, Food Delivery App\n      Rate Review Option: 2: User, Food Delivery App"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Develop a userJourney diagram outlining the process of booking a flight in a travel booking application.",
        "planning": "**User Journey Diagram Components and Interactions:**\n\n*   **User:** The individual booking the flight.\n*   **Travel Booking Application (App/Website):** The platform used for booking.\n\n**Key Stages & Interactions:**\n\n1.  **Start (User Goal: Book a flight):**\n\n    *   User opens the app/website.\n    *   User Input: Enters desired destination, dates, and number of passengers.\n2.  **Search Flights:**\n\n    *   App interacts with backend (API/Database) to retrieve flight options.\n    *   App displays available flights with details (price, airlines, layovers).\n3.  **Select Flight:**\n\n    *   User selects a suitable outbound and return flight.\n    *   User Input: Clicks on a desired flight option.\n4.  **Review & Customize:**\n\n    *   App displays flight details summary.\n    *   User adds extras (baggage, seat selection). User Input: Add desired options\n5.  **Passenger Details:**\n\n    *   User Input: Enters passenger information (names, dates of birth).\n6.  **Payment:**\n\n    *   App displays payment options.\n    *   User selects payment method and enters payment details. User Input: Selects and enters payment.\n    *   App interacts with payment gateway.\n7.  **Confirmation:**\n\n    *   App generates and displays booking confirmation.\n    *   App sends confirmation email.\n8.  **End (User Goal Achieved: Flight booked):**\n\n**Interactions:**\n\n*   **User - App:** Primarily input (search criteria, selections, personal information) and output (display of information, confirmation).\n*   **App - Backend (API/Database):** Data retrieval (flight information), data storage (booking details).\n*   **App - Payment Gateway:** Payment processing.\n*   **App - Email Service:** Sending confirmation emails.",
        "output": "```mermaid\njourney\n    section Start\n      Open App/Website: 2: User\n      Enter Destination Dates Passengers: 3: User\n    section Search Flights\n      Retrieve Flight Options: 4: App\n      Display Available Flights: 5: App\n    section Select Flight\n      Choose Outbound Flight: 3: User\n      Choose Return Flight: 3: User\n    section Review and Customize\n      Display Flight Details Summary: 4: App\n      Add Extras Baggage Seats: 3: User\n    section Passenger Details\n      Enter Passenger Information: 5: User\n    section Payment\n      Select Payment Method: 3: User\n      Enter Payment Details: 5: User\n      Process Payment: 4: App\n    section Confirmation\n      Generate Booking Confirmation: 4: App\n      Display Confirmation: 3: App\n      Send Confirmation Email: 3: App\n    section End\n      Flight Booked: 1: User\n```"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Sketch a userJourney diagram for a social media application demonstrating account creation, posting updates, and interacting with friends.",
        "planning": "**User Journey Diagram Components & Interactions Plan:**\n\n**1. Account Creation:**\n\n*   **User:** Enters app, clicks \"Sign Up\".\n*   **App:** Presents signup form (email, password, username).\n*   **User:** Fills form, submits.\n*   **App:** Validates data, creates account, may send verification email.\n*   **User:** (Optional) Verifies email.\n*   **App:** User logged in, directed to profile setup/feed.\n\n**2. Posting Updates:**\n\n*   **User:** Clicks \"New Post\" button.\n*   **App:** Presents text input field, media upload options.\n*   **User:** Writes update, adds media (optional), clicks \"Post\".\n*   **App:** Saves post to database, displays post in user's profile and friend's feeds.\n\n**3. Interacting with Friends:**\n\n*   **User:** Views feed, sees friend's post.\n*   **User:** Clicks \"Like\" button.\n*   **App:** Updates like count on post.\n*   **User:** Clicks \"Comment\" button.\n*   **App:** Presents comment input field.\n*   **User:** Writes comment, submits.\n*   **App:** Saves comment to database, displays comment below post.\n*   **User:** Clicks on friend's profile.\n*   **App:** Displays friend's profile and posts.",
        "output": "journey\n    section Account Creation\n      Enter App: 2: User\n      Click Sign Up: 3: User\n      Signup Form: 5: App\n      Fill Form: 4: User\n      Submit Form: 3: User\n      Validate Data: 5: App\n      Create Account: 5: App\n      Verify Email: 3: User\n      Login: 4: App\n      Profile Setup: 3: App\n    section Posting Updates\n      New Post Button: 2: User\n      Text Input Field: 4: App\n      Write Update: 5: User\n      Add Media: 3: User\n      Post Update: 4: User\n      Save Post: 5: App\n      Display Post: 5: App\n    section Interacting with Friends\n      View Feed: 3: User\n      See Friend Post: 3: User\n      Like Button: 2: User\n      Update Like Count: 5: App\n      Comment Button: 2: User\n      Comment Input: 4: App\n      Write Comment: 5: User\n      Submit Comment: 3: User\n      Save Comment: 5: App\n      Display Comment: 5: App\n      View Friend Profile: 3: User\n      Display Profile: 5: App"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Show a userJourney diagram for a task management application where a user creates, updates, and completes tasks.",
        "planning": "*   **User:** The actor initiating the actions.\n*   **Task Management Application (System):** The application itself, handling the logic.\n*   **Journey Stages:**\n    *   **Creating a Task:**\n        *   User navigates to task creation.\n        *   User enters task details (title, description, due date, etc.)\n        *   User saves the task.\n        *   System confirms task creation.\n    *   **Updating a Task:**\n        *   User selects a task.\n        *   User edits task details.\n        *   User saves the changes.\n        *   System confirms task update.\n    *   **Completing a Task:**\n        *   User selects a task.\n        *   User marks the task as complete.\n        *   System updates task status to complete.\n*   **Interactions:** User actions trigger system responses, confirming actions.\n*   **Swimlanes (Optional):** Can be used for User and System to visually separate responsibilities.",
        "output": "journey\n    section Create Task\n      Navigate to creation page: 5: User\n      Enter task details: 3: User\n      Save task: 5: User\n      Confirm task creation: 3: System\n    section Update Task\n      Select task: 5: User\n      Edit task details: 3: User\n      Save changes: 5: User\n      Confirm task update: 3: System\n    section Complete Task\n      Select task to complete: 5: User\n      Mark task as complete: 5: User\n      Update task status: 3: System"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Generate a userJourney diagram for a healthcare appointment booking app detailing appointment scheduling and confirmation steps.",
        "planning": "**User:**\n\n*   **Starts Journey:** Initiates booking process within the app.\n*   **Selects Service:** Chooses appointment type (e.g., consultation, check-up).\n*   **Chooses Provider/Location:** Selects doctor or clinic location.\n*   **Selects Date/Time:** Chooses desired date and time slot.\n*   **Confirms Appointment:** Reviews details and confirms booking.\n*   **Receives Confirmation:** Receives confirmation message/email.\n*   **Views Appointment Details:** Accesses appointment information within the app.\n\n**App:**\n\n*   **Presents Service Options:** Displays available appointment types.\n*   **Displays Provider/Location Options:** Shows available doctors/clinics.\n*   **Displays Available Time Slots:** Presents calendar with available times.\n*   **Collects User Details:** (Optional) Gathers necessary patient information.\n*   **Confirms Availability:** Verifies chosen time slot is still available.\n*   **Schedules Appointment:** Books the appointment in the system.\n*   **Generates Confirmation:** Creates appointment confirmation details.\n*   **Sends Confirmation:** Sends confirmation message/email to user.\n*   **Updates Appointment List:** Adds appointment to user's appointment list.\n\n**System (Backend):**\n\n*   **Maintains Availability:** Stores available appointment slots.\n*   **Validates User:** Authenticates user if required.\n*   **Updates Appointment Records:** Saves appointment details.\n*   **Triggers Notifications:** Sends alerts for confirmations.\n\n**Interactions:**\n\n*   User interacts with App to select options and confirm booking.\n*   App communicates with System to check availability and schedule appointments.\n*   System sends confirmation to App.\n*   App displays confirmation and updates appointment list.",
        "output": "journey\n    section Start\n      User opens app: 1: User\n      App loads: 1: App\n    section Service Selection\n      User selects service: 3: User\n      App displays options: 3: App\n    section Provider Selection\n      User selects provider: 3: User\n      App shows providers: 3: App\n    section Date and Time\n      User picks date/time: 5: User\n      App shows availability: 5: App\n      App requests confirmation: 2: App, System\n      System checks availability: 2: System\n    section Confirmation\n      User confirms booking: 3: User\n      App sends request to system: 3: App, System\n    section Booking\n      System books appointment: 5: System\n    section Confirmation Display\n      System generates confirmation: 3: System\n      App receives confirmation: 3: App\n      App displays confirmation: 3: App\n      App updates appointment list: 3: App\n    section Notification\n      System sends notification: 2: System\n      User receives confirmation: 2: User"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Construct a userJourney diagram for an online learning platform where users enroll in courses and track their progress.",
        "planning": "*   **User:** Represents the learner.\n\n*   **Online Learning Platform (System):** The main entity.\n\n*   **Entry Point/Trigger:**\n    *   Visit Website/App: User lands on the platform.\n\n*   **Key Stages/Steps:**\n    *   **Browse Courses:** User explores available courses. (User -> Platform)\n    *   **Search Courses:** User searches for specific courses. (User -> Platform)\n    *   **View Course Details:** User sees course description, syllabus, etc. (Platform -> User)\n    *   **Enroll in Course:** User signs up for a course. (User -> Platform)\n    *   **Payment (Optional):** User pays for the course (if applicable). (User -> Platform)\n    *   **Access Course Content:** User starts learning. (User -> Platform)\n    *   **View Lessons/Modules:** User navigates through course material. (Platform -> User)\n    *   **Complete Lessons/Modules:** User marks lessons as finished. (User -> Platform)\n    *   **Take Quizzes/Assessments:** User tests their knowledge. (User -> Platform, Platform -> User feedback/score)\n    *   **Track Progress:** User views their course completion status. (Platform -> User)\n    *   **Participate in Forums/Discussions:** User interacts with other learners/instructors. (User <-> Platform)\n    *   **Earn Certificate (Optional):** User receives a certificate upon completion. (Platform -> User)\n\n*   **Touchpoints:**\n    *   Website/App interface.\n    *   Email notifications (enrollment confirmation, reminders).\n\n*   **Outcomes:**\n    *   Course Enrollment\n    *   Course Completion\n    *   Knowledge Gain\n    *   Certificate Awarded (Optional)",
        "output": "journey\n    section Access Platform\n      Visit Website: 5: User\n    section Course Discovery\n      Browse Courses: 4: User, Platform\n      Search Courses: 3: User, Platform\n      View Course Details: 5: Platform\n    section Enrollment\n      Enroll in Course: 5: User, Platform\n      Payment: 3: User, Platform\n    section Learning\n      Access Course Content: 5: User, Platform\n      View Lessons: 5: Platform\n      Complete Lessons: 4: User, Platform\n      Take Quizzes: 4: User, Platform\n    section Progress\n      Track Progress: 5: Platform\n    section Interaction\n      Participate in Forums: 3: User, Platform\n    section Completion\n      Earn Certificate: 5: Platform"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Formulate a userJourney diagram for a music streaming app covering the signup process, playlist creation, and music playback.",
        "planning": "**User:**\n\n*   **Actions:** Opens App, Clicks \"Sign Up\", Enters Information, Clicks \"Create Account\", Clicks \"Create Playlist\", Names Playlist, Adds Songs, Clicks \"Play\" on Song/Playlist, Adjusts Volume, Pauses/Skips.\n\n**App (System):**\n\n*   **States/Pages:** Sign Up Screen, Home Screen, Playlist Creation Screen, Now Playing Screen.\n*   **Processes:** Verifies Information, Creates Account, Creates Playlist, Saves Playlist, Streams Music.\n*   **Database (Implied):** User Account, Playlist Data, Music Library.\n\n**Interactions:**\n\n*   User Input -> App (Forms, Buttons).\n*   App -> User Feedback (Error Messages, Success Notifications, Loading Indicators, Audio Playback).\n*   App -> Database (Saving User Data, Retrieving Music).",
        "output": "journey\n    section Sign Up\n      Open App: 2: User\n      Sign Up Screen Displayed: 3: App\n      Click Sign Up: 2: User\n      Enter Information: 4: User\n      Verify Information: 3: App\n      Create Account: 3: App\n      Account Created Notification: 2: App\n\n    section Playlist Creation\n      Home Screen Displayed: 2: App\n      Click Create Playlist: 2: User\n      Playlist Creation Screen: 3: App\n      Name Playlist: 3: User\n      Add Songs: 5: User\n      Save Playlist: 3: App\n      Playlist Saved Notification: 2: App\n\n    section Music Playback\n      Click Play on SongPlaylist: 2: User\n      Stream Music: 5: App\n      Now Playing Screen Displayed: 3: App\n      Adjust Volume: 2: User\n      PauseSkip: 2: User"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Outline a userJourney diagram for a job application portal, from profile creation to submitting a job application.",
        "planning": "**User:**\n\n*   **Action:** Profile Creation\n    *   **Interaction:** Enters personal details, work experience, education, skills.\n    *   **Outcome:** Account creation, profile saved.\n*   **Action:** Job Search\n    *   **Interaction:** Uses search filters (keywords, location, industry).\n    *   **Outcome:** List of relevant job postings.\n*   **Action:** Job Posting View\n    *   **Interaction:** Reviews job description, requirements, company information.\n    *   **Outcome:** Decision to apply or not.\n*   **Action:** Application Start\n    *   **Interaction:** Clicks \"Apply Now\".\n    *   **Outcome:** Application form displayed.\n*   **Action:** Application Completion\n    *   **Interaction:** Fills in form fields, uploads resume/cover letter, answers questions.\n    *   **Outcome:** Application preview available.\n*   **Action:** Application Submission\n    *   **Interaction:** Clicks \"Submit Application\".\n    *   **Outcome:** Application confirmation, notification.\n\n**System (Portal):**\n\n*   **Component:** Database\n    *   **Interaction:** Stores user profiles, job postings, applications.\n*   **Component:** Search Engine\n    *   **Interaction:** Retrieves job postings based on user search criteria.\n*   **Component:** Application Form\n    *   **Interaction:** Presents form to user, collects application data.\n*   **Component:** Notification System\n    *   **Interaction:** Sends confirmation emails/messages to user.\n*   **Component:** Backend System\n    *   **Interaction:** Processes and stores submitted applications, notifies recruiters.\n\n**Interactions:**\n\n*   User interacts with the system to input data, search for jobs, and submit applications.\n*   The system processes user input, retrieves data from the database, and provides feedback to the user.",
        "output": "journey\n    section Profile Creation\n      Enter Details: 5: User\n      Save Profile: 3: User\n\n    section Job Search\n      Use Filters: 5: User\n      View Job List: 3: User\n\n    section Job Posting View\n      Review Details: 5: User\n      Decide Apply: 3: User\n\n    section Application Start\n      Click Apply: 5: User\n      Form Displayed: 3: System\n\n    section Application Completion\n      Fill Form: 5: User\n      Upload Docs: 4: User\n      Preview App: 2: User\n\n    section Application Submission\n      Submit App: 5: User\n      Confirmation: 3: System"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Produce a userJourney diagram for a customer support chat system, detailing the steps from inquiry initiation to resolution.",
        "planning": "**Components:**\n\n*   **Customer:** Initiates the journey.\n*   **Chatbot/Virtual Agent:** Initial point of contact, automated responses.\n*   **Knowledge Base:** Database of articles, FAQs, and solutions.\n*   **Human Agent:** Handles complex issues beyond chatbot capabilities.\n*   **Ticketing System:** Manages and tracks unresolved issues.\n*   **Resolution Confirmation:** Final step, confirms issue is resolved.\n\n**Interactions:**\n\n1.  **Customer -> Chatbot:** Customer starts chat with inquiry.\n2.  **Chatbot -> Knowledge Base:** Chatbot searches for relevant articles.\n3.  **Chatbot -> Customer:** Chatbot provides automated responses/suggests solutions.\n4.  **Customer -> Chatbot:** Customer indicates if solution is insufficient.\n5.  **Chatbot -> Human Agent:** Chatbot transfers customer to a human agent if needed.\n6.  **Human Agent -> Customer:** Human agent communicates with customer to understand issue.\n7.  **Human Agent <-> Knowledge Base:** Agent accesses knowledge base for solutions.\n8.  **Human Agent -> Ticketing System:** Agent creates a ticket if issue needs further investigation.\n9.  **Ticketing System -> Human Agent:** Ticket is resolved through background activity.\n10. **Human Agent -> Customer:** Human agent provides solution and confirms resolution.\n11. **Customer -> Resolution Confirmation:** Customer confirms issue is resolved.",
        "output": "journey\n    section Inquiry Initiation\n      Customer Starts Chat: 5: Customer\n    section Automated Response\n      Chatbot Searches KB: 3: Chatbot\n      Provides Initial Solutions: 4: Chatbot\n    section Insufficient Solution\n      Customer Indicates Issue: 5: Customer\n    section Transfer to Human Agent\n      Transferring to Agent: 2: Chatbot\n    section Human Agent Interaction\n      Agent Communicates: 5: HumanAgent\n      Agent Accesses KB: 3: HumanAgent\n    section Ticketing System\n      Creates Ticket if Needed: 4: HumanAgent\n      Ticket Resolution Bkgd: 3: TicketingSystem\n    section Resolution Confirmation\n      Provides Solution: 5: HumanAgent\n      Confirms Resolution: 4: Customer\n    section End\n      Issue Resolved: 1: Customer"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Compile a userJourney diagram for a ride-sharing application showing ride booking, driver assignment, and ride completion steps.",
        "planning": "**User (Passenger)**\n\n*   **Action:** Opens App, Enters Destination, Requests Ride.\n*   **Interaction:** Interacts with the app interface.\n*   **Consideration:** Choosing Ride type.\n\n**System (Ride-Sharing App)**\n\n*   **Action:** Receives Ride Request, Calculates Fare, Finds Available Drivers.\n*   **Interaction:** Processes data, communicates with driver database.\n*   **Consideration:** Surge pricing, driver proximity.\n\n**Driver**\n\n*   **Action:** Receives Ride Request, Accepts/Declines Request, Navigates to Passenger, Starts Ride.\n*   **Interaction:** Interacts with app interface, communicates with passenger (optional).\n*   **Consideration:** Distance to passenger, potential earnings.\n\n**User (Passenger) - During Ride**\n\n*   **Action:** Monitors Ride Progress, Communicates with Driver (optional).\n*   **Interaction:** Interacts with app for status.\n*   **Consideration:** ETA, route.\n\n**Driver - During Ride**\n\n*   **Action:** Drives Passenger to Destination, Completes Ride.\n*   **Interaction:** Uses app for navigation, ride completion.\n*   **Consideration:** Traffic, route changes.\n\n**System (Ride-Sharing App) - After Ride**\n\n*   **Action:** Processes Payment, Prompts for Ratings/Reviews.\n*   **Interaction:** Handles financial transactions, stores feedback.\n*   **Consideration:** Payment failure.\n\n**User (Passenger) - After Ride**\n\n*   **Action:** Pays Fare, Rates/Reviews Driver.\n*   **Interaction:** Interacts with app for payment and feedback.\n*   **Consideration:** Tipping.",
        "output": "journey\n    section Ride Booking\n      Open App: 3: Passenger\n      Enter Destination: 3: Passenger\n      Request Ride: 5: Passenger\n\n    section Driver Assignment\n      Receive Ride Request: 5: System\n      Calculate Fare: 3: System\n      Find Available Drivers: 5: System\n      Accept/Decline Request: 5: Driver\n\n    section Navigation and Ride\n      Navigate to Passenger: 5: Driver\n      Start Ride: 3: Driver\n      Monitor Ride Progress: 5: Passenger\n      Drive to Destination: 5: Driver\n\n    section Ride Completion\n      Complete Ride: 5: Driver\n      Process Payment: 5: System\n      Prompt for Ratings: 3: System\n      Pay Fare: 5: Passenger\n      Rate Driver: 3: Passenger"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Draft a userJourney diagram for a cloud storage service where the process involves file uploading, organization, and sharing.",
        "planning": "**Components:**\n\n*   **User:** The actor initiating actions.\n*   **Application (Cloud Storage App/Web):** Interface for interaction.\n*   **Cloud Storage Service:** Backend handling storage and processing.\n\n**User Journey Steps & Interactions:**\n\n1.  **Upload File:**\n    *   User -> Application: Selects file(s) to upload.\n    *   Application -> Cloud Storage Service: Initiates upload request with file data.\n    *   Cloud Storage Service: Receives, processes, and stores the file.\n    *   Cloud Storage Service -> Application: Confirmation of successful upload.\n    *   Application -> User: Displays upload success notification.\n\n2.  **Organize File(s):**\n    *   User -> Application: Creates folder, moves file(s) to folder.\n    *   Application -> Cloud Storage Service: Sends request to create folder/move files.\n    *   Cloud Storage Service: Updates file metadata and directory structure.\n    *   Cloud Storage Service -> Application: Confirmation of organization changes.\n    *   Application -> User: Reflects the new file organization.\n\n3.  **Share File(s):**\n    *   User -> Application: Selects file(s)/folder(s) to share and chooses sharing option (e.g., generate link, invite user).\n    *   Application -> Cloud Storage Service: Sends request to create a shareable link/grant access.\n    *   Cloud Storage Service: Generates link/updates permissions.\n    *   Cloud Storage Service -> Application: Returns generated link/confirmation of access granted.\n    *   Application -> User: Displays the shareable link/confirms user invitation.",
        "output": "journey\n    section Upload File\n      U[User] -> A[Application]: Selects file to upload\n      A -> C[Cloud Storage]: Initiates upload request\n      C: Processes and stores file\n      C --> A: Upload confirmation\n      A --> U: Displays upload success\n    section Organize Files\n      U -> A: Creates folder moves files\n      A -> C: Sends request to create folder/move files\n      C: Updates metadata and directory\n      C --> A: Organization confirmation\n      A --> U: Reflects file organization\n    section Share Files\n      U -> A: Selects files/folders and chooses sharing option\n      A -> C: Sends request to create a shareable link/grant access\n      C: Generates link/updates permissions\n      C --> A: Returns link/confirmation\n      A --> U: Displays the shareable link/confirms user invitation"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Illustrate a userJourney diagram for a calendar scheduling app where a user creates an event, receives a confirmation, and sets reminders.",
        "planning": "*   **User:** Initiates and interacts with the app.\n*   **Calendar Scheduling App (Frontend):** User interface for input and display.\n*   **Calendar Scheduling App (Backend/Server):** Processes data, interacts with database/calendar service.\n*   **Database/Calendar Service:** Stores event data (e.g., Google Calendar, internal database).\n*   **Notification Service:** Sends reminders/confirmations.\n\n**Interactions:**\n\n1.  **User -> Frontend:** User inputs event details (title, date, time, attendees).\n2.  **Frontend -> Backend:** Sends event data to the backend.\n3.  **Backend -> Database/Calendar Service:** Saves event data.\n4.  **Backend -> Frontend:** Confirmation message to the frontend.\n5.  **Frontend -> User:** Displays confirmation.\n6.  **Backend -> Notification Service:** Schedules reminders based on event data.\n7.  **Notification Service -> User:** Sends reminders at scheduled times.",
        "output": "journey\n    section Create Event\n      User Input Event Details: 5: User\n      Send Event Data to Backend: 3: Frontend\n    section Process Event\n      Save Event Data: 5: Backend\n      Send Confirmation to Frontend: 3: Backend\n    section Confirm Event\n      Display Confirmation: 5: Frontend\n      User Receives Confirmation: 3: User\n    section Set Reminders\n      Schedule Reminders: 5: Backend\n    section Send Reminders\n      Send Reminder Notification: 5: Notification Service\n      User Receives Reminder: 3: User"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Depict a userJourney diagram for a mobile banking app detailing steps for balance checking, fund transfers, and reviewing transaction history.",
        "planning": "**Components:**\n\n*   **User:** The person using the app.\n*   **Mobile Banking App:** The application interface.\n*   **Authentication System:** Handles login and security.\n*   **Account Management System:** Stores and retrieves account information.\n*   **Transaction Processing System:** Handles fund transfers.\n*   **Transaction History Database:** Stores past transactions.\n\n**Interactions:**\n\n1.  **Balance Checking:**\n    *   User interacts with App (e.g., taps \"Check Balance\").\n    *   App sends request to Authentication System.\n    *   Authentication System verifies user credentials.\n    *   App requests account balance from Account Management System.\n    *   Account Management System retrieves balance.\n    *   App displays balance to User.\n\n2.  **Fund Transfers:**\n    *   User interacts with App (enters recipient details, amount).\n    *   App sends transfer request to Authentication System.\n    *   Authentication System verifies user credentials.\n    *   App sends transaction request to Transaction Processing System.\n    *   Transaction Processing System processes transfer, updating accounts.\n    *   App confirms transfer to User.\n\n3.  **Reviewing Transaction History:**\n    *   User interacts with App (e.g., taps \"Transaction History\").\n    *   App sends request to Authentication System.\n    *   Authentication System verifies user credentials.\n    *   App requests transaction history from Transaction History Database.\n    *   Transaction History Database provides data.\n    *   App displays transaction history to User.",
        "output": "journey\n    section Balance Checking\n      Tap Check Balance: 5: User\n      Request Authentication: 3: Mobile Banking App\n      Verify Credentials: 4: Authentication System\n      Request Balance: 3: Mobile Banking App\n      Retrieve Balance: 4: Account Management System\n      Display Balance: 5: Mobile Banking App\n\n    section Fund Transfers\n      Enter Transfer Details: 5: User\n      Request Authentication for Transfer: 3: Mobile Banking App\n      Verify Credentials for Transfer: 4: Authentication System\n      Process Transfer: 4: Transaction Processing System\n      Confirm Transfer: 5: Mobile Banking App\n\n    section Review Transaction History\n      Tap Transaction History: 5: User\n      Request Authentication for History: 3: Mobile Banking App\n      Verify Credentials for History: 4: Authentication System\n      Retrieve Transaction History: 4: Transaction History Database\n      Display Transaction History: 5: Mobile Banking App"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Render a userJourney diagram for a fitness tracking application showing user sign-up, activity tracking, and feedback on goal achievements.",
        "planning": "**1. Swimlanes:**\n\n*   **User:** The user taking actions.\n*   **Fitness Tracking App:** The application processing requests and displaying information.\n*   **Database:** Stores user data, activity data, and goals.\n\n**2. Sign-Up Flow:**\n\n*   **User:** Opens App.\n*   **Fitness Tracking App:** Presents Sign-Up Screen.\n*   **User:** Enters Details (email, password, etc.).\n*   **Fitness Tracking App:** Validates Input.\n*   **Fitness Tracking App:** Sends data to Database.\n*   **Database:** Stores User Profile.\n*   **Fitness Tracking App:** Confirms Registration, Login.\n\n**3. Activity Tracking Flow:**\n\n*   **User:** Starts Activity (e.g., run, workout).\n*   **Fitness Tracking App:** Records Activity Data (time, distance, heart rate).\n*   **Fitness Tracking App:** Stores data to Database.\n*   **Database:** Saves Activity Data.\n*   **Fitness Tracking App:** Displays Real-time Activity Stats.\n*   **User:** Ends Activity.\n\n**4. Goal Achievement Feedback Flow:**\n\n*   **Fitness Tracking App:** Retrieves Activity Data from Database.\n*   **Fitness Tracking App:** Compares Activity Data with User's Goals.\n*   **Fitness Tracking App:** Determines Goal Achievement Status.\n*   **Fitness Tracking App:** Displays Feedback (Success/Progress).\n*   **User:** Views Feedback.",
        "output": "journey\n    section Sign-Up\n      Open App: 2: User\n      Sign-Up Screen: 3: Fitness Tracking App\n      Enter Details: 4: User\n      Validate Input: 3: Fitness Tracking App\n      Send Data to DB: 3: Fitness Tracking App\n      Store User Profile: 4: Database\n      Confirm Registration: 3: Fitness Tracking App\n      Login: 2: Fitness Tracking App\n    section Activity Tracking\n      Start Activity: 3: User\n      Record Activity Data: 4: Fitness Tracking App\n      Store Data to DB: 3: Fitness Tracking App\n      Save Activity Data: 4: Database\n      Display Real-time Stats: 3: Fitness Tracking App\n      End Activity: 2: User\n    section Goal Achievement Feedback\n      Retrieve Activity Data: 3: Fitness Tracking App\n      Compare to Goals: 4: Fitness Tracking App\n      Determine Goal Status: 4: Fitness Tracking App\n      Display Feedback: 3: Fitness Tracking App\n      View Feedback: 2: User"
    },
    {
        "diagram_type": "userJourney",
        "prompt": "Show a userJourney diagram for a forum website where the steps include user registration, topic posting, and replying to comments.",
        "planning": "*   **User:** The starting point and actor initiating all actions.\n*   **Forum Website:** The system/platform responding to user actions.\n*   **Registration Process:**\n    *   User navigates to registration page.\n    *   User fills in registration form.\n    *   Forum website validates the information.\n    *   Forum website creates user account.\n    *   User receives confirmation/login.\n*   **Topic Posting:**\n    *   User logs in.\n    *   User navigates to forum section.\n    *   User creates new topic (title, content).\n    *   Forum website saves the topic.\n    *   Topic is displayed in the forum.\n*   **Replying to Comments:**\n    *   User views a topic.\n    *   User enters reply text.\n    *   Forum website saves the reply.\n    *   Reply is displayed under the comment/topic.",
        "output": "journey\n    section Registration\n      Navigate to Registration: 5: User\n      Fill Registration Form: 3: User\n      Validate Information: 4: Forum Website\n      Create User Account: 5: Forum Website\n      Confirmation Login: 3: Forum Website\n    section Topic Posting\n      User Logs In: 5: User\n      Navigate to Forum: 4: User\n      Create New Topic: 5: User\n      Save Topic: 5: Forum Website\n      Display Topic: 3: Forum Website\n    section Replying\n      View Topic: 5: User\n      Enter Reply Text: 4: User\n      Save Reply: 5: Forum Website\n      Display Reply: 3: Forum Website"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram to compare the time complexity of bubble sort, merge sort, and quicksort as the input size increases.",
        "planning": "*   **Chart Type:** xyChart (Scatter plot or Line Chart).\n*   **X-axis:** Input Size (n). Represents the number of elements to be sorted.\n*   **Y-axis:** Time Complexity (Number of Operations or Execution Time).\n*   **Data Series 1:** Bubble Sort. Plots the time complexity of bubble sort as 'n' increases (n^2).\n*   **Data Series 2:** Merge Sort. Plots the time complexity of merge sort as 'n' increases (n log n).\n*   **Data Series 3:** Quicksort. Plots the average-case time complexity of quicksort as 'n' increases (n log n). It could also optionally include the worst-case (n^2).\n*   **Legend:** Identifies each data series (Bubble Sort, Merge Sort, Quicksort).\n*   **Interaction:** As 'n' (X-axis) increases, the Y-axis values for each sorting algorithm will show their respective complexity growth. Bubble sort's curve will rise steeply, while Merge Sort and Quicksort (on average) will rise more gradually. The worst-case Quicksort line would show a steep climb similar to Bubble Sort.",
        "output": "xychart-beta\n    x-axis [10 20 30 40 50]\n    y-axis \"Time Complexity\" 0 --> 2500\n    line [100 400 900 1600 2500]\n    line [33 66 99 132 165]\n    line [33 66 99 132 165]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram showing network latency versus packet loss percentage in a TCP connection.",
        "planning": "*   **Chart Title:** \"TCP Connection: Network Latency vs. Packet Loss\"\n*   **X-Axis:** \"Packet Loss (%)\" (Range: 0-100)\n*   **Y-Axis:** \"Network Latency (ms)\" (Range: dynamically adjust to data)\n*   **Data Series:**\n    *   A series representing the relationship between packet loss and latency.\n    *   Each data point is an (x, y) coordinate: (Packet Loss Percentage, Network Latency in ms).\n*   **Data Points:** Display several data points representing different packet loss percentages and corresponding latency. The data should demonstrate a general trend (e.g., increasing latency with increasing packet loss).\n*   **Trend Line (Optional):** A line of best fit visually indicating the correlation (positive in this case) between packet loss and latency.\n*   **Labels/Annotations (Optional):** Add annotations to specific data points to highlight significant increases in latency at certain packet loss thresholds.",
        "output": "xychart-beta\n    title \"TCP Connection: Network Latency vs. Packet Loss\"\n    x-axis \"Packet Loss Percentage\" 0 --> 100\n    y-axis \"Network Latency ms\"\n    line [10 50 25 120 40 250 60 400 80 700]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram displaying CPU usage over time for a chat application.",
        "planning": "*   **X-Axis (Time):** Represents the passage of time. Units: seconds, minutes, etc.\n\n*   **Y-Axis (CPU Usage):** Represents the percentage of CPU being used. Units: %. Range: 0-100.\n\n*   **Data Points:** Each point represents CPU usage at a specific time.  Plotted using time on the X-axis and CPU usage on the Y-axis.\n\n*   **Line/Series:**  Connects the data points to visually show the trend of CPU usage over time.  Represents the chat application's CPU usage.\n\n*   **Chat Application (Implied):** Generates the CPU usage data that is displayed on the chart. Not directly on the chart, but the data source.\n\n*   **Interaction:** The Chat Application's CPU Usage Data is the Input. That Input data is translated to the chart's Data points. The connected Data Points makes up the Lines/Series in the XY Chart. The X and Y axis are for context.",
        "output": "xychart-beta\n    x-axis [0s, 10s, 20s, 30s, 40s, 50s, 60s]\n    y-axis \"CPU Usage (%)\" 0 --> 100\n    line [10, 15, 22, 30, 45, 60, 75]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram to illustrate memory consumption versus time for an e-commerce application.",
        "planning": "*   **X-Axis (Time):** Represents the timeline of the application's execution (e.g., seconds, minutes, hours).\n*   **Y-Axis (Memory Consumption):** Represents the amount of memory being used by the application (e.g., MB, GB).\n*   **Data Series (Memory Usage Line):** A line plotting the memory consumption at different points in time. This line visually represents memory usage trend.\n*   **Events/Markers (Optional):** Markers on the line indicating specific events (e.g., peak load, deployment, garbage collection) that might correlate with changes in memory consumption. Markings are not necessary, but highly recommended for providing additional information.\n*   **Legend:** Identifies the data series being plotted (e.g., \"Heap Memory\", \"Non-Heap Memory\"). If there is only one curve, legend can be skipped.",
        "output": "xychart-beta\n    x-axis [0, 5, 10, 15, 20, 25, 30]\n    y-axis \"Memory Consumption MB\" 0 --> 100\n    line [10, 25, 40, 60, 50, 75, 90]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram showing the growth of a social media platform's active user base over time.",
        "planning": "*   **X-axis:** Time (Months, Quarters, Years). Represents the independent variable.\n*   **Y-axis:** Active Users (Number of users). Represents the dependent variable.\n*   **Data Points:** Represent the number of active users at specific time intervals. Each point connects to form a line.\n*   **Line:** Connects the data points, showing the trend of user growth over time. Upward slope indicates growth, downward slope indicates decline.\n*   **Chart Title:** \"Active User Growth\" or similar. Describes the data being presented.\n*   **Axis Labels:** \"Time\" for the x-axis, \"Active Users\" for the y-axis. Clearly identifies what each axis represents.\n*   **Legend (Optional):** If multiple lines are present (e.g., comparing different regions), a legend clarifies which line represents what.",
        "output": "xychart-beta\n    title \"Active User Growth\"\n    x-axis [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]\n    y-axis \"Active Users\" 1000 --> 10000\n    line [1500, 2500, 3800, 4200, 5500, 6500, 7200, 7800, 8100, 8900, 9200, 9800]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram visualizing server response time versus number of concurrent users in a RESTful API system.",
        "planning": "*   **Chart Title:** \"Server Response Time vs. Concurrent Users\"\n*   **X-Axis:**\n    *   Label: \"Number of Concurrent Users\"\n    *   Range: Appropriate range based on expected user load (e.g., 0 to 1000)\n    *   Scale: Linear\n*   **Y-Axis:**\n    *   Label: \"Response Time (ms)\"\n    *   Range: Appropriate range based on expected response times (e.g., 0 to 500 ms)\n    *   Scale: Linear\n*   **Data Series:**\n    *   Series 1: Response Time data\n    *   Data Points: Each point represents a specific number of concurrent users and the corresponding average/median response time.\n*   **Plot Area:**\n    *   Visualize the relationship between concurrent users and response time. As concurrent users increase, observe the corresponding increase in response time (ideally showing a trend).\n*   **Legend (Optional):** If multiple data series are present (e.g., different API endpoints).\n*   **Annotations (Optional):** Highlight key thresholds or performance bottlenecks.",
        "output": "xychart-beta\n    title \"Server Response Time vs Concurrent Users\"\n    x-axis \"Number of Concurrent Users\" 0 --> 1000\n    y-axis \"Response Time (ms)\" 0 --> 500\n    line [50 75 120 180 250 330 420 500 600 700]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram for a RAG-based search engine showing response time versus query complexity.",
        "planning": "*   **X-axis:** Query Complexity (e.g., Number of clauses, tokens, relations).\n*   **Y-axis:** Response Time (e.g., milliseconds, seconds).\n*   **Data Points:** Represent individual queries. Positioned based on their complexity and response time.\n*   **RAG Pipeline Stages (implicit):** While not explicitly labeled on the axes, the data point distribution *implicitly* reflects the combined latency of Retrieval, Augmentation, and Generation stages.\n*   **Trend Line (optional):** Show the general trend of response time as query complexity increases.",
        "output": "xychart-beta\n    x-axis \"Query Complexity\" [Simple, Medium, Complex]\n    y-axis \"Response Time (ms)\" 0 --> 200\n    line [20, 80, 180]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram comparing execution times of different algorithms as dataset size increases.",
        "planning": "**Chart Components:**\n\n*   **X-Axis:** Dataset Size (Input Size)\n*   **Y-Axis:** Execution Time (Milliseconds, Seconds, etc.)\n*   **Data Series:** Each algorithm represented as a separate line or set of points. Each series plots execution time vs. dataset size for that specific algorithm.\n*   **Title:** Descriptive title, e.g., \"Algorithm Execution Time vs. Dataset Size\"\n*   **Legend:** Identifies each algorithm's line/data series.\n\n**Interactions:**\n\n*   **X-Axis & Data Series:** X-axis values (dataset sizes) are the input for each algorithm's execution.\n*   **Y-Axis & Data Series:** Y-axis values (execution times) are the output of the algorithms running on specific dataset sizes. The data series plots these x,y pairs.\n*   **Legend & Data Series:** Legend clarifies which line represents which algorithm, allowing for visual comparison.",
        "output": "xychart-beta\n    title \"Algorithm Execution Time vs Dataset Size\"\n    x-axis [10 20 30 40 50]\n    y-axis \"Execution Time (ms)\" 0 --> 100\n    line [10 15 23 32 41]\n    line [12 18 27 36 45]\n    line [15 22 31 40 49]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram showing the trend of network throughput versus time in a stock-trading application.",
        "planning": "*   **X-axis (Time):** Represents the progression of time, such as seconds, minutes, or hours.\n*   **Y-axis (Network Throughput):** Represents the amount of data transferred per unit of time, typically in bits per second (bps) or bytes per second (Bps).\n*   **Data Points:** Each point on the chart represents the network throughput measured at a specific time.\n*   **Trend Line:** A line connecting the data points, visually illustrating the overall trend of network throughput over time.  May be smoothed for clarity.\n*   **Title:** \"Network Throughput vs. Time in Stock-Trading Application\"\n*   **Labels:** X-axis label \"Time\", Y-axis label \"Network Throughput (bps)\".\n\nInteraction: Time progresses along the X-axis. At each time point, a measurement of Network Throughput is taken and plotted on the Y-axis. The trend line visually connects these measurements to show how throughput changes over time.",
        "output": "xychart-beta\n    title \"Network Throughput vs. Time in Stock-Trading Application\"\n    x-axis [0s 10s 20s 30s 40s 50s 60s]\n    y-axis \"Network Throughput bps\" 1000 --> 10000\n    line [2000 3000 4500 6000 7500 8000 9000]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram representing the number of transactions per hour over a day in an online banking system.",
        "planning": "*   **Chart Title:** \"Transactions per Hour - Online Banking\"\n*   **X-Axis Label:** \"Hour of Day (0-23)\"\n*   **Y-Axis Label:** \"Number of Transactions\"\n*   **Data Series:** A single series representing the number of transactions for each hour. The X-value is the hour (0-23) and the Y-value is the transaction count for that hour.\n*   **Data Points:** Represent the individual transaction counts for each hour. These points form the line or bars on the chart.\n*   **Line/Bars:** Connect data points to visually represent the trend of transactions over the day.\n*   **Axis Scales:** Numerical scales on both X and Y axis to represent the time and transaction counts. The X-axis should range from 0 to 23. The Y-axis should adjust dynamically based on the maximum transaction count.",
        "output": "xychart-beta\n    title \"Transactions per Hour - Online Banking\"\n    x-axis \"Hour of Day\" 0 --> 23\n    y-axis \"Number of Transactions\"\n    line [10, 12, 15, 20, 30, 45, 60, 75, 80, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 18, 15, 12, 10]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram to plot energy consumption versus time for a distributed MapReduce computing system.",
        "planning": "**xyChart Diagram Plan: Energy Consumption vs. Time**\n\n*   **X-Axis:** Time (Units: Seconds, Minutes, Hours - specify).\n*   **Y-Axis:** Energy Consumption (Units: Joules, kWh - specify).\n*   **Data Series 1: Master Node(s):** Plot energy consumption of the master node(s) over time.\n*   **Data Series 2: Worker Node(s):** Plot aggregated energy consumption of worker nodes over time. Could represent an average or total. Consider including several worker nodes to showcase the impact of each worker node to the total energy consumption.\n*   **Data Series 3: Network Infrastructure:** Plot energy consumption of network devices (switches, routers) required for communication.\n*   **Possible Annotations:**\n    *   MapReduce Job Start/End times: Mark when MapReduce jobs begin and end, correlating them with energy spikes.\n    *   Data Transfer Spikes: Highlight periods of high network activity, linking them to increased energy use.\n    *   Idle Periods: Show periods where energy consumption is minimal.",
        "output": "xychart-beta\n    x-axis [0min 10min 20min 30min 40min 50min 60min]\n    y-axis \"Energy Consumption kWh\" 0 --> 10\n    line [1.5 2.5 3.1 4.2 5.8 6.1 7.9 8.2 9.1 9.5]\n    line [0.5 1.0 1.3 2.1 2.4 3.2 3.8 4.2 4.8 5.0]\n    line [0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram to display load time trends over time for a web application built with React.",
        "planning": "*   **X-Axis:** Represents Time (e.g., timestamps, date/time).\n\n*   **Y-Axis:** Represents Load Time (e.g., milliseconds, seconds).\n\n*   **Data Points:** Each point represents a specific load time measurement at a specific time. Points derive from collected performance data, such as that recorded by performance monitoring tools.\n\n*   **Line/Curve:** Connects the data points to visualize the trend of load time over time.\n\n*   **Title:** \"Load Time Trends\" or similar descriptive title.\n\n*   **X-Axis Label:** \"Time\" or specific time interval.\n\n*   **Y-Axis Label:** \"Load Time (ms)\" or appropriate unit.\n\n*   **Legend (Optional):** If multiple metrics are displayed, a legend would be useful.",
        "output": "xychart-beta\n    title \"Load Time Trends\"\n    x-axis [00:00 00:05 00:10 00:15 00:20 00:25]\n    y-axis \"Load Time (ms)\" 0 --> 1000\n    line [150 250 300 420 580 700]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram showing server response time versus request payload size in a microservices-based architecture.",
        "planning": "*   **X-axis:** Request Payload Size (bytes, KB, or MB)\n*   **Y-axis:** Server Response Time (milliseconds or seconds)\n*   **Data Points:** Represent individual requests, plotted based on their payload size and the server's response time.\n*   **Microservices:** Represent the server component processing the requests. (Optional: Can be a single \"Server\" or multiple named microservices like \"Authentication Service,\" \"Data Service,\" etc.)\n*   **Client:** Initiates requests to the microservices.\n*   **Interaction:** Client sends request with varying payload size -> Microservice processes request -> Microservice returns response (response time measured).\n*   **Trendline (Optional):** Show the general trend of response time as payload size increases.",
        "output": "xychart-beta\n    x-axis \"Request Payload Size MB\" [0.1 0.2 0.3 0.4 0.5]\n    y-axis \"Server Response Time ms\" 0 --> 200\n    line [20 40 60 80 100]\n    bar [30 50 70 90 110]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram illustrating the growth trend of active users versus time in a dating application.",
        "planning": "*   **X-Axis (Time):** Represents the time period (e.g., days, weeks, months). The scale should be appropriate for the dataset.\n*   **Y-Axis (Active Users):** Represents the number of active users. The scale should start near zero or the minimum active user count.\n*   **Data Series/Line:** A line connecting data points showing the trend of active users over time. The line visually represents the correlation between time and active user count.\n*   **Data Points (Optional):** Individual markers on the line indicating the exact active user count at specific time intervals. These can emphasize specific data points.\n*   **Title:** \"Active Users vs. Time\" - Clearly describes the chart's purpose.\n*   **Axis Labels:** \"Time\" and \"Number of Active Users\" - Identifies what each axis represents.\n*   **Legend (Not Always Needed):** If comparing multiple user segments (e.g., different age groups), a legend distinguishes each line. Not necessary for a single 'active users' line.",
        "output": "xychart-beta\n    title \"Active Users vs Time\"\n    x-axis [Week1 Week2 Week3 Week4 Week5 Week6]\n    y-axis \"Number of Active Users\" 100 --> 500\n    line [150 200 320 400 410 480]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram comparing scalability metrics (like response time) of monolithic versus microservices architectures.",
        "planning": "*   **X-Axis:** Request Load (e.g., Requests per Second) - represents the increasing load on the system.\n\n*   **Y-Axis:** Response Time (e.g., Milliseconds) - represents the latency experienced by users.\n\n*   **Data Series 1:** Monolithic Architecture - A single line showing response time increasing as request load increases. Expect a steeper increase and earlier performance degradation.\n\n*   **Data Series 2:** Microservices Architecture - A line showing response time also increasing with request load, but ideally with a gentler slope and later performance degradation compared to the monolithic architecture.\n\n*   **Annotation Points:**\n    *   Point where Monolithic response time starts to degrade significantly.\n    *   Point where Microservices response time starts to degrade significantly (ideally at a higher request load).\n    *   Potentially a point showing the \"knee\" in each curve (where performance starts to noticeably worsen).",
        "output": "xychart-beta\n    x-axis \"Request Load (Requests/Second)\" [100 200 300 400 500 600 700 800]\n    y-axis \"Response Time (Milliseconds)\" 0 --> 600\n    line [50 70 100 150 220 310 420 550]\n    line [40 55 75 95 120 150 185 230]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram showing memory usage versus the number of threads in a parallel processing system.",
        "planning": "*   **X-axis:** \"Number of Threads\". Represents the independent variable (number of threads used).\n*   **Y-axis:** \"Memory Usage\". Represents the dependent variable (amount of memory consumed). Units (e.g., MB, GB) should be specified.\n*   **Data Points:** Each point on the chart represents a specific measurement of memory usage for a particular number of threads.\n*   **Trend Line/Curve:** A line or curve connecting the data points to visually represent the relationship between the number of threads and memory usage. It might show a linear, exponential, or other type of relationship.\n*   **Chart Title:** \"Memory Usage vs. Number of Threads\" - A clear title describing the data being presented.\n*   **Labels:** Labels for each axis to specify the variable being measured and its units.",
        "output": "xychart-beta\n    title \"Memory Usage vs. Number of Threads\"\n    x-axis \"Number of Threads\" [1, 2, 4, 8, 16, 32]\n    y-axis \"Memory Usage (MB)\" 100 --> 1000\n    line [150, 250, 400, 650, 800, 950]\n    bar  [150, 250, 400, 650, 800, 950]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram to visualize cache hit ratio trends over time in a distributed caching system.",
        "planning": "*   **X-axis (Time):** Represents the timeline, showing the progression of time (e.g., seconds, minutes, hours, days).\n\n*   **Y-axis (Cache Hit Ratio):** Represents the percentage of requests served from the cache. Ranges from 0% to 100%.\n\n*   **Data Points:** Each point on the chart represents the cache hit ratio at a specific point in time.\n\n*   **Line/Series:** A line connecting the data points to visualize the trend of the cache hit ratio over time.\n\n*   **Legend (Optional):** If multiple caches are being monitored, a legend differentiates the lines representing each cache.\n\n*   **Title:** \"Cache Hit Ratio Trends Over Time\"\n\n*   **Labels:** X-axis labeled as \"Time\" and Y-axis labeled as \"Cache Hit Ratio (%)\".\n\n*   **Optional Annotation**: Mark interesting data points on the chart.",
        "output": "xychart-beta\n    title Cache Hit Ratio Trends Over Time\n    x-axis [00:00 00:15 00:30 00:45 01:00 01:15 01:30 01:45]\n    y-axis \"Cache Hit Ratio (%)\" 0 --> 100\n    line [60 65 70 75 80 85 90 95]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram showing the relationship between encryption key size and encryption/decryption time for RSA cryptography.",
        "planning": "*   **X-Axis:** Encryption Key Size (bits) - Values should range from typical RSA key sizes (e.g., 512, 1024, 2048, 4096).\n*   **Y-Axis:** Encryption/Decryption Time (milliseconds/seconds) - Represents the time taken for encryption or decryption.\n*   **Data Series 1:** Encryption Time - Plots the time taken to encrypt data for each key size.\n*   **Data Series 2:** Decryption Time - Plots the time taken to decrypt data for each key size.\n*   **Plot Area:** Shows how encryption and decryption times generally increase with key size.\n*   **Legend:** Identifies which line represents encryption time and which represents decryption time.",
        "output": "xychart-beta\n    x-axis [512, 1024, 2048, 4096]\n    y-axis \"Time (ms)\"\n    line [10, 25, 60, 150]\n    line [15, 35, 80, 200]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram displaying internet download and upload speed trends over several weeks for a home network.",
        "planning": "*   **Chart Title:** \"Home Network Download/Upload Speed Trends\" (identifies the data)\n*   **X-Axis:** \"Date (Weeks)\" (represents the time period)\n*   **Y-Axis:** \"Speed (Mbps)\" (represents the download/upload speed)\n*   **Download Speed Line:** (plots download speed data points over time)\n*   **Upload Speed Line:** (plots upload speed data points over time)\n*   **Legend:** (identifies which line represents download and upload speeds)\n*   **Data Points:** (individual measurements of download/upload speed at specific dates)\n*   **Interaction:**\n    *   X-Axis provides the timeline for the data.\n    *   Y-Axis provides the scale for speed.\n    *   Data Points are positioned on the chart based on their X-axis (date) and Y-axis (speed) values.\n    *   Download and upload lines connect respective data points, visualizing trends.\n    *   Legend connects the lines displayed to the type of speed they're displaying.",
        "output": "xychart-beta\n    title \"Home Network Download/Upload Speed Trends\"\n    x-axis [Week1 Week2 Week3 Week4 Week5 Week6]\n    y-axis \"Speed Mbps\" 0 --> 100\n    line [60 65 72 78 85 90]\n    line [15 18 20 22 25 28]"
    },
    {
        "diagram_type": "xyChart",
        "prompt": "Generate an xyChart diagram representing average response time versus the number of API calls for a weather forecast application.",
        "planning": "*   **Chart Title:** \"Average Response Time vs. Number of API Calls\"\n*   **X-Axis:** \"Number of API Calls\" (Range: e.g., 0 to 1000, incrementing by 100)\n*   **Y-Axis:** \"Average Response Time (ms)\" (Range: e.g., 0 to 500ms, incrementing by 50ms)\n*   **Data Series:** A line or scatter plot representing the average response time for different numbers of API calls. As the number of calls increases, the response time may increase or remain stable.\n*   **Data Points:** Each point on the chart represents a specific number of API calls and its corresponding average response time.\n*   **Trendline (Optional):** A line of best fit to show the general trend of response time versus API calls.\n*   **Labels:** X and Y axis labels to show what x and y axis are used for and also the unit of measurement.",
        "output": "xychart-beta\n    title \"Average Response Time vs Number of API Calls\"\n    x-axis \"Number of API Calls\" 0 --> 1000\n    y-axis \"Average Response Time ms\" 0 --> 500\n    line [20, 40, 60, 80, 100, 120, 140, 160, 180, 200]"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Generate a zenuml flow diagram illustrating the TCP three-way handshake, including SYN, SYN-ACK, and ACK messages.",
        "planning": "*   **Client:** Initiates the connection.\n*   **Server:** Listens for incoming connection requests.\n*   **SYN (Synchronize):** Client sends to Server.\n*   **SYN-ACK (Synchronize-Acknowledge):** Server sends to Client.\n*   **ACK (Acknowledge):** Client sends to Server.\n*   **Arrows:** Illustrate the flow of messages between Client and Server.\n*   **States:** Implicitly show connection state changes on both sides (e.g., Client: SYN-SENT, Server: SYN-RECEIVED, both: ESTABLISHED).",
        "output": "zenuml\n    Client->Server: SYN\n    Server->Client: SYN-ACK\n    Client->Server: ACK"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Draw a zenuml sequence diagram for client-server communication in an E-commerce application during the checkout process.",
        "planning": "*   **Client (Customer's Browser):** Initiates the checkout, displays information to the user.\n*   **Web Server:** Handles client requests, manages sessions, interacts with other services.\n*   **Authentication Service:** Verifies user credentials.\n*   **Shopping Cart Service:** Stores and manages items in the customer's cart.\n*   **Payment Service:** Processes payments using payment gateway.\n*   **Inventory Service:** Checks and updates product stock levels.\n*   **Order Service:** Creates and manages the order.\n*   **Database:** Stores data (user info, product details, order details, etc.)\n\n**Interactions:**\n\n1.  **Client -> Web Server:** Checkout request.\n2.  **Web Server -> Authentication Service:** Authenticate user.\n3.  **Web Server -> Shopping Cart Service:** Retrieve cart details.\n4.  **Web Server -> Payment Service:** Initiate payment processing.\n5.  **Payment Service -> (External) Payment Gateway:** (Implied external service)\n6.  **Payment Service -> Web Server:** Payment confirmation.\n7.  **Web Server -> Inventory Service:** Check/Update inventory.\n8.  **Web Server -> Order Service:** Create order.\n9.  **Order Service -> Database:** Store order details.\n10. **Web Server -> Client:** Order confirmation.",
        "output": "zenuml\n    Client\n    WebServer\n    AuthService\n    CartService\n    PaymentService\n    InventoryService\n    OrderService\n    Database\n\n    Client->WebServer: Checkout Request\n    WebServer->AuthService: Authenticate User\n    AuthService->WebServer: User Authenticated\n    WebServer->CartService: Retrieve Cart Details\n    CartService->WebServer: Cart Details\n    WebServer->PaymentService: Initiate Payment Processing\n    PaymentService->PaymentService: Interact with Payment Gateway\n    PaymentService->WebServer: Payment Confirmation\n    WebServer->InventoryService: Check Update Inventory\n    InventoryService->WebServer: Inventory Updated\n    WebServer->OrderService: Create Order\n    OrderService->Database: Store Order Details\n    Database->OrderService: Order Details Stored\n    OrderService->WebServer: Order Created\n    WebServer->Client: Order Confirmation"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Create a zenuml flow diagram detailing the steps of OAuth 2.0 authentication in a chat application.",
        "planning": "*   **User:** Initiates authorization request.\n*   **Chat Application (Client):** Redirects user to Authorization Server, requests authorization code.\n*   **Authorization Server:** Authenticates user, obtains user consent, issues authorization code.\n*   **Chat Application (Client):** Exchanges authorization code for access token.\n*   **Resource Server (Chat API):** Validates access token, provides access to protected resources (chat messages).\n*   **User:** Accesses chat messages via the Chat Application using the access token.\n\n**Interactions:**\n\n1.  User clicks \"Login\" in Chat Application.\n2.  Chat Application redirects user to Authorization Server with Client ID, redirect URI, and scope.\n3.  Authorization Server presents login/consent screen to User.\n4.  User authenticates and grants consent.\n5.  Authorization Server redirects User back to Chat Application with authorization code.\n6.  Chat Application exchanges authorization code with Authorization Server for access token.\n7.  Chat Application sends access token to Resource Server (Chat API) to access chat messages.\n8.  Resource Server validates token and returns chat messages to Chat Application.\n9. Chat Application shows chat messages to User.",
        "output": "zenuml\n    User.clicksLogin\n    ChatApp->AuthServer: RedirectsUser\n    // User authenticates and grants consent.\n    AuthServer.presentsLogin\n    AuthServer->ChatApp: RedirectsUserWithCode\n    ChatApp->AuthServer: ExchangesCodeForToken\n    token = AuthServer.issueAccessToken\n    ChatApp->ChatAPI: SendsAccessToken\n    ChatAPI.validateToken\n    ChatAPI->ChatApp: returnsChatMessages\n    ChatApp->User: showsChatMessages"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Provide a zenuml block diagram representing the RSA encryption and decryption process for secure messaging.",
        "planning": "*   **Entities:**\n    *   Sender\n    *   Receiver\n    *   RSA Encryption\n    *   RSA Decryption\n*   **Components & Interactions:**\n    1.  Sender: Generates a plaintext message.\n    2.  Sender -> RSA Encryption: Sends plaintext to the Encryption component.\n    3.  RSA Encryption: Uses Receiver's public key to encrypt the message, resulting in ciphertext.\n    4.  RSA Encryption -> Receiver: Sends ciphertext to the Receiver.\n    5.  Receiver -> RSA Decryption: Sends ciphertext to the Decryption component.\n    6.  RSA Decryption: Uses Receiver's private key to decrypt the ciphertext, resulting in the original plaintext message.\n    7.  RSA Decryption -> Receiver: Outputs the plaintext message to the Receiver.\n*   **Key Elements:**\n    *   Public Key (for encryption)\n    *   Private Key (for decryption)\n    *   Plaintext Message\n    *   Ciphertext Message",
        "output": "zenuml\n  Sender\n  Receiver\n  RSA_Encryption\n  RSA_Decryption\n\n  Sender->RSA_Encryption: Plaintext Message\n  RSA_Encryption.encrypt { \n    // Using Receiver's Public Key\n    RSA_Encryption->Receiver: Ciphertext\n  }\n  \n  Receiver->RSA_Decryption: Ciphertext\n  RSA_Decryption.decrypt {\n    // Using Receiver's Private Key\n    RSA_Decryption->Receiver: Plaintext Message\n  }"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Construct a zenuml diagram showing the resource allocation and scheduling process in an operating system.",
        "planning": "**Components:**\n\n*   **Processes:** Represent running programs/tasks requiring resources.\n*   **Scheduler:** Decides which process gets resources and when.\n*   **Resource Manager:** Manages available resources (CPU, Memory, I/O devices).\n*   **Resource Pool:** Represents the collection of available resources.\n*   **Process Control Block (PCB):** Data structure holding process information (state, priority, resource allocation).\n\n**Interactions:**\n\n1.  **Process -> Scheduler:** Process requests resources (e.g., CPU time).\n2.  **Scheduler -> PCB:** Scheduler retrieves process information from its PCB to make scheduling decisions.\n3.  **Scheduler -> Resource Manager:** Scheduler requests resources from the Resource Manager for a selected process.\n4.  **Resource Manager -> Resource Pool:** Resource Manager checks resource availability in the Resource Pool.\n5.  **Resource Manager -> PCB:** Resource Manager updates the PCB to reflect resource allocation (or failure).\n6.  **Resource Manager -> Scheduler:** Resource Manager informs the Scheduler about resource allocation success/failure.\n7.  **Scheduler -> Process:** Scheduler grants or denies resource access to the process (based on Resource Manager response).\n8.  **Process -> Resource Manager:** Process releases resources upon completion or preemption.\n9.  **Resource Manager -> Resource Pool:** Resource Manager returns released resources to the Resource Pool.",
        "output": "zenuml\n  Process\n  Scheduler\n  ResourceManager\n  ResourcePool\n  PCB\n\n  Process->Scheduler: Request Resources\n  Scheduler->PCB: Get Process Information\n  Scheduler->ResourceManager: Request Resources for Process\n  ResourceManager->ResourcePool: Check Resource Availability\n  ResourceManager->PCB: Update PCB with Allocation Info\n  ResourceManager->Scheduler: Inform Scheduler about Allocation\n  Scheduler->Process: Grant or Deny Resource Access\n  Process->ResourceManager: Release Resources\n  ResourceManager->ResourcePool: Return Resources to Pool"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Illustrate a zenuml state diagram representing the fork-join process in a parallel computing system.",
        "planning": "*   **Initial State:** Represents the starting point of the parallel process.\n\n*   **Fork State:** A state with a single incoming transition and multiple outgoing transitions. This signifies the splitting of the process into parallel execution paths.\n\n*   **Parallel Activities (States):** Represent the tasks or activities that are executed concurrently. Label these with descriptive names (e.g., \"Process Data A\", \"Process Data B\").\n\n*   **Transitions:** Arrows connecting states, indicating the flow of execution.\n\n*   **Join State:** A state with multiple incoming transitions and a single outgoing transition. This synchronizes the parallel execution paths, waiting for all parallel activities to complete before proceeding.\n\n*   **Final State:** Represents the end of the parallel process after the join.\n\n*   **Interaction:** The Fork State splits the flow to parallel activities. These activities execute independently. The Join State waits for all activities to complete before transitioning to the Final State.",
        "output": "zenuml\n  Initial -> Fork: Start\n\n  Fork -> ProcessA\n  Fork -> ProcessB\n\n  ProcessA -> Join: Complete A\n  ProcessB -> Join: Complete B\n\n  Join -> Final: All Complete\n\n  @Actor Initial\n  @Actor Fork\n  @Actor Join\n  @Actor Final\n  @Database ProcessA\n  @Database ProcessB"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Generate a zenuml diagram of a kanban board managing tasks in a software development project.",
        "planning": "*   **KanbanBoard:** Central container for the board itself.\n*   **Columns:** Represent stages of the workflow (e.g., \"To Do,\" \"In Progress,\" \"Code Review,\" \"Done\").\n*   **Tasks (Cards):** Represent individual tasks, with properties like:\n    *   `TaskID`: Unique identifier.\n    *   `Title`: Task name.\n    *   `Description`: Task details.\n    *   `Assignee`: Person responsible.\n    *   `Priority`: Task importance.\n*   **Interactions:**\n    *   Tasks belong to a specific Column.\n    *   Tasks can be moved between Columns, representing workflow progression.\n    *   Assignee is associated with a Task.\n    *   KanbanBoard contains multiple Columns.",
        "output": "zenuml\n  KanbanBoard\n  Column1 as \"To Do\"\n  Column2 as \"In Progress\"\n  Column3 as \"Code Review\"\n  Column4 as \"Done\"\n\n  Task1 as \"Task A\"\n  Task2 as \"Task B\"\n  Task3 as \"Task C\"\n\n  Assignee1 as \"Dev A\"\n  Assignee2 as \"Dev B\"\n\n  KanbanBoard.Add(Column1)\n  KanbanBoard.Add(Column2)\n  KanbanBoard.Add(Column3)\n  KanbanBoard.Add(Column4)\n\n  Column1.AddTask(Task1)\n  Column2.AddTask(Task2)\n  Column3.AddTask(Task3)\n\n  Task1.Assign(Assignee1)\n  Task2.Assign(Assignee2)\n\n  // Move Task\n  Column1->Column2: Move Task A\n\n  //Expand Labels\n  note right of Task1: TaskID: 123\\nTitle: Implement Feature X\\nDescription: Detailed description of X\\nPriority: High\n  note right of Task2: TaskID: 456\\nTitle: Fix Bug Y\\nDescription: Detailed description of Y\\nPriority: Medium\n  note right of Task3: TaskID: 789\\nTitle: Review Code Z\\nDescription: Detailed description of Z\\nPriority: High"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Draw a zenuml flow diagram depicting the transmission of data packets in a UDP communication protocol.",
        "planning": "*   **Source Application:** Initiates data transmission. Sends data to UDP.\n*   **UDP at Sender:** Encapsulates data into UDP datagrams (adds UDP header: source port, destination port, length, checksum). Sends to IP.\n*   **IP at Sender:** Encapsulates UDP datagram into IP packet (adds IP header: source IP, destination IP). Routes to network interface.\n*   **Network:** Represents the network infrastructure (routers, switches). Transports the IP packet.\n*   **IP at Receiver:** Receives IP packet. Decapsulates IP header. Forwards UDP datagram to UDP.\n*   **UDP at Receiver:** Decapsulates UDP header. Sends data to destination application.\n*   **Destination Application:** Receives the data.",
        "output": "zenuml\n    SourceApp->UDPSender: Data\n    UDPSender.encapsulate {        \n        UDPSender->IPSender: UDP Datagram\n    }\n    IPSender.encapsulate {        \n        IPSender->Network: IP Packet\n    }\n    Network->IPReceiver: IP Packet\n    IPReceiver.decapsulate {\n        IPReceiver->UDPReceiver: UDP Datagram\n    }\n    UDPReceiver.decapsulate {\n        UDPReceiver->DestApp: Data\n    }\n\n    // Participants\n    @Actor SourceApp\n    @Actor DestApp\n    UDPSender as UDP at Sender\n    IPSender as IP at Sender\n    IPReceiver as IP at Receiver\n    UDPReceiver as UDP at Receiver"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Create a zenuml flow diagram that outlines the establishment of a TCP connection via the three-way handshake.",
        "planning": "*   **Client (Sender):** The initiator of the connection.\n*   **Server (Receiver):** The listener and acceptor of the connection.\n*   **SYN (Synchronization):** Packet indicating a request to synchronize sequence numbers.\n*   **ACK (Acknowledgement):** Packet acknowledging received data.\n*   **Sequence Number (seq):** Number assigned to the first byte of data in a TCP segment.\n*   **Acknowledgement Number (ack):** Expected next sequence number from the other party.\n\n**Interactions:**\n\n1.  **Client -> Server: SYN (seq=x)**: Client sends a SYN packet to the server, indicating its desire to establish a connection with an initial sequence number 'x'.\n2.  **Server -> Client: SYN-ACK (seq=y, ack=x+1)**: Server responds with a SYN-ACK packet, acknowledging the client's SYN (ack=x+1) and setting its own initial sequence number 'y'.\n3.  **Client -> Server: ACK (seq=x+1, ack=y+1)**: Client sends an ACK packet to the server, acknowledging the server's SYN (ack=y+1). The connection is now established.",
        "output": "zenuml\n  Client->Server: SYN seq=x\n  Server->Client: SYN-ACK seq=y ack=x+1\n  Client->Server: ACK seq=x+1 ack=y+1"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Visualize a zenuml diagram of a simplified architecture of an E-commerce recommendation system.",
        "planning": "*   **User:** Interacts with the system, providing data (explicit ratings, purchase history, browsing history).\n\n*   **Web/App Interface:** Receives user requests and displays recommendations.\n\n*   **Data Collection & Storage:** Gathers user data and stores it (e.g., in a database).\n\n*   **Recommendation Engine:** Core component; processes user data and generates recommendations.\n\n*   **Model Training (Offline):** Trains the recommendation models periodically using historical data.\n\n*   **Item Catalog:** Stores information about available products.\n\n*   **Interaction Flow:**\n    *   User interacts with Web/App.\n    *   Web/App sends data to Data Collection.\n    *   Data Collection stores data in Storage.\n    *   Recommendation Engine retrieves user data from Storage and item data from the Item Catalog.\n    *   Recommendation Engine generates recommendations.\n    *   Recommendations are sent to Web/App for display.\n    *   Model Training uses data in Storage to periodically update the Recommendation Engine.",
        "output": "zenuml\n  User\n  WebInterface\n  DataCollection\n  DataStorage\n  RecommendationEngine\n  ItemCatalog\n  ModelTraining\n\n  User->WebInterface: Interacts with Web/App\n  WebInterface->DataCollection: Sends user data\n  DataCollection->DataStorage: Stores user data\n  RecommendationEngine->DataStorage: Retrieves user data\n  RecommendationEngine->ItemCatalog: Retrieves item data\n  RecommendationEngine->WebInterface: Sends recommendations\n  WebInterface->User: Displays recommendations\n  ModelTraining->DataStorage: Uses historical data\n  ModelTraining->RecommendationEngine: Updates recommendation models"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Generate a zenuml diagram showing the data processing steps in a text search application similar to Elasticsearch.",
        "planning": "**Plan for ZenUML Diagram: Text Search Application**\n\n*   **User:** Initiates search query.\n*   **Search API:** Receives query from the user.\n*   **Query Parser:** Parses the search query.\n*   **Index Searcher:** Searches the inverted index for matching terms.\n*   **Inverted Index:** Stores terms and document IDs.\n*   **Document Retrieval:** Retrieves relevant documents based on search results.\n*   **Ranker:** Ranks the retrieved documents based on relevance.\n*   **Search API:** Returns ranked results to the user.\n*   **Indexer:** Indexes documents.\n*   **Analyzer:** Analyzes the document text to make it ready for the Inverted Index.\n*   **Data Store:** Contains the documents to be indexed.",
        "output": "zenuml\n  User->SearchAPI: Search Query\n  SearchAPI->QueryParser: Parse Query\n  QueryParser->IndexSearcher: Search Terms\n  IndexSearcher->InvertedIndex: Retrieve Document IDs\n  IndexSearcher->DocumentRetrieval: Get Documents\n  DocumentRetrieval->Ranker: Rank Documents\n  Ranker->SearchAPI: Ranked Results\n  SearchAPI->User: Display Results\n\n  // Indexing Process\n  DataStore->Indexer: New Document\n  Indexer->Analyzer: Analyze Text\n  Analyzer->InvertedIndex: Update Index"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Construct a zenuml flow diagram that represents the client-server interaction in a RAG-based chatbot application.",
        "planning": "*   **Client:**\n    *   User sends a question.\n    *   Receives the chatbot's answer.\n\n*   **Server (RAG Chatbot):**\n    *   Receives user question.\n    *   Query Encoder: Encodes the user question into a query vector.\n    *   Vector Database:\n        *   Search: Finds relevant documents based on the query vector.\n        *   Returns relevant document chunks.\n    *   LLM (Large Language Model):\n        *   Receives the question and relevant document chunks.\n        *   Generates an answer.\n    *   Sends the answer back to the client.\n\n*   **Interactions:**\n    1.  Client -> Server: Send User Question.\n    2.  Server -> Query Encoder: Encode User Question.\n    3.  Query Encoder -> Vector Database: Send Query Vector\n    4.  Vector Database -> LLM: Sends retrieved document chunks.\n    5.  Server -> LLM: Send Question and retrieved documents\n    6.  LLM -> Server: Sends the generated answer.\n    7.  Server -> Client: Send Chatbot Answer.",
        "output": "zenuml\n    Client->Server: User Question\n    Server->QueryEncoder: Encode Question\n    QueryEncoder->VectorDatabase: Query Vector\n    VectorDatabase->LLM: Document Chunks\n    Server->LLM: Question + Documents\n    LLM->Server: Chatbot Answer\n    Server->Client: Chatbot Answer"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Draw a zenuml diagram outlining the sequence of events for setting up an HTTPS secure connection.",
        "planning": "*   **User (Client Browser):** Initiates the connection.\n*   **Web Server:** Hosts the website/application.\n*   **Certificate Authority (CA):** Trusted entity that issues digital certificates.\n\n**Interactions:**\n\n1.  **Client -> Server:**  Client sends an HTTPS request (ClientHello: TLS version, cipher suites).\n2.  **Server -> Client:** Server responds with its digital certificate (ServerHello: selected cipher suite, certificate).\n3.  **Client -> CA:** Client verifies the server's certificate with the Certificate Authority (implicitly via trusted root certificates).\n4.  **Client -> Server:** Client generates a pre-master secret, encrypts it with the server's public key (from the certificate), and sends it to the server.\n5.  **Server:** Server decrypts the pre-master secret using its private key.\n6.  **Client & Server:** Both derive a shared secret key from the pre-master secret.\n7.  **Client <-> Server:**  Secure communication using the shared secret key (encrypted data).",
        "output": "zenuml\n  Client as UserBrowser\n  Server as WebServer\n  CA as CertificateAuthority\n\n  // 1. Client initiates HTTPS request\n  UserBrowser->WebServer: ClientHello TLS version cipherSuites\n\n  // 2. Server responds with its certificate\n  WebServer->UserBrowser: ServerHello selectedCipherSuite certificate\n\n  // 3. Client verifies the certificate with CA\n  UserBrowser->CA: Verify serverCertificate\n\n  // 4. Client sends encrypted pre-master secret\n  UserBrowser->WebServer: Encrypted preMasterSecret\n\n  // 5. Server decrypts the pre-master secret\n  WebServer.decryptPreMasterSecret\n\n  // 6. Client and Server derive shared secret key\n  par {\n    UserBrowser.deriveSharedSecret\n    WebServer.deriveSharedSecret\n  }\n\n  // 7. Secure communication\n  UserBrowser<->WebServer: Encrypted data"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Illustrate a zenuml diagram showing the process of failure detection and recovery in a basic distributed system.",
        "planning": "*   **Components:**\n    *   Node A (Primary/Leader)\n    *   Node B (Secondary/Replica/Worker)\n    *   Monitor (Failure Detector)\n\n*   **Interactions:**\n    1.  **Heartbeat:** Node A periodically sends heartbeat signals to the Monitor.\n    2.  **Monitoring:** The Monitor observes heartbeat signals from Node A.\n    3.  **Failure Detection:** If the Monitor doesn't receive a heartbeat from Node A within a timeout period, it declares Node A as failed.\n    4.  **Notification:** The Monitor notifies Node B about Node A's failure.\n    5.  **Takeover/Election:** Node B initiates a takeover process (e.g., leader election) to become the new Primary.\n    6.  **Recovery:** Node B assumes Node A's responsibilities and continues operation.\n    7.  **Optional: Node A Recovery & Reintegration:** Node A recovers, rejoins the system as a secondary, potentially synchronizing with Node B.",
        "output": "zenuml\n    NodeA->Monitor: Heartbeat\n    Monitor->NodeA: Ack\n    opt {\n        // Failure Detection\n        Monitor->Monitor: Timeout\n        if(no_heartbeat) {\n            Monitor->NodeB: NodeA Failed\n            // Takeover\n            NodeB->NodeB: Become Primary\n            NodeB->Monitor: New Primary\n        }\n    }\n\n    // Optional: Node A Recovery\n    opt {\n        NodeA->NodeB: Rejoin\n        NodeB->NodeA: Sync Data\n        NodeA->NodeB: Become Secondary\n    }"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Create a zenuml state diagram that visualizes the state transitions in a simple vending machine operation protocol.",
        "planning": "*   **States:**\n    *   `Idle`: Initial state, waiting for user interaction.\n    *   `Selecting`: User is choosing a product.\n    *   `Payment`: User is inserting money.\n    *   `Dispensing`: Vending machine is delivering the product.\n    *   `Change`: Vending machine is returning change.\n    *   `OutOfStock`: The selected product is out of stock.\n    *   `Error`: General error condition.\n\n*   **Events (Triggers):**\n    *   `selectProduct`: User selects a product.\n    *   `insertCoin`: User inserts money.\n    *   `enoughMoney`: Sufficient money is inserted.\n    *   `dispense`: Product is dispensed.\n    *   `noChange`: No change is needed.\n    *   `returnChange`: Change is returned.\n    *   `productAvailable`: Product is available.\n    *   `productUnavailable`: Product is unavailable.\n    *   `timeout`: A timeout occurs (e.g., no selection after money insertion).\n    *   `cancel`: User cancels the operation.\n    *   `errorDetected`: An error occurred.\n\n*   **Transitions:**\n    *   `Idle` -> `Selecting`: `selectProduct`\n    *   `Selecting` -> `OutOfStock`: `productUnavailable`\n    *   `Selecting` -> `Payment`: `productAvailable`\n    *   `Payment` -> `Payment`: `insertCoin`\n    *   `Payment` -> `Dispensing`: `enoughMoney`\n    *   `Payment` -> `Idle`: `cancel` or `timeout` (money returned)\n    *   `Dispensing` -> `Change`: `returnChange`\n    *   `Dispensing` -> `Idle`: `noChange`\n    *   `Change` -> `Idle`: (automatic after change dispensed)\n    *   `Any` -> `Error`: `errorDetected`\n    *   `Error` -> `Idle`: (automatic after error cleared)\n\n*   **Interactions:**\n    *   User selects a product, triggering the `selectProduct` event.\n    *   The machine checks availability.\n    *   User inserts coins, triggering `insertCoin` event. The machine tracks the total amount.\n    *   When `enoughMoney`, the `dispense` event occurs.\n    *   Change is calculated and potentially returned.\n    *   Errors can occur at any point, transitioning to the `Error` state.",
        "output": "zenuml\n  Idle->Selecting: selectProduct\n  Selecting->OutOfStock: productUnavailable\n  Selecting->Payment: productAvailable\n  Payment->Payment: insertCoin\n  Payment->Dispensing: enoughMoney\n  Payment->Idle: cancel\n  Payment->Idle: timeout\n  Dispensing->Change: returnChange\n  Dispensing->Idle: noChange\n  Change->Idle\n  OutOfStock->Idle\n  Idle->Error: errorDetected\n  Selecting->Error: errorDetected\n  Payment->Error: errorDetected\n  Dispensing->Error: errorDetected\n  Change->Error: errorDetected\n  OutOfStock->Error: errorDetected\n  Error->Idle"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Generate a zenuml flow diagram representing the energy certification process in a green computing system.",
        "planning": "*   **System Initialization:** The process starts with the system being powered on and initialized.\n\n*   **Energy Monitoring:** Continuous monitoring of energy consumption by various system components (CPU, GPU, Memory, Storage).\n\n*   **Data Acquisition:** Gathering energy consumption data from sensors or power management interfaces.\n\n*   **Data Analysis:** Analyzing the collected data to identify energy usage patterns and anomalies.\n\n*   **Baseline Establishment:** Establishing a baseline energy consumption profile for normal operation.\n\n*   **Performance Evaluation:** Evaluate impact of energy saving actions on overall system performance\n\n*   **Optimization Algorithm:** Decide energy saving actions according to the energy monitoring and performance evaluation\n\n*   **Energy Saving Actions:** Setting power limits, frequency scaling, or other power-saving strategies.\n\n*   **Certification Module:** Compares the system's actual energy consumption with predefined certification standards.\n\n*   **Reporting:** Generates a report indicating whether the system meets the energy certification requirements.\n\n*   **Certification Validation:** Verifying that the system meets the required energy efficiency standards.\n\n*   **Certification Granting:** Officially granting the energy certification if the system meets the requirements.",
        "output": "zenuml\n  System -> EnergyMonitor: System Initialization\n  EnergyMonitor -> DataAcquisition: Energy Monitoring\n  DataAcquisition -> DataAnalysis: Gather Energy Data\n  DataAnalysis -> Baseline: Analyze Data\n  Baseline -> PerfEval: Establish Baseline\n  PerfEval -> OptAlgo: Performance Evaluation\n  OptAlgo -> EnergySaving: Optimization Algorithm\n  EnergySaving -> CertificationModule: Energy Saving Actions\n  CertificationModule -> Reporting: Compare to Standards\n  Reporting -> CertificationValidation: Generate Report\n  CertificationValidation -> CertificationGranting: Verify Standards"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Construct a zenuml diagram outlining the order processing steps in a microservices-based online store.",
        "planning": "**Components:**\n\n*   **Customer:** Initiates the order.\n*   **API Gateway:** Entry point, routes requests.\n*   **Order Service:** Creates/manages order records.\n*   **Product Service:** Checks stock, retrieves product info.\n*   **Payment Service:** Processes payment.\n*   **Inventory Service:** Updates inventory levels.\n*   **Shipping Service:** Handles order shipment.\n*   **Notification Service:** Sends order updates.\n\n**Interactions:**\n\n1.  Customer places order (through UI/App).\n2.  UI/App sends request to API Gateway.\n3.  API Gateway routes to Order Service.\n4.  Order Service:\n    *   Creates order record.\n    *   Calls Product Service to validate product availability.\n    *   Calls Payment Service to process payment.\n    *   Calls Inventory Service to reserve inventory.\n5.  Inventory Service updates inventory (if payment succeeds).\n6.  Order Service notifies Shipping Service to initiate shipment.\n7.  Shipping Service updates order status.\n8.  Notification Service sends order updates to Customer.\n9.  Order Service returns confirmation to API Gateway.\n10. API Gateway returns confirmation to Customer.",
        "output": "zenuml\n    Customer\n    APIGateway\n    OrderService\n    ProductService\n    PaymentService\n    InventoryService\n    ShippingService\n    NotificationService\n\n    Customer->APIGateway: Place Order\n    APIGateway->OrderService: Create Order\n\n    OrderService->ProductService: Validate Products\n    ProductService-->>OrderService: Product Info\n\n    OrderService->PaymentService: Process Payment\n    PaymentService-->>OrderService: Payment Status\n\n    if(Payment Status == Success) {\n        OrderService->InventoryService: Reserve Inventory\n        InventoryService->InventoryService: Update Inventory\n\n        OrderService->ShippingService: Initiate Shipment\n        ShippingService->ShippingService: Update Order Status\n\n        OrderService->NotificationService: Send Order Updates\n        NotificationService->Customer: Order Updates\n    }\n\n    OrderService-->>APIGateway: Order Confirmation\n    APIGateway-->>Customer: Order Confirmation"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Draw a zenuml diagram representing the data flow in a basic publish-subscribe messaging system.",
        "planning": "**Components:**\n\n*   **Publisher:** Originates messages.\n*   **Subscriber:** Receives messages.\n*   **Broker/Message Queue:** Manages messages and subscriptions.\n*   **Topic/Channel:** Category/group that messages are published to and subscribers subscribe to.\n\n**Interactions:**\n\n1.  **Publisher -> Broker:** Publisher publishes a message to a specific Topic/Channel.\n2.  **Subscriber -> Broker:** Subscriber subscribes to a specific Topic/Channel.\n3.  **Broker -> Subscriber:** Broker forwards messages from the Topic/Channel to all subscribed Subscribers.",
        "output": "zenuml\n  Publisher->Broker: publish(message, Topic)\n  Subscriber->Broker: subscribe(Topic)\n  Broker->Subscriber: forward(message, Topic)"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Generate a zenuml diagram that illustrates the process of packet encapsulation in the TCP/IP networking stack.",
        "planning": "*   **Application Layer:**\n    *   Data: Represents the original data from an application.\n    *   Interaction: Sends data to the Transport Layer.\n\n*   **Transport Layer:**\n    *   TCP Header: Segment header containing source/destination port, sequence number, etc.\n    *   UDP Header: Datagram header containing source/destination port, length, checksum\n    *   Interaction:\n        *   Receives data from the Application Layer.\n        *   Adds TCP or UDP header to create a segment or datagram.\n        *   Sends the segment/datagram to the Network Layer.\n\n*   **Network Layer:**\n    *   IP Header: Packet header containing source/destination IP address, TTL, etc.\n    *   Interaction:\n        *   Receives segment/datagram from the Transport Layer.\n        *   Adds IP header to create a packet.\n        *   Sends the packet to the Data Link Layer.\n\n*   **Data Link Layer:**\n    *   Ethernet Header/Trailer: Frame header (MAC addresses, EtherType) and trailer (FCS).\n    *   Interaction:\n        *   Receives packet from the Network Layer.\n        *   Adds Ethernet header and trailer to create a frame.\n        *   Transmits the frame over the physical network.\n\n*   **Physical Layer:**\n    *   Represents the physical medium (cable, wireless).\n    *   Interaction: Transmits/receives the frame as bits.\n\n*   **Arrows:**\n    *   Downwards arrows indicating encapsulation as data moves down the stack. Labeled with \"Encapsulation\" or \"Adds Header\".\n    *   Upwards arrows (in a receiving host diagram - omitted here for simplicity), indicating decapsulation, Labeled with \"Decapsulation\" or \"Removes Header\".",
        "output": "zenuml\n  Application as App\n  Transport as Trans\n  Network as Net\n  DataLink as Data\n  Physical as Phys\n\n  App->Trans: Data\n  // Encapsulation\n  Trans->Net: Adds TCP/UDP Header\n  // Encapsulation\n  Net->Data: Adds IP Header\n  // Encapsulation\n  Data->Phys: Adds Ethernet Header and Trailer\n  // Transmission\n\n  note right of App: Application Layer\n  note right of Trans: Transport Layer\n  note right of Net: Network Layer\n  note right of Data: Data Link Layer\n  note right of Phys: Physical Layer"
    },
    {
        "diagram_type": "zenuml",
        "prompt": "Create a zenuml diagram visualizing the user authentication flow in a single sign-on (SSO) system.",
        "planning": "*   **User:** Initiates login.\n*   **Service Provider (SP):** Application user wants to access.\n*   **SSO Identity Provider (IdP):** Manages user identities and authentication.\n*   **Browser:** Facilitates communication (HTTP redirects).\n\n**Interactions:**\n\n1.  User attempts to access SP.\n2.  SP redirects user to IdP for authentication.\n3.  User authenticates at IdP (login).\n4.  IdP redirects user back to SP with an authentication assertion (e.g., SAML token).\n5.  SP validates the assertion.\n6.  SP grants access to the user.",
        "output": "zenuml\n  User\n  Browser\n  SP as ServiceProvider\n  IdP as IdentityProvider\n\n  User->Browser: Access SP\n  Browser->SP: Request resource\n  SP->Browser: Redirect to IdP\n  Browser->IdP: Authentication request\n  IdP->Browser: Authentication page\n  Browser->IdP: User credentials\n  IdP->IdP: Validate credentials\n  IdP->Browser: Redirect to SP with assertion\n  Browser->SP: Authentication assertion\n  SP->SP: Validate assertion\n  SP->Browser: Grant access\n  Browser->User: Access granted"
    }
]