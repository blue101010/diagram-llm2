[
  {
    "prompt": "Construct a packet diagram titled 'ARP Reply'. Include Hardware Type (0-15), Protocol Type (16-31), Hardware Address Length (32-39), Protocol Address Length (40-47), Opcode (48-63), Sender MAC (64-111), Sender IP (112-143), Target MAC (144-191), and Target IP (192-223).",
    "expected_output": "packet-beta\ntitle ARP Reply\n0-15: \"Hardware Type\"\n16-31: \"Protocol Type\"\n32-39: \"Hardware Address Length\"\n40-47: \"Protocol Address Length\"\n48-63: \"Opcode\"\n64-111: \"Sender MAC\"\n112-143: \"Sender IP\"\n144-191: \"Target MAC\"\n192-223: \"Target IP\"",
    "models": {
      "gemma-3-27b-it": "packet \"ARP Reply\"\n    Hardware Type : 0-15\n    Protocol Type : 16-31\n    Hardware Address Length : 32-39\n    Protocol Address Length : 40-47\n    Opcode : 48-63\n    Sender MAC : 64-111\n    Sender IP : 112-143\n    Target MAC : 144-191\n    Target IP : 192-223",
      "fine-tuned": "Okay, here's a text-based packet diagram representing an ARP Reply.  I'll use a table format to clearly show the fields, their bit offsets, lengths, and example values.  Since I can't *draw* a diagram, this is the best representation I can provide.  I'll also include explanations of the fields.\n\n**ARP Reply Packet Diagram**\n\n**Title: ARP Reply**\n\n| **Field Name**          | **Bit Offset** | **Length (bits)** | **Length (bytes)** | **Example Value (Hex)** | **Description**"
    }
  },
  {
    "prompt": "Generate a packet diagram representing a DNS Query packet structure (simplified). Include Transaction ID (0-15), Flags (16-31), Questions Count (32-47), Answer RRs Count (48-63), Authority RRs Count (64-79), and Additional RRs Count (80-95).",
    "expected_output": "packet-beta\ntitle DNS Query Header\n0-15: \"Transaction ID\"\n16-31: \"Flags\"\n32-47: \"Questions Count\"\n48-63: \"Answer RRs Count\"\n64-79: \"Authority RRs Count\"\n80-95: \"Additional RRs Count\"",
    "models": {
      "gemma-3-27b-it": "packet \"DNS Query Packet\"\n  byte \"Transaction ID\" : 0-15\n  byte \"Flags\" : 16-31\n  byte \"Questions Count\" : 32-47\n  byte \"Answer RRs Count\" : 48-63\n  byte \"Authority RRs Count\" : 64-79\n  byte \"Additional RRs Count\" : 80-95",
      "fine-tuned": "Okay, here's a text-based packet diagram representing a simplified DNS Query packet structure.  I'll use a visual style that's common for these diagrams.  I'll also include explanations of the fields and their typical sizes.  Since I can't *draw* a diagram, I'll use ASCII art and text formatting to approximate it.\n\n```\n+-----------------------------------------------------------------+\n| DNS Query Packet (Simplified)                                   |\n+-----------------------------------------------------------------+\n|  0-15: Transaction ID (2 bytes)                               |\n|-----------------------------------------------------------------|\n|  16-31: Flags (2 bytes)                                        |\n|   - Recursion Desired (RD)                                     |\n|   - Truncation (TC)                                            |\n|   - Authoritative Answer (AA)                                  |\n|   - ... other flags ...                                        |\n|-----------------------------------------------------------------|\n|  32-47: Questions Count (2 bytes)                             |\n|-----------------------------------------------------------------|\n|  48-63: Answer RRs Count (2 bytes)                            |\n|-----------------------------------------------------------------|\n|  64-79: Authority RRs Count (2 bytes)                         |\n|-----------------------------------------------------------------|\n|  80-95: Additional RRs Count (2 bytes)                        |\n|-----------------------------------------------------------------|\n|  96 - ...:  Question Section (Variable Length)                 |\n|   - QNAME (Domain Name)                                        |\n|   - QTYPE (Query Type - e.g., A, AAAA, MX)                    |\n|   - QCLASS (Query Class - usually IN for Internet)             |\n|-----------------------------------------------------------------|\n|  ... : Answer Section (Variable Length - if Answer RRs > 0)    |\n|  ... : Authority Section (Variable Length - if Authority RRs > 0)|\n|  ... : Additional Section (Variable Length - if Additional RRs > 0)|\n+-----------------------------------------------------------------+\n```\n\n**Explanation of Fields:**\n\n*   **Transaction ID (0-15, 2 bytes):**  A random ID assigned by the client to match the response to the query.  This is crucial for handling asynchronous DNS lookups.  It's a 16-bit integer.\n\n*   **Flags (16-31, 2 bytes):**  A set of bits that control various aspects of the query and response.  Some important flags include:\n    *   **Recursion Desired (RD):**  If set, the client wants the DNS server to perform recursive lookups (i.e., query other servers on behalf of the client).  This is the most common setting for client queries.\n    *   **Truncation (TC):**  If set, the response was truncated because it exceeded the maximum UDP packet size.  The client should then retry the query using TCP.\n    *   **Authoritative Answer (AA):** If set, the responding server is an authoritative server for the domain.\n    *   There are many other flags related to caching, checking, and response validity.\n\n*   **Questions Count (32-47, 2 bytes):**  The number of questions included in the query.  Typically, a DNS query contains only one question.\n\n*   **Answer RRs Count (48-63, 2 bytes):**  The number of Resource Records (RRs) in the answer section.  This will be 0 if the server doesn't have an answer.\n\n*   **Authority RRs Count (64-79, 2 bytes):**  The number of Resource Records in the authority section.  This section contains information about authoritative name servers for the domain.\n\n*   **Additional RRs Count (80-95, 2 bytes):**  The number of Resource Records in the additional section.  This section can contain helpful information, such as IP addresses for the authoritative name servers.\n\n*   **Question Section (96-..., Variable Length):** This section contains the actual query.\n    *   **QNAME:** The domain name being queried (e.g., `www.example.com`).  It's represented as a series of labels, each preceded by its length.\n    *   **QTYPE:** The type of record being requested (e.g., `A` for IPv4 address, `AAAA` for IPv6 address, `MX` for mail exchange).\n    *   **QCLASS:** The class of the query (usually `IN` for Internet).\n\n*   **Answer, Authority, and Additional Sections (..., Variable Length):** These sections contain the responses to the query, information about authoritative servers, and additional helpful data, respectively.  Each section consists of Resource Records (RRs).  The format of an RR depends on its type (e.g., A, AAAA, MX).\n\n**Important Notes:**\n\n*   **Byte Order:** DNS packets use network byte order (big-endian).\n*   **Variable Length:** The Question, Answer, Authority, and Additional sections have variable lengths, depending on the data they contain.\n*   **UDP vs. TCP:** DNS queries are typically sent over UDP for small responses.  If the response is too large for UDP, TCP is used.\n*   **Simplification:** This diagram is a simplified representation.  The full DNS packet format is more complex.  I've omitted details like the RCODE (Response Code) in the Flags section for clarity.\n*   **Resource Records (RRs):**  The structure of RRs is complex and depends on the QTYPE.  They contain fields like Name, Type, Class, TTL (Time To Live), and RDATA (the actual data).\n\nThis diagram should give you a good overview of the basic structure of a DNS Query packet.  Let me know if you'd like me to elaborate on any specific aspect or field."
    }
  },
  {
    "prompt": "Junction `J_split`. Junction `J_merge`. Services `Source` (disk, \"Src\"), `WorkerA` (server, \"WA\"), `WorkerB` (server, \"WB\"), `Sink` (disk, \"Sink\"). Connect `Source`:R --> `L:J_split`. Connect `J_split`:T --> `L:WorkerA`. Connect `J_split`:B --> `L:WorkerB`. Connect `WorkerA`:R --> `L:J_merge`. Connect `WorkerB`:R --> `T:J_merge`. Connect `J_merge`:R --> `L:Sink`.",
    "expected_output": "architecture-beta\n    junction J_split\n    junction J_merge\n\n    service Source(disk)[Src]\n    service WorkerA(server)[WA]\n    service WorkerB(server)[WB]\n    service Sink(disk)[Sink]\n\n    Source:R --> L:J_split\n    J_split:T --> L:WorkerA\n    J_split:B --> L:WorkerB\n    WorkerA:R --> L:J_merge\n    WorkerB:R --> T:J_merge\n    J_merge:R --> L:Sink",
    "models": {
      "gemma-3-27b-it": "graph LR\n    Src[Source] -- R --> J_split\n    J_split -- T --> WA[WorkerA]\n    J_split -- B --> WB[WorkerB]\n    WA -- R --> J_merge\n    WB -- R --> J_merge\n    J_merge -- R --> Sink[Sink]\n    classDef disk fill:#f9f,stroke:#333,stroke-width:2px\n    classDef server fill:#ccf,stroke:#333,stroke-width:2px\n    class Src,Sink disk\n    class WA,WB server",
      "fine-tuned": "Okay, this describes a data processing pipeline with a split and merge pattern. Here's a breakdown of the pipeline, visualized and explained:\n\n**Pipeline Description:**\n\n*   **Source (Src):**  This is where the data originates. It's a disk-based source.\n*   **J_split:** A junction that splits the incoming data stream into two separate streams.  Think of it as a \"tee\" or a distributor.\n*   **WorkerA (WA):** A server that processes one part of the split data.\n*   **WorkerB (WB):** A server that processes the other part of the split data.\n*   **J_merge:** A junction that merges the two processed data streams back into a single stream.\n*   **Sink:** The final destination for the processed data. It's a disk-based sink.\n\n**Connections (and their meaning):**\n\n*   **`Source`:R --> `L:J_split`:**  Data flows *from* the `Source` (specifically, its \"Right\" output) *to* the \"Left\" input of the `J_split` junction.  This is the initial data input.\n*   **`J_split`:T --> `L:WorkerA`:** The `J_split` junction sends the data from its \"Top\" output *to* the \"Left\" input of `WorkerA`.  This is one branch of the split data.\n*   **`J_split`:B --> `L:WorkerB`:** The `J_split` junction sends the data from its \"Bottom\" output *to* the \"Left\" input of `WorkerB`. This is the other branch of the split data.\n*   **`WorkerA`:R --> `L:J_merge`:**  `WorkerA` processes its data and sends the result from its \"Right\" output *to* the \"Left\" input of the `J_merge` junction.\n*   **`WorkerB`:R --> `T:J_merge`:** `WorkerB` processes its data and sends the result from its \"Right\" output *to* the \"Top\" input of the `J_merge` junction.\n*   **`J_merge`:R --> `L:Sink`:** The `J_merge` junction combines the data from `WorkerA` and `WorkerB` and sends the merged result from its \"Right\" output *to* the \"Left\" input of the `Sink`.\n\n**Visual Representation (Conceptual):**\n\n```\n   Src (Disk)\n      | R\n      v\n   J_split\n   /    \\\n  T      B\n /        \\\nv          v\nWA (Server) WB (Server)\n | R        | R\n \\          /\n  v        v\n   J_merge\n      | R\n      v\n   Sink (Disk)\n```\n\n**Purpose/Use Case:**\n\nThis pipeline is designed for parallel processing.  The `J_split` junction divides the workload between `WorkerA` and `WorkerB`.  This can significantly speed up processing if the tasks performed by `WorkerA` and `WorkerB` are independent and can be executed concurrently.  The `J_merge` junction then reassembles the results before writing them to the `Sink`.\n\n**Possible Scenarios:**\n\n*   **Image Processing:** `J_split` could divide an image into sections, `WorkerA` and `WorkerB` could process those sections (e.g., apply filters), and `J_merge` would reassemble the processed image.\n*   **Log Analysis:** `J_split` could distribute log files, `WorkerA` and `WorkerB` could analyze them for specific patterns, and `J_merge` would combine the analysis results.\n*   **Data Transformation:** `J_split` could divide a dataset, `WorkerA` and `WorkerB` could perform different transformations on their respective subsets, and `J_merge` would combine the transformed data.\n\n**Key Considerations:**\n\n*   **Data Partitioning:** How the `J_split` junction divides the data is crucial.  It needs to be done in a way that balances the workload between `WorkerA` and `WorkerB`.\n*   **Data Ordering:**  If the order of the data is important, the `J_merge` junction needs to ensure that the data is reassembled in the correct order.  The \"T\" input to `J_merge` suggests a possible ordering consideration.\n*   **Error Handling:**  The pipeline needs to handle errors that might occur in `WorkerA` or `WorkerB`.\n\n\n\nThis detailed explanation should give you a good understanding of the pipeline described by your input.  Let me know if you'd like me to elaborate on any specific aspect or consider a particular use case."
    }
  },
  {
    "prompt": "Draw a User Journey diagram for 'Preparing a Presentation'. Title: 'Presentation Prep'. Sections: 'Planning & Research', 'Content Creation', 'Design', 'Practice'. Planning & Research: 'Define Objective & Audience' (score 5, actor: Presenter), 'Gather Information & Data' (score 6, actor: Presenter), 'Outline Key Points' (score 4, actor: Presenter). Content Creation: 'Write Script/Talking Points' (score 7, actor: Presenter), 'Develop Core Content for Slides' (score 6, actor: Presenter). Design: 'Choose Presentation Template' (score 3, actor: Presenter), 'Create/Format Slides' (score 5, actor: Presenter), 'Add Visuals (Images, Charts)' (score 4, actor: Presenter). Practice: 'Rehearse Delivery & Timing' (score 8, actor: Presenter), 'Get Feedback (Optional)' (score 5, actors: Presenter, Colleague), 'Finalize Slides & Notes' (score 3, actor: Presenter).",
    "expected_output": "journey\n    title Presentation Prep\n    section Planning & Research\n      Define Objective & Audience: 5: Presenter\n      Gather Information & Data: 6: Presenter\n      Outline Key Points: 4: Presenter\n    section Content Creation\n      Write Script/Talking Points: 7: Presenter\n      Develop Core Content for Slides: 6: Presenter\n    section Design\n      Choose Presentation Template: 3: Presenter\n      Create/Format Slides: 5: Presenter\n      Add Visuals (Images, Charts): 4: Presenter\n    section Practice\n      Rehearse Delivery & Timing: 8: Presenter\n      Get Feedback (Optional): 5: Presenter, Colleague\n      Finalize Slides & Notes: 3: Presenter",
    "models": {
      "gemma-3-27b-it": "journey\n    title Presentation Prep\n\n    section Planning & Research\n      Define Objective & Audience: 5 [Presenter]\n      Gather Information & Data: 6 [Presenter]\n      Outline Key Points: 4 [Presenter]\n\n    section Content Creation\n      Write Script/Talking Points: 7 [Presenter]\n      Develop Core Content for Slides: 6 [Presenter]\n\n    section Design\n      Choose Presentation Template: 3 [Presenter]\n      Create/Format Slides: 5 [Presenter]\n      Add Visuals (Images, Charts): 4 [Presenter]\n\n    section Practice\n      Rehearse Delivery & Timing: 8 [Presenter]\n      Get Feedback (Optional): 5 [Presenter, Colleague]\n      Finalize Slides & Notes: 3 [Presenter]",
      "fine-tuned": "Okay, here's a User Journey diagram for \"Presentation Prep\" based on your specifications.  I'll represent it in a text-based format that aims to visually mimic a journey map.  I'll use indentation to show flow and hierarchy, and include the scores and actors as requested.  I'll also add some emotional indicators (emojis) to give a sense of the user's experience at each stage.  Since I can't *draw* an image, this is the best representation I can provide.\n\n**Presentation Prep - User Journey**\n\n**(Overall Goal: Deliver a compelling and effective presentation)**\n\n---\n\n**1. Planning & Research \ud83e\uddd0 (Generally Feeling: Focused, but potentially overwhelmed)**\n\n   * **Define Objective & Audience**  (Score: 5/10)\n      * Actor: Presenter\n      * Description: Clearly identify the presentation's purpose and who it's for.\n      * Emotional State: \ud83e\udd14 (Thinking, Questioning)\n   * **Gather Information & Data** (Score: 6/10)\n      * Actor: Presenter\n      * Description: Research the topic thoroughly, collecting relevant facts, statistics, and examples.\n      * Emotional State: \ud83e\udd13 (Studious, Engaged)\n   * **Outline Key Points** (Score: 4/10)\n      * Actor: Presenter\n      * Description: Structure the presentation logically, creating a clear outline of main ideas.\n      * Emotional State: \ud83d\ude15 (Slightly Frustrated - structure can be tricky)\n\n   **--> Transition:  \"Now I have a plan, time to build the content!\"**\n\n---\n\n**2. Content Creation \u270d\ufe0f (Generally Feeling: Productive, but potentially writer's block)**\n\n   * **Write Script/Talking Points** (Score: 7/10)\n      * Actor: Presenter\n      * Description: Develop detailed notes or a full script to guide the presentation.\n      * Emotional State: \u270d\ufe0f (Writing, Concentrating)\n   * **Develop Core Content for Slides** (Score: 6/10)\n      * Actor: Presenter\n      * Description:  Translate key points into concise and impactful slide content.\n      * Emotional State: \ud83d\udca1 (Idea Generation, Progress)\n\n   **--> Transition: \"Content is ready, let's make it look good!\"**\n\n---\n\n**3. Design \ud83c\udfa8 (Generally Feeling: Creative, but potentially detail-oriented/frustrated)**\n\n   * **Choose Presentation Template** (Score: 3/10)\n      * Actor: Presenter\n      * Description: Select a visually appropriate and professional template.\n      * Emotional State: \ud83d\ude29 (Slightly Annoyed - Template selection can be time-consuming)\n   * **Create/Format Slides** (Score: 5/10)\n      * Actor: Presenter\n      * Description: Populate the template with content, ensuring consistent formatting.\n      * Emotional State: \ud83d\udcbb (Working, Focused)\n   * **Add Visuals (Images, Charts)** (Score: 4/10)\n      * Actor: Presenter\n      * Description: Enhance slides with relevant images, charts, and graphs.\n      * Emotional State: \u2728 (Adding polish, Improving aesthetics)\n\n   **--> Transition: \"Slides are looking good, time to practice!\"**\n\n---\n\n**4. Practice \ud83c\udfa4 (Generally Feeling: Nervous, but building confidence)**\n\n   * **Rehearse Delivery & Timing** (Score: 8/10)\n      * Actor: Presenter\n      * Description: Practice the presentation multiple times, focusing on pacing, clarity, and delivery.\n      * Emotional State: \ud83d\ude2c (Nervous, but determined) -> \ud83d\ude0a (More Confident with each run-through)\n   * **Get Feedback (Optional)** (Score: 5/10)\n      * Actors: Presenter, Colleague\n      * Description: Present to a colleague and solicit constructive criticism.\n      * Emotional State: \ud83e\udee3 (Vulnerable, Open to Improvement)\n   * **Finalize Slides & Notes** (Score: 3/10)\n      * Actor: Presenter\n      * Description: Make final adjustments based on practice and feedback.\n      * Emotional State: \u2705 (Completed, Ready to Go!)\n\n---\n\n**Final State: Confident and Prepared to Deliver! \ud83c\udf89**\n\n\n\n**Key:**\n\n*   **Score:**  Represents the perceived effort/difficulty/enjoyment of the task (1-10, 1 being very difficult/unenjoyable, 10 being very easy/enjoyable).\n*   **Actor:**  Who is performing the task.\n*   **Emotional State:**  A quick indication of how the presenter might *feel* during that stage.\n*   **--> Transition:**  A brief statement to show the flow between stages.\n\n\n\n**Important Considerations (If this were a real, visual diagram):**\n\n*   **Visual Flow:**  Arrows would clearly connect each step in the journey.\n*   **Pain Points:**  Areas with lower scores would be highlighted as potential pain points.\n*   **Opportunities:**  Areas where the experience could be improved.\n*   **Timeline:**  A rough timeline could be added to show how long each stage typically takes.\n\n\n\nI hope this text-based representation is helpful!  Let me know if you'd like me to modify it in any way."
    }
  },
  {
    "prompt": "Generate a packet diagram showing a structure with overlapping bit range descriptions (for syntax demonstration, though potentially invalid semantically): Part 1 (0-15), Part 2 (16-31), Part 3 (32-47), Part 4 (48-63).",
    "expected_output": "packet-beta\ntitle Example Packet Structure\n0-15: \"Part 1\"\n16-31: \"Part 2\"\n32-47: \"Part 3\"\n48-63: \"Part 4\"",
    "models": {
      "gemma-3-27b-it": "packetDiagram\n    participant Packet\n    Packet -> Part1 : 0-15\n    Packet -> Part2 : 16-31\n    Packet -> Part3 : 32-47\n    Packet -> Part4 : 48-63",
      "fine-tuned": "Okay, here's a text-based packet diagram illustrating overlapping bit ranges, as requested.  I'll use a simple ASCII art style.  I'll also include explanations to clarify the structure.  Because the ranges *do* overlap, I'll highlight that visually and add a note about the semantic implications.\n\n```\n+-----------------------------------------------------------------+\n| Packet Structure (Demonstration of Overlapping Bit Ranges)      |\n+-----------------------------------------------------------------+\n| Bit Range: 0-63                                                 |\n+-----------------------------------------------------------------+\n|   0-15 | Part 1  |----------------------------------------------|\n|        |         |                                              |\n|        |         |   16-31 | Part 2  |--------------------------|\n|        |         |         |         |                          |\n|        |         |         |         |   32-47 | Part 3  |--------|\n|        |         |         |         |         |         |        |\n|        |         |         |         |         |         |   48-63| Part 4|\n|        |         |         |         |         |         |        |\n+--------+---------+---------+---------+---------+---------+--------+\n|        |         |         |         |         |         |        |\n|        |         |         |         |         |         |        |\n|  Overlap Areas:                                                 |\n|  - 16-15: Part 1 & Part 2                                      |\n|  - 32-31: Part 2 & Part 3                                      |\n|  - 48-47: Part 3 & Part 4                                      |\n+-----------------------------------------------------------------+\n| NOTE: This structure is likely semantically invalid.  Overlapping|\n| bit ranges typically lead to ambiguity in interpretation.      |\n| This is for demonstration of the diagramming concept only.      |\n+-----------------------------------------------------------------+\n```\n\n**Explanation:**\n\n*   **Overall Structure:** The diagram represents a packet or data structure that is 64 bits wide (0-63).\n*   **Parts:**  The structure is divided into four parts: Part 1, Part 2, Part 3, and Part 4.\n*   **Bit Ranges:** Each part is assigned a bit range:\n    *   Part 1: 0-15\n    *   Part 2: 16-31\n    *   Part 3: 32-47\n    *   Part 4: 48-63\n*   **Overlap:**  The key feature is the intentional overlap.  Each part overlaps with the next one by a single bit.  I've visually indicated the overlap areas in the \"Overlap Areas\" section.\n*   **Note:** The \"NOTE\" section is crucial.  In a real-world scenario, this kind of overlapping definition would almost certainly be a mistake.  It would create ambiguity about which part \"owns\" the overlapping bits.  This diagram is purely for illustrating how to represent such a structure visually.\n\n**How to interpret the diagram:**\n\nThe diagram shows how the bit ranges are laid out within the overall packet.  The lines and labels help to visualize the boundaries of each part and the areas where they overlap.  The overlap areas are explicitly called out to emphasize the potential problem.\n\n**Possible Use Cases (for why you might *want* to visualize this, even if it's invalid):**\n\n*   **Debugging:**  You might encounter a poorly designed protocol or data format where such overlaps exist.  Visualizing it can help you understand the problem.\n*   **Reverse Engineering:**  When analyzing an unknown data format, you might initially misinterpret the bit ranges and create a diagram like this before realizing the overlap.\n*   **Educational Purpose:**  As in this case, to demonstrate how to represent bit ranges and overlaps in a diagram.\n*   **Hypothetical Scenarios:**  Exploring unusual or experimental data structures.\n\n**Tools for creating more sophisticated diagrams:**\n\nWhile this ASCII art is sufficient for a simple demonstration, for more complex packet structures, consider using dedicated tools:\n\n*   **PacketViz:** A web-based tool for creating packet diagrams.\n*   **Wireshark's Display Filter Syntax:**  Wireshark's display filters can be used to highlight specific bit ranges in captured packets.\n*   **Draw.io (Diagrams.net):** A general-purpose diagramming tool that can be used to create custom packet diagrams.\n*   **Microsoft Visio:** Another general-purpose diagramming tool.\n*   **Specialized Protocol Editors:** Some protocol editors have built-in diagramming features.\n\nLet me know if you'd like me to modify this diagram or create a more complex one!  For example, I could add more parts, different bit ranges, or more detailed labels."
    }
  },
  {
    "prompt": "Construct a diagram with multiple services within nested groups connected via junctions: Group `region` (cloud)[Region] contains Group `vpc` (cloud)[VPC]. Group `vpc` contains Group `subnet_a` (cloud)[SubnetA] and Group `subnet_b` (cloud)[SubnetB]. `subnet_a` contains `service_a1` (server)[A1] and `service_a2` (server)[A2]. `subnet_b` contains `service_b1` (database)[B1]. Junction `j_a` is in `subnet_a`. Junction `j_b` is in `subnet_b`. Connect `service_a1`:R to `j_a`:L. Connect `service_a2`:B to `j_a`:T. Connect `j_a`:R to `j_b`:L (`-->`). Connect `j_b`:R to `service_b1`:L (`-->`).",
    "expected_output": "architecture-beta\n    group region(cloud)[Region]\n    group vpc(cloud)[VPC] in region\n    group subnet_a(cloud)[SubnetA] in vpc\n    group subnet_b(cloud)[SubnetB] in vpc\n\n    service service_a1(server)[A1] in subnet_a\n    service service_a2(server)[A2] in subnet_a\n    service service_b1(database)[B1] in subnet_b\n\n    junction j_a in subnet_a\n    junction j_b in subnet_b\n\n    service_a1:R -- L:j_a\n    service_a2:B -- T:j_a\n    j_a:R --> L:j_b\n    j_b:R --> L:service_b1",
    "models": {
      "gemma-3-27b-it": "graph LR\n    subgraph region [Region]\n        subgraph vpc [VPC]\n            subgraph subnet_a [SubnetA]\n                service_a1(A1) -- R --> j_a\n                service_a2(A2) -- B --> j_a\n                j_a\n            end\n            subgraph subnet_b [SubnetB]\n                j_b\n                service_b1(B1) -- L --> j_b\n            end\n            j_a -- R --> j_b\n        end\n    end\n    style service_a1 fill:#f9f,stroke:#333,stroke-width:2px\n    style service_a2 fill:#f9f,stroke:#333,stroke-width:2px\n    style service_b1 fill:#ccf,stroke:#333,stroke-width:2px\n    style j_a fill:#ffc,stroke:#333,stroke-width:2px\n    style j_b fill:#ffc,stroke:#333,stroke-width:2px",
      "fine-tuned": "graph LR\n    subgraph Region [Region (cloud)]\n        subgraph VPC [VPC (cloud)]\n            subgraph SubnetA [SubnetA (cloud)]\n                service_a1(A1) -- R --> j_a(j_a)\n                service_a2(A2) -- B --> j_a\n            end\n            subgraph SubnetB [SubnetB (cloud)]\n                j_b(j_b) -- R --> service_b1(B1)\n            end\n        end\n    end\n\n    j_a -- R --> j_b\n    \n    classDef server fill:#f9f,stroke:#333,stroke-width:2px\n    classDef database fill:#ccf,stroke:#333,stroke-width:2px\n    classDef cloud fill:#eee,stroke:#333,stroke-width:2px\n\n    class service_a1,service_a2 server;\n    class service_b1 database;\n    class Region,VPC,SubnetA,SubnetB cloud;"
    }
  },
  {
    "prompt": "Create a block diagram with 4 blocks 'N1', 'N2', 'N3', 'N4' arranged in a 2x2 grid using 2 columns. Connect 'N1' to 'N2', 'N2' to 'N4', 'N4' to 'N3', and 'N3' to 'N1'. Use stadium shapes for all blocks.",
    "expected_output": "block-beta\n  columns 2\n  N1([\"N1\"]) N2([\"N2\"])\n  N3([\"N3\"]) N4([\"N4\"])\n  N1 --> N2\n  N2 --> N4\n  N4 --> N3\n  N3 --> N1",
    "models": {
      "gemma-3-27b-it": "st=>start: N1\nop1=>op: N2\nop2=>op: N3\nop3=>op: N4\n\nst --> op1\nop1 --> op3\nop3 --> op2\nop2 --> st",
      "fine-tuned": "graph TD\n    subgraph Grid\n        N1[Stadium: N1] --> N2[Stadium: N2]\n        N2 --> N4[Stadium: N4]\n        N4 --> N3[Stadium: N3]\n        N3 --> N1\n    end\n    style Grid fill:#f9f,stroke:#333,stroke-width:2px"
    }
  },
  {
    "prompt": "Construct a Kanban board with columns 'Draft' (id: draft), 'Review' (id: review), 'Approved' (id: approved). Add task 'Policy Update v1' (id: polUpd1) with metadata assigned: 'Yara', ticket: 'POL-01' to 'Draft'. Add task 'Procedure Manual v2' (id: procMan2) with metadata priority: 'High' to 'Review'. Add task 'Guideline Doc v3' (id: guideDoc3) with metadata assigned: 'Zara', ticket: 'GUIDE-03' to 'Approved'.",
    "expected_output": "kanban\n  draft[Draft]\n    polUpd1[Policy Update v1]@{ assigned: 'Yara', ticket: 'POL-01' }\n  review[Review]\n    procMan2[Procedure Manual v2]@{ priority: 'High' }\n  approved[Approved]\n    guideDoc3[Guideline Doc v3]@{ assigned: 'Zara', ticket: 'GUIDE-03' }",
    "models": {
      "gemma-3-27b-it": "kanban\n    column \"Draft\" id: draft\n    column \"Review\" id: review\n    column \"Approved\" id: approved\n\n    card \"Policy Update v1\" id: polUpd1 in draft assigned: Yara ticket: POL-01\n    card \"Procedure Manual v2\" id: procMan2 in review priority: High\n    card \"Guideline Doc v3\" id: guideDoc3 in approved assigned: Zara ticket: GUIDE-03",
      "fine-tuned": "```json\n{\n  \"board\": {\n    \"columns\": [\n      {\n        \"id\": \"draft\",\n        \"name\": \"Draft\",\n        \"tasks\": [\n          {\n            \"id\": \"polUpd1\",\n            \"name\": \"Policy Update v1\",\n            \"metadata\": {\n              \"assigned\": \"Yara\",\n              \"ticket\": \"POL-01\"\n            }\n          }\n        ]\n      },\n      {\n        \"id\": \"review\",\n        \"name\": \"Review\",\n        \"tasks\": [\n          {\n            \"id\": \"procMan2\",\n            \"name\": \"Procedure Manual v2\",\n            \"metadata\": {\n              \"priority\": \"High\"\n            }\n          }\n        ]\n      },\n      {\n        \"id\": \"approved\",\n        \"name\": \"Approved\",\n        \"tasks\": [\n          {\n            \"id\": \"guideDoc3\",\n            \"name\": \"Guideline Doc v3\",\n            \"metadata\": {\n              \"assigned\": \"Zara\",\n              \"ticket\": \"GUIDE-03\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**Explanation:**\n\n* **`board`:**  The root object containing the entire Kanban board.\n* **`columns`:** An array of column objects.\n* **`id`:**  Unique identifier for each column (draft, review, approved).\n* **`name`:**  The human-readable name of the column.\n* **`tasks`:** An array of task objects within each column.\n* **`id`:** Unique identifier for each task (polUpd1, procMan2, guideDoc3).\n* **`name`:** The human-readable name of the task.\n* **`metadata`:**  An object containing additional information about the task.  This is where the assigned user, priority, ticket number, etc. are stored.  The structure of the metadata is flexible, allowing for different key-value pairs as needed."
    }
  },
  {
    "prompt": "Five services in a line: `S1`, `S2`, `S3`, `S4`, `S5` (all server icon, labels \"S1\"-\"S5\"). Connect `S1`:R --> `L:S2`. `S2`:R --> `L:S3`. `S3`:R --> `L:S4`. `S4`:R --> `L:S5`.",
    "expected_output": "architecture-beta\n    service S1(server)[S1]\n    service S2(server)[S2]\n    service S3(server)[S3]\n    service S4(server)[S4]\n    service S5(server)[S5]\n\n    S1:R --> L:S2\n    S2:R --> L:S3\n    S3:R --> L:S4\n    S4:R --> L:S5",
    "models": {
      "gemma-3-27b-it": "graph LR\n    S1[S1]:::server -- \"R\" --> S2[S2]:::server\n    S2 -- \"R\" --> S3[S3]:::server\n    S3 -- \"R\" --> S4[S4]:::server\n    S4 -- \"R\" --> S5[S5]:::server\n    classDef server fill:#f9f,stroke:#333,stroke-width:2px",
      "fine-tuned": "graph LR\n    S1[S1] -- L:S2 --> S2[S2]\n    S2 -- L:S3 --> S3[S3]\n    S3 -- L:S4 --> S4[S4]\n    S4 -- L:S5 --> S5[S5]"
    }
  },
  {
    "prompt": "Construct a packet diagram titled 'Broadcast Message'. Include: Message ID (0-15), Source Group (16-31), Message Priority (32-35), Message TTL (36-43), and Broadcast Payload (44-299).",
    "expected_output": "packet-beta\ntitle Broadcast Message\n0-15: \"Message ID\"\n16-31: \"Source Group\"\n32-35: \"Message Priority\"\n36-43: \"Message TTL\"\n44-299: \"Broadcast Payload\"",
    "models": {
      "gemma-3-27b-it": "packet \"Broadcast Message\"\n    0-15 : Message ID\n    16-31 : Source Group\n    32-35 : Message Priority\n    36-43 : Message TTL\n    44-299 : Broadcast Payload",
      "fine-tuned": "Okay, here's a text-based packet diagram representing a \"Broadcast Message\" structure, as you requested.  I'll use a table format to clearly show the bit ranges and their corresponding fields.  I'll also include some notes about the fields.  Since I can't *draw* a diagram, this is the best representation I can provide.  I'll also add a little explanation after the table.\n\n**Broadcast Message Packet Diagram**\n\n| **Bit Range** | **Field Name**       | **Size (bits)** | **Description**"
    }
  },
  {
    "prompt": "Construct an xyChart with a numeric x-axis having negative range. Title: \"Negative X Range\". X-axis: \"Position\", -5 --> 5. Y-axis: \"Strength\", 0 --> 100. Line data: [20, 40, 80, 100, 90, 70, 50, 30, 25, 10, 5]. Bar data: [10, 30, 60, 90, 95, 75, 55, 35, 20, 15, 8].",
    "expected_output": "xychart-beta\n    title \"Negative X Range\"\n    x-axis \"Position\" -5 --> 5\n    y-axis \"Strength\" 0 --> 100\n    line [20, 40, 80, 100, 90, 70, 50, 30, 25, 10, 5]\n    bar [10, 30, 60, 90, 95, 75, 55, 35, 20, 15, 8]",
    "models": {
      "gemma-3-27b-it": "xyChart\n  title Negative X Range\n  xAxisPosition X\n  xAxisRange -5 5\n  yAxisRange 0 100\n  xAxisLabel Position\n  yAxisLabel Strength\n  line \"Line Data\" : -5,20 -4,40 -3,80 -2,100 -1,90 0,70 1,50 2,30 3,25 4,10 5,5\n  bar \"Bar Data\" : -5,10 -4,30 -3,60 -2,90 -1,95 0,75 1,55 2,35 3,20 4,15 5,8",
      "fine-tuned": "```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data\nx = np.arange(-5, 6)  # x-axis values from -5 to 5\nline_data = [20, 40, 80, 100, 90, 70, 50, 30, 25, 10, 5]\nbar_data = [10, 30, 60, 90, 95, 75, 55, 35, 20, 15, 8]\n\n# Create the plot\nplt.figure(figsize=(10, 6))  # Adjust figure size for better readability\n\n# Plot the line data\nplt.plot(x, line_data, marker='o', linestyle='-', color='blue', label='Line Data')\n\n# Plot the bar data\nplt.bar(x, bar_data, color='orange', label='Bar Data', width=0.5)  # Adjust width as needed\n\n# Set the title and axis labels\nplt.title(\"Negative X Range\")\nplt.xlabel(\"Position\")\nplt.ylabel(\"Strength\")\n\n# Set the axis limits\nplt.xlim(-5, 5)\nplt.ylim(0, 100)\n\n# Add a grid for better readability\nplt.grid(True)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n```\n\nKey improvements and explanations:\n\n* **Uses `matplotlib`:** This is the standard Python library for creating plots.  It's much more flexible and powerful than trying to create a chart from scratch.\n* **`numpy` for x-axis:**  Uses `np.arange(-5, 6)` to create the x-axis values. This is the correct way to generate a sequence of numbers including -5 up to (but not including) 6, giving us the desired -5 to 5 range.\n* **Clear Data Definition:**  The data is clearly defined as lists.\n* **`plt.plot` for line:** Uses `plt.plot` to create the line chart.  `marker='o'` adds markers to the line, `linestyle='-'` makes it a solid line, and `color='blue'` sets the color.\n* **`plt.bar` for bars:** Uses `plt.bar` to create the bar chart.  `color='orange'` sets the color, and `width=0.5` controls the width of the bars.  Adjust the width as needed to make the chart look good.\n* **Axis Labels and Title:**  Sets the title and axis labels for clarity.\n* **Axis Limits:**  `plt.xlim(-5, 5)` and `plt.ylim(0, 100)` explicitly set the axis limits as requested.  This is important to ensure the chart displays the data correctly.\n* **Grid:**  `plt.grid(True)` adds a grid to the plot, making it easier to read the values.\n* **Legend:** `plt.legend()` adds a legend to identify the line and bar data.\n* **Figure Size:** `plt.figure(figsize=(10, 6))` adjusts the figure size for better readability.  You can change these values to suit your needs.\n* **`plt.show()`:**  Displays the plot.\n\nHow to run the code:\n\n1. **Install `matplotlib` and `numpy`:**\n   ```bash\n   pip install matplotlib numpy\n   ```\n2. **Save the code:** Save the code as a Python file (e.g., `xy_chart.py`).\n3. **Run the file:**\n   ```bash\n   python xy_chart.py\n   ```\n\nThis will display the xyChart with the specified data, title, axis labels, and limits.  The line and bar data will be clearly visible."
    }
  },
  {
    "prompt": "Create a block diagram with 4 columns. 'CompA', 'CompB', 'CompC', 'CompD'. Make A=circle, B=rectangle, C=rhombus, D=hexagon. Connect A->B, B->C, C->D. Add connection C->A ('Feedback'). Style C fill orange.",
    "expected_output": "block-beta\n  columns 4\n  A((\"CompA\")) B[\"CompB\"] C{\"CompC\"} D{{\"CompD\"}}\n\n  A --> B\n  B --> C\n  C --> D\n  C -- \"Feedback\" --> A\n\n  style C fill:orange",
    "models": {
      "gemma-3-27b-it": "blockdiag\n    A[Circle] --> B[Rectangle]\n    B --> C[Rhombus]\n    C --> D[Hexagon]\n    C --> A [label=\"Feedback\"]\n    style C fill:#FFA500",
      "fine-tuned": "graph TD\n    A(Circle) --> B(Rectangle)\n    B --> C(Rhombus)\n    C --> D(Hexagon)\n    C --> A\n    style C fill:#FFA500,stroke:#333,stroke-width:2px"
    }
  },
  {
    "prompt": "Create a quadrantChart using point styling for stroke-width and stroke-color. Title: \"Stroke Styling Focus\". x-axis \"Width --> Color\". y-axis \"Stroke --> Properties\". Q1-Q4 text. Points: StrokeA [0.2, 0.7] stroke-width: 4px, stroke-color: #800080, StrokeB [0.8, 0.3] radius: 7, stroke-width: 2px, stroke-color: #008000, StrokeC [0.5, 0.5] color: #d3d3d3, stroke-width: 6px, stroke-color: #ff4500.",
    "expected_output": "quadrantChart\n    title Stroke Styling Focus\n    x-axis Width --> Color\n    y-axis Stroke --> Properties\n    quadrant-1 Q1\n    quadrant-2 Q2\n    quadrant-3 Q3\n    quadrant-4 Q4\n    StrokeA: [0.2, 0.7] stroke-width: 4px, stroke-color: #800080\n    StrokeB: [0.8, 0.3] radius: 7, stroke-width: 2px, stroke-color: #008000\n    StrokeC: [0.5, 0.5] color: #d3d3d3, stroke-width: 6px, stroke-color: #ff4500",
    "models": {
      "gemma-3-27b-it": "quadrantChart\n  title Stroke Styling Focus\n  xAxis \"Width --> Color\"\n  yAxis \"Stroke --> Properties\"\n  quadrant1 StrokeA [0.2, 0.7] stroke-width: 4px, stroke-color: #800080\n  quadrant2 StrokeB [0.8, 0.3] radius: 7, stroke-width: 2px, stroke-color: #008000\n  quadrant3 StrokeC [0.5, 0.5] color: #d3d3d3, stroke-width: 6px, stroke-color: #ff4500",
      "fine-tuned": "```python\nimport plotly.graph_objects as go\n\n# Data for the points\npoints = [\n    {\"name\": \"StrokeA\", \"x\": 0.2, \"y\": 0.7, \"stroke_width\": 4, \"stroke_color\": \"#800080\"},\n    {\"name\": \"StrokeB\", \"x\": 0.8, \"y\": 0.3, \"radius\": 7, \"stroke_width\": 2, \"stroke_color\": \"#008000\"},\n    {\"name\": \"StrokeC\", \"x\": 0.5, \"y\": 0.5, \"color\": \"#d3d3d3\", \"stroke_width\": 6, \"stroke_color\": \"#ff4500\"}\n]\n\n# Create the figure\nfig = go.Figure()\n\n# Add scatter traces for each point, styling based on data\nfor point in points:\n    fig.add_trace(go.Scatter(\n        x=[point[\"x\"]],\n        y=[point[\"y\"]],\n        mode='markers',\n        marker=dict(\n            symbol='circle',\n            size=10,  # Adjust size as needed\n            color=point.get(\"color\", \"blue\"), # Default color if not specified\n            line=dict(\n                width=point[\"stroke_width\"],\n                color=point[\"stroke_color\"]\n            )\n        ),\n        text=point[\"name\"],\n        hoverinfo='text'\n    ))\n\n# Customize the layout\nfig.update_layout(\n    title=\"Stroke Styling Focus\",\n    xaxis_title=\"Width --> Color\",\n    yaxis_title=\"Stroke --> Properties\",\n    xaxis_range=[0, 1],\n    yaxis_range=[0, 1],\n    # Add quadrant labels\n    annotations=[\n        dict(x=0.5, y=0.5, xref=\"paper\", yref=\"paper\", text=\"Q1\", showarrow=False),\n        dict(x=0.5, y=0.5, xref=\"paper\", yref=\"paper\", text=\"Q2\", showarrow=False),\n        dict(x=0.5, y=0.5, xref=\"paper\", yref=\"paper\", text=\"Q3\", showarrow=False),\n        dict(x=0.5, y=0.5, xref=\"paper\", yref=\"paper\", text=\"Q4\", showarrow=False)\n    ]\n)\n\n# Show the plot\nfig.show()\n```\n\nKey improvements and explanations:\n\n* **Clearer Data Structure:**  The `points` list now uses dictionaries to store the data for each point, making it much more readable and maintainable.  This is the best practice for handling structured data in Python.\n* **`get()` for Optional Values:**  Uses `point.get(\"color\", \"blue\")` to handle the case where a point might not have a `color` defined.  This prevents errors and provides a default color.\n* **`hoverinfo='text'`:**  This ensures that the point's name is displayed when you hover over it.\n* **`symbol='circle'`:** Explicitly sets the marker symbol to a circle.\n* **Quadrant Labels:** Added annotations to label the quadrants (Q1, Q2, Q3, Q4).  The `xref=\"paper\"` and `yref=\"paper\"` arguments position the annotations relative to the entire plot area.\n* **Axis Ranges:**  Sets `xaxis_range` and `yaxis_range` to [0, 1] to ensure the points are visible within the quadrant.\n* **Concise Code:**  The code is more streamlined and easier to understand.\n* **Correct Styling:**  The `marker` dictionary now correctly applies the `stroke_width` and `stroke_color` to the line around the marker.\n* **Error Handling:** The use of `point.get()` prevents errors if a point doesn't have a specific property.\n* **Comments:** Added comments to explain the purpose of each section of the code.\n\nHow to run this code:\n\n1. **Install Plotly:**  If you don't have it already, install Plotly using pip:\n   ```bash\n   pip install plotly\n   ```\n2. **Save the Code:** Save the code as a Python file (e.g., `quadrant_chart.py`).\n3. **Run the File:** Execute the file from your terminal:\n   ```bash\n   python quadrant_chart.py\n   ```\n\nThis will open the chart in your web browser.  The chart will display the three points with the specified stroke widths and colors, and the quadrant labels will be visible.  Hovering over each point will show its name."
    }
  }
]